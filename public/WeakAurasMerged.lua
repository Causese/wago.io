local L = WeakAuras.L

-- Options translation
L["1 Match"] = "1 Match"
L["Actions"] = "Actions"
L["Activate when the given aura(s) |cFFFF0000can't|r be found"] = "Activate when the given aura(s) |cFFFF0000can't|r be found"
L["Add a new display"] = "Add a new display"
L["Add Dynamic Text"] = "Add Dynamic Text"
L["Addon"] = "Addon"
L["Addons"] = "Addons"
L["Add to group %s"] = "Add to group %s"
L["Add to new Dynamic Group"] = "Add to new Dynamic Group"
L["Add to new Group"] = "Add to new Group"
L["Add Trigger"] = "Add Trigger"
L["A group that dynamically controls the positioning of its children"] = "A group that dynamically controls the positioning of its children"
L["Align"] = "Align"
L["Allow Full Rotation"] = "Allow Full Rotation"
L["Alpha"] = "Alpha"
L["Anchor"] = "Anchor"
L["Anchor Point"] = "Anchor Point"
L["Angle"] = "Angle"
L["Animate"] = "Animate"
L["Animated Expand and Collapse"] = "Animated Expand and Collapse"
L["Animation relative duration description"] = [=[
The duration of the animation relative to the duration of the display, expressed as a fraction (1/2), percentage (50%), or decimal (0.5).
|cFFFF0000Note:|r if a display does not have progress (it has a non-timed event trigger, is an aura with no duration, etc.), the animation will not play.

|cFF4444FFFor Example:|r
If the animation's duration is set to |cFF00CC0010%|r, and the display's trigger is a buff that lasts 20 seconds, the start animation will play for 2 seconds.
If the animation's duration is set to |cFF00CC0010%|r, and the display's trigger is a buff that has no set duration, no start animation will play (although it would if you specified a duration in seconds)."
]=]
L["Animations"] = "Animations"
L["Animation Sequence"] = "Animation Sequence"
L["Aquatic"] = "Aquatic"
L["Aura (Paladin)"] = "Aura"
L["Aura(s)"] = "Aura(s)"
L["Auto"] = "Auto"
L["Auto-cloning enabled"] = "Auto-cloning enabled"
L["Automatic Icon"] = "Automatic Icon"
L["Backdrop Color"] = "Backdrop Color"
L["Backdrop Style"] = "Backdrop Style"
L["Background"] = "Background"
L["Background Color"] = "Background Color"
L["Background Inset"] = "Background Inset"
L["Background Offset"] = "Background Offset"
L["Background Texture"] = "Background Texture"
L["Bar Alpha"] = "Bar Alpha"
L["Bar Color"] = "Bar Color"
L["Bar Color Settings"] = "Bar Color Settings"
L["Bar in Front"] = "Bar in Front"
L["Bar Texture"] = "Bar Texture"
L["Battle"] = "Battle"
L["Bear"] = "Bear"
L["Berserker"] = "Berserker"
L["Blend Mode"] = "Blend Mode"
L["Blood"] = "Blood"
L["Border"] = "Border"
L["Border Color"] = "Border Color"
L["Border Inset"] = "Border Inset"
L["Border Offset"] = "Border Offset"
L["Border Settings"] = "Border Settings"
L["Border Size"] = "Border Size"
L["Border Style"] = "Border Style"
L["Bottom Text"] = "Bottom Text"
L["Button Glow"] = "Button Glow"
L["Can be a name or a UID (e.g., party1). Only works on friendly players in your group."] = "Can be a name or a UID (e.g., party1). Only works on friendly players in your group."
L["Cancel"] = "Cancel"
L["Cat"] = "Cat"
L["Change the name of this display"] = "Change the name of this display"
L["Channel Number"] = "Channel Number"
L["Check On..."] = "Check On..."
L["Choose"] = "Choose"
L["Choose Trigger"] = "Choose Trigger"
L["Choose whether the displayed icon is automatic or defined manually"] = "Choose whether the displayed icon is automatic or defined manually"
L["Clone option enabled dialog"] = [=[
You have enabled an option that uses |cFFFF0000Auto-cloning|r.

|cFFFF0000Auto-cloning|r causes a display to be automatically duplicated to display multiple sources of information.
Unless you put this display in a |cFF22AA22Dynamic Group|r, all the clones will be displayed on top of each other in a big heap.

Would you like this display to be placed in a new |cFF22AA22Dynamic Group|r?]=]
L["Close"] = "Close"
L["Collapse"] = "Collapse"
L["Collapse all loaded displays"] = "Collapse all loaded displays"
L["Collapse all non-loaded displays"] = "Collapse all non-loaded displays"
L["Color"] = "Color"
L["Compress"] = "Compress"
L["Concentration"] = "Concentration"
L["Constant Factor"] = "Constant Factor"
L["Control-click to select multiple displays"] = "Control-click to select multiple displays"
L["Controls the positioning and configuration of multiple displays at the same time"] = "Controls the positioning and configuration of multiple displays at the same time"
L["Convert to..."] = "Convert to..."
L["Cooldown"] = "Cooldown"
L["Copy"] = "Copy"
L["Copy settings from..."] = "Copy settings from..."
L["Copy settings from another display"] = "Copy settings from another display"
L["Copy settings from %s"] = "Copy settings from %s"
L["Count"] = "Count"
L["Creating buttons: "] = "Creating buttons: "
L["Creating options: "] = "Creating options: "
L["Crop X"] = "Crop X"
L["Crop Y"] = "Crop Y"
L["Crusader"] = "Crusader"
L["Custom Code"] = "Custom Code"
L["Custom Trigger"] = "Custom Trigger"
L["Custom trigger event tooltip"] = [=[
Choose which events cause the custom trigger to be checked.
Multiple events can be specified using commas or spaces.

|cFF4444FFFor example:|r
UNIT_POWER, UNIT_AURA PLAYER_TARGET_CHANGED
]=]
L["Custom trigger status tooltip"] = [=[
Choose which events cause the custom trigger to be checked.
Since this is a status-type trigger, the specified events may be called by WeakAuras without the expected arguments.
Multiple events can be specified using commas or spaces.

|cFF4444FFFor example:|r
UNIT_POWER, UNIT_AURA PLAYER_TARGET_CHANGED
]=]
L["Custom Untrigger"] = "Custom Untrigger"
L["Custom untrigger event tooltip"] = [=[
Choose which events cause the custom un-trigger to be checked.
This can be different than the events defined for the trigger.
Multiple events can be specified using commas or spaces.

|cFF4444FFFor example:|r
UNIT_POWER, UNIT_AURA PLAYER_TARGET_CHANGED
]=]
L["Death"] = "Death"
L["Death Rune"] = "Death Rune"
L["Debuff Type"] = "Debuff Type"
L["Defensive"] = "Defensive"
L["Delete"] = "Delete"
L["Delete all"] = "Delete all"
L["Delete children and group"] = "Delete children and group"
L["Deletes this display - |cFF8080FFShift|r must be held down while clicking"] = "Deletes this display - |cFF8080FFShift|r must be held down while clicking"
L["Delete Trigger"] = "Delete Trigger"
L["Desaturate"] = "Desaturate"
L["Devotion"] = "Devotion"
L["Disabled"] = "Disabled"
L["Discrete Rotation"] = "Discrete Rotation"
L["Display"] = "Display"
L["Display Icon"] = "Display Icon"
L["Display Text"] = "Display Text"
L["Distribute Horizontally"] = "Distribute Horizontally"
L["Distribute Vertically"] = "Distribute Vertically"
L["Do not copy any settings"] = "Do not copy any settings"
L["Do not group this display"] = "Do not group this display"
L["Duplicate"] = "Duplicate"
L["Duration Info"] = "Duration Info"
L["Duration (s)"] = "Duration (s)"
L["Dynamic Group"] = "Dynamic Group"
L["Dynamic text tooltip"] = [=[
There are several special codes available to make this text dynamic:

|cFFFF0000%p|r - Progress - The remaining time of a timer, or a non-timer value
|cFFFF0000%t|r - Total - The maximum duration of a timer, or a maximum non-timer value
|cFFFF0000%n|r - Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name
|cFFFF0000%i|r - Icon - The icon associated with the display
|cFFFF0000%s|r - Stacks - The number of stacks of an aura (usually)
|cFFFF0000%c|r - Custom - Allows you to define a custom Lua function that returns a string value to be displayed]=]
L["Enabled"] = "Enabled"
L["Enter an aura name, partial aura name, or spell id"] = "Enter an aura name, partial aura name, or spell id"
L["Event Type"] = "Event Type"
L["Expand"] = "Expand"
L["Expand all loaded displays"] = "Expand all loaded displays"
L["Expand all non-loaded displays"] = "Expand all non-loaded displays"
L["Expand Text Editor"] = "Expand Text Editor"
L["Expansion is disabled because this group has no children"] = "Expansion is disabled because this group has no children"
L["Export"] = "Export"
L["Export to Lua table..."] = "Export to Lua table..."
L["Export to string..."] = "Export to string..."
L["Fade"] = "Fade"
L["Finish"] = "Finish"
L["Fire Resistance"] = "Fire Resistance"
L["Flight(Non-Feral)"] = "Flight(Non-Feral)"
L["Font"] = "Font"
L["Font Flags"] = "Font Flags"
L["Font Size"] = "Font Size"
L["Font Type"] = "Font Type"
L["Foreground Color"] = "Foreground Color"
L["Foreground Texture"] = "Foreground Texture"
L["Form (Druid)"] = "Form"
L["Form (Priest)"] = "Form"
L["Form (Shaman)"] = "Form"
L["Form (Warlock)"] = "Form"
L["Frame"] = "Frame"
L["Frame Strata"] = "Frame Strata"
L["Frost"] = "Frost"
L["Frost Resistance"] = "Frost Resistance"
L["Full Scan"] = "Full Scan"
L["Ghost Wolf"] = "Ghost Wolf"
L["Glow Action"] = "Glow Action"
L["Group aura count description"] = [=[
The amount of %s members which must be affected by one or more of the given auras for the display to trigger.
If the entered number is a whole number (e.g. 5), the number of affected raid members will be compared with the entered number.
If the entered number is a decimal (e.g. 0.5), fraction (e.g. 1/2), or percentage (e.g. 50%%), then that fraction of the %s must be affected.

|cFF4444FFFor example:|r
|cFF00CC00> 0|r will trigger when anyone in the %s is affected
|cFF00CC00= 100%%|r will trigger when everyone in the %s is affected
|cFF00CC00!= 2|r will trigger when the number of %s members affected is not exactly 2
|cFF00CC00<= 0.8|r will trigger when less than 80%% of the %s is affected (4 of 5 party members, 8 of 10 or 20 of 25 raid members)
|cFF00CC00> 1/2|r will trigger when more than half of the %s is affected
|cFF00CC00>= 0|r will always trigger, no matter what
]=]
L["Group Member Count"] = "Group Member Count"
L["Group (verb)"] = "Group"
L["Height"] = "Height"
L["Hide this group's children"] = "Hide this group's children"
L["Hide When Not In Group"] = "Hide When Not In Group"
L["Horizontal Align"] = "Horizontal Align"
L["Icon Info"] = "Icon Info"
L["Icon Inset"] = "Item Inset"
L["Ignored"] = "Ignored"
L["Ignore GCD"] = "Ignore GCD"
L["%i Matches"] = "%i Matches"
L["Import"] = "Import"
L["Import a display from an encoded string"] = "Import a display from an encoded string"
L["Justify"] = "Justify"
L["Left Text"] = "Left Text"
L["Load"] = "Load"
L["Loaded"] = "Loaded"
L["Main"] = "Main"
L["Main Trigger"] = "Main Trigger"
L["Mana (%)"] = "Mana (%)"
L["Manage displays defined by Addons"] = "Manage displays defined by Addons"
L["Message Prefix"] = "Message Prefix"
L["Message Suffix"] = "Message Suffix"
L["Metamorphosis"] = "Metamorphosis"
L["Mirror"] = "Mirror"
L["Model"] = "Model"
L["Moonkin/Tree/Flight(Feral)"] = "Moonkin/Tree/Flight(Feral)"
L["Move Down"] = "Move Down"
L["Move this display down in its group's order"] = "Move this display down in its group's order"
L["Move this display up in its group's order"] = "Move this display up in its group's order"
L["Move Up"] = "Move Up"
L["Multiple Displays"] = "Multiple Displays"
L["Multiple Triggers"] = "Multiple Triggers"
L["Multiselect ignored tooltip"] = [=[
|cFFFF0000Ignored|r - |cFF777777Single|r - |cFF777777Multiple|r
This option will not be used to determine when this display should load]=]
L["Multiselect multiple tooltip"] = [=[
|cFF777777Ignored|r - |cFF777777Single|r - |cFF00FF00Multiple|r
Any number of matching values can be picked]=]
L["Multiselect single tooltip"] = [=[
|cFF777777Ignored|r - |cFF00FF00Single|r - |cFF777777Multiple|r
Only a single matching value can be picked]=]
L["Must be spelled correctly!"] = "Must be spelled correctly!"
L["Name Info"] = "Name Info"
L["Negator"] = "Not"
L["New"] = "New"
L["Next"] = "Next"
L["No"] = "No"
L["No Children"] = "No Children"
L["Not all children have the same value for this option"] = "Not all children have the same value for this option"
L["Not Loaded"] = "Not Loaded"
L["No tooltip text"] = "No tooltip text"
L["% of Progress"] = "% of Progress"
L["Okay"] = "Okay"
L["On Hide"] = "On Hide"
L["On Init"] = "On Init"
L["Only match auras cast by people other than the player"] = "Only match auras cast by people other than the player"
L["Only match auras cast by the player"] = "Only match auras cast by the player"
L["On Show"] = "On Show"
L["Operator"] = "Operator"
L["or"] = "or"
L["Orientation"] = "Orientation"
L["Other"] = "Other"
L["Outline"] = "Outline"
L["Own Only"] = "Own Only"
L["Player Character"] = "Player Character"
L["Play Sound"] = "Play Sound"
L["Presence (DK)"] = "Presence"
L["Presence (Rogue)"] = "Presence"
L["Prevents duration information from decreasing when an aura refreshes. May cause problems if used with multiple auras with different durations."] = "Prevents duration information from decreasing when an aura refreshes. May cause problems if used with multiple auras with different durations."
L["Primary"] = "Primary"
L["Progress Bar"] = "Progress Bar"
L["Progress Texture"] = "Progress Texture"
L["Put this display in a group"] = "Put this display in a group"
L["Ready For Use"] = "Ready For Use"
L["Re-center X"] = "Re-center X"
L["Re-center Y"] = "Re-center Y"
L["Remaining Time Precision"] = "Remaining Time Precision"
L["Remove this display from its group"] = "Remove this display from its group"
L["Rename"] = "Rename"
L["Requesting display information"] = "Requesting display information from %s..."
L["Required For Activation"] = "Required For Activation"
L["Retribution"] = "Retribution"
L["Right-click for more options"] = "Right-click for more options"
L["Right Text"] = "Right Text"
L["Rotate"] = "Rotate"
L["Rotate In"] = "Rotate In"
L["Rotate Out"] = "Rotate Out"
L["Rotate Text"] = "Rotate Text"
L["Rotation"] = "Rotation"
L["Same"] = "Same"
L["Search"] = "Search"
L["Secondary"] = "Secondary"
L["Select the auras you always want to be listed first"] = "Select the auras you always want to be listed first"
L["Send To"] = "Send To"
L["Set tooltip description"] = "Set tooltip description"
L["Shadow Dance"] = "Shadow Dance"
L["Shadowform"] = "Shadowform"
L["Shadow Resistance"] = "Shadow Resistance"
L["Shift-click to create chat link"] = "Shift-click to create a |cFF8800FF[Chat Link]"
L["Show all matches (Auto-clone)"] = "Show all matches (Auto-clone)"
L["Show players that are |cFFFF0000not affected"] = "Show players that are |cFFFF0000not affected"
L["Shows a 3D model from the game files"] = "Shows a 3D model from the game files"
L["Shows a custom texture"] = "Shows a custom texture"
L["Shows a progress bar with name, timer, and icon"] = "Shows a progress bar with name, timer, and icon"
L["Shows a spell icon with an optional cooldown overlay"] = "Shows a spell icon with an optional cooldown overlay"
L["Shows a texture that changes based on duration"] = "Shows a texture that changes based on duration"
L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = "Shows one or more lines of text, which can include dynamic information such as progress or stacks"
L["Shows the remaining or expended time for an aura or timed event"] = "Shows the remaining or expended time for an aura or timed event"
L["Show this group's children"] = "Show this group's children"
L["Size"] = "Size"
L["Slide"] = "Slide"
L["Slide In"] = "Slide In"
L["Slide Out"] = "Slide Out"
L["Sort"] = "Sort"
L["Sound"] = "Sound"
L["Sound Channel"] = "Sound Channel"
L["Sound File Path"] = "Sound File Path"
L["Space"] = "Space"
L["Space Horizontally"] = "Space Horizontally"
L["Space Vertically"] = "Space Vertically"
L["Spell ID"] = "Spell ID"
L["Spell ID dialog"] = [=[
You have specified an aura by |cFFFF0000spell ID|r.

By default, |cFF8800FFWeakAuras|r cannot distinguish between auras with the same name but different |cFFFF0000spell ID|r.
However, if the Use Full Scan option is enabled, |cFF8800FFWeakAuras|r can search for specific |cFFFF0000spell ID|rs.

Would you like to enable Use Full Scan to match this |cFFFF0000spell ID|r?]=]
L["Stack Count"] = "Stack Count"
L["Stack Count Position"] = "Stack Count Position"
L["Stack Info"] = "Stack Info"
L["Stacks Settings"] = "Stacks Settings"
L["Stagger"] = "Stagger"
L["Stance (Warrior)"] = "Stance"
L["Start"] = "Start"
L["Stealable"] = "Stealable"
L["Stealthed"] = "Stealthed"
L["Sticky Duration"] = "Sticky Duration"
L["Temporary Group"] = "Temporary Group"
L["Text"] = "Text"
L["Text Color"] = "Text Color"
L["Text Position"] = "Text Position"
L["Text Settings"] = "Text Settings"
L["Texture"] = "Texture"
L["Texture Info"] = "Texture Info"
L["The children of this group have different display types, so their display options cannot be set as a group."] = "The children of this group have different display types, so their display options cannot be set as a group."
L["The duration of the animation in seconds."] = "The duration of the animation in seconds."
L["The type of trigger"] = "The type of trigger"
L["This condition will not be tested"] = "This condition will not be tested"
L["This display is currently loaded"] = "This display is currently loaded"
L["This display is not currently loaded"] = "This display is not currently loaded"
L["This display will only show when |cFF00FF00%s"] = "This display will only show when |cFF00FF00%s"
L["This display will only show when |cFFFF0000 Not %s"] = "This display will only show when |cFFFF0000 Not %s"
L["This region of type \"%s\" has no configuration options."] = "This region of type \"%s\" has no configuration options."
L["Time in"] = "Time in"
L["Timer"] = "Timer"
L["Timer Settings"] = "Timer Settings"
L["Toggle the visibility of all loaded displays"] = "Toggle the visibility of all loaded displays"
L["Toggle the visibility of all non-loaded displays"] = "Toggle the visibility of all non-loaded displays"
L["Toggle the visibility of this display"] = "Toggle the visibility of this display"
L["to group's"] = "to group's"
L["Tooltip"] = "Tooltip"
L["Tooltip on Mouseover"] = "Tooltip on Mouseover"
L["Top Text"] = "Top Text"
L["to screen's"] = "to screen's"
L["Total Time Precision"] = "Total Time Precision"
L["Tracking"] = "Tracking"
L["Travel"] = "Travel"
L["Trigger"] = "Trigger"
L["Trigger %d"] = "Trigger %d"
L["Triggers"] = "Triggers"
L["Type"] = "Type"
L["Ungroup"] = "Ungroup"
L["Unholy"] = "Unholy"
L["Unit Exists"] = "Unit Exists"
L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = "Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."
L["Unstealthed"] = "Unstealthed"
L["Update Custom Text On..."] = "Update Custom Text On..."
L["Use Full Scan (High CPU)"] = "Use Full Scan (High CPU)"
L["Use tooltip \"size\" instead of stacks"] = "Use tooltip \"size\" instead of stacks"
L["Vertical Align"] = "Vertical Align"
L["View"] = "View"
L["Width"] = "Width"
L["X Offset"] = "X Offset"
L["X Scale"] = "X Scale"
L["Yes"] = "Yes"
L["Y Offset"] = "Y Offset"
L["Y Scale"] = "Y Scale"
L["Z Offset"] = "Z Offset"
L["Zoom"] = "Zoom"
L["Zoom In"] = "Zoom In"
L["Zoom Out"] = "Zoom Out"




local L = WeakAuras.L

--@localization(locale="enUS", format="lua_additive_table", namespace="WeakAuras", handle-subnamespaces="none")@

--@do-not-package@
L["<"] = "<"
L["<="] = "<="
L["="] = "="
L[">"] = ">"
L[">="] = ">="
L["!="] = "!="
L["10 Man Raid"] = "10 Man Raid"
L["25 Man Raid"] = "25 Man Raid"
L["5 Man Dungeon"] = "5 Man Dungeon"
L["Absorb"] = "Absorb"
L["Absorbed"] = "Absorbed"
L["Action Usable"] = "Action Usable"
L["Affected"] = "Affected"
L["Air"] = "Air"
L["Alive"] = "Alive"
L["All Triggers"] = "All Triggers"
L["Alternate Power"] = "Alternate Power"
L["Ambience"] = "Ambience"
L["Amount"] = "Amount"
L["Any Triggers"] = "Any Triggers"
L["Arena"] = "Arena"
L["Ascending"] = "Ascending"
L["At Least One Enemy"] = "At Least One Enemy"
L["Attackable"] = "Attackable"
L["Aura"] = "Aura"
L["Aura:"] = "Aura:"
L["Aura Applied"] = "Aura Applied"
L["Aura Applied Dose"] = "Aura Applied Dose"
L["Aura Broken"] = "Aura Broken"
L["Aura Broken Spell"] = "Aura Broken Spell"
L["Aura Name"] = "Aura Name or ID"
L["Aura Refresh"] = "Aura Refresh"
L["Aura Removed"] = "Aura Removed"
L["Aura Removed Dose"] = "Aura Removed Dose"
L["Auras:"] = "Auras:"
L["Aura Stack"] = "Aura Stack"
L["Aura Type"] = "Aura Type"
L["Automatic"] = "Automatic"
L["Back and Forth"] = "Back and Forth"
L["Battleground"] = "Battleground"
L["Battle.net Whisper"] = "Battle.net Whisper"
L["BG>Raid>Party>Say"] = "BG>Raid>Party>Say"
L["BG-System Alliance"] = "BG-System Alliance"
L["BG-System Horde"] = "BG-System Horde"
L["BG-System Neutral"] = "BG-System Neutral"
L["Blizzard Combat Text"] = "Blizzard Combat Text"
L["Block"] = "Block"
L["Blocked"] = "Blocked"
L["Blood Rune #1"] = "Blood Rune #1"
L["Blood Rune #2"] = "Blood Rune #2"
L["Blood runes"] = "Blood runes"
L["Boss Emote"] = "Boss Emote"
L["Bottom"] = "Bottom"
L["Bottom Left"] = "Bottom Left"
L["Bottom Right"] = "Bottom Right"
L["Bottom to Top"] = "Bottom to Top"
L["Bounce"] = "Bounce"
L["Bounce with Decay"] = "Bounce with Decay"
L["Buff"] = "Buff"
L["Burning Embers"] = "Burning Embers"
L["By |cFF69CCF0Mirrored|r of Dragonmaw(US) Horde"] = "By |cFF69CCF0Mirrored|r of Dragonmaw(US) Horde"
L["Cast"] = "Cast"
L["Cast Failed"] = "Cast Failed"
L["Cast Start"] = "Cast Start"
L["Cast Success"] = "Cast Success"
L["Cast Type"] = "Cast Type"
L["Center"] = "Center"
L["Centered Horizontal"] = "Centered Horizontal"
L["Centered Vertical"] = "Centered Vertical"
L["Channel"] = "Channel"
L["Channel (Spell)"] = "Channel"
L["Character Type"] = "Character Type"
L["Chat Frame"] = "Chat Frame"
L["Chat Message"] = "Chat Message"
L["Children:"] = "Children:"
L["Chi Power"] = "Chi Power"
L["Circle"] = "Circle"
L["Circular"] = "Circular"
L["Class"] = "Class"
L["Click to close configuration"] = "Click to close configuration"
L["Click to open configuration"] = "Click to open configuration"
L["Combat Log"] = "Combat Log"
L["Combo Points"] = "Combo Points"
L["Conditions"] = "Conditions"
L["Contains"] = "Contains"
L["Cooldown Progress (Item)"] = "Cooldown Progress (Item)"
L["Cooldown Progress (Spell)"] = "Cooldown Progress (Spell)"
L["Cooldown Ready (Item)"] = "Cooldown Ready (Item)"
L["Cooldown Ready (Spell)"] = "Cooldown Ready (Spell)"
L["Create"] = "Create"
L["Critical"] = "Critical"
L["Crowd Controlled"] = "Crowd Controlled"
L["Crushing"] = "Crushing"
L["Curse"] = "Curse"
L["Custom"] = "Custom"
L["Custom Function"] = "Custom Function"
L["Damage"] = "Damage"
L["Damager"] = "Damager"
L["Damage Shield"] = "Damage Shield"
L["Damage Shield Missed"] = "Damage Shield Missed"
L["Damage Split"] = "Damage Split"
L["Death Knight"] = "Death Knight"
L["Death Knight Rune"] = "Death Knight Rune"
L["Death Rune"] = "Death Rune"
L["Debuff"] = "Debuff"
L["Deflect"] = "Deflect"
L["Demonic Fury"] = "Demonic Fury"
L["Descending"] = "Descending"
L["Destination Name"] = "Destination Name"
L["Destination Unit"] = "Destination Unit"
L["Disease"] = "Disease"
L["Dispel"] = "Dispel"
L["Dispel Failed"] = "Dispel Failed"
L["Dodge"] = "Dodge"
L["Done"] = "Done"
L["Down"] = "Down"
L["Drain"] = "Drain"
L["Drowning"] = "Drowning"
L["Druid"] = "Druid"
L["Dungeon Difficulty"] = "Dungeon Difficulty"
L["Durability Damage"] = "Durability Damage"
L["Durability Damage All"] = "Durability Damage All"
L["Earth"] = "Earth"
L["Eclipse Direction"] = "Eclipse Direction"
L["Eclipse Power"] = "Eclipse Power"
L["Eclipse Type"] = "Eclipse Type"
L["Emote"] = "Emote"
L["Energize"] = "Energize"
L["Energy"] = "Energy"
L["Enrage"] = "Enrage"
L["Environmental"] = "Environmental"
L["Environment Type"] = "Environment Type"
L["Evade"] = "Evade"
L["Event"] = "Event"
L["Event(s)"] = "Event(s)"
L["Every Frame"] = "Every Frame"
L["Extra Amount"] = "Extra Amount"
L["Extra Attacks"] = "Extra Attacks"
L["Extra Spell Name"] = "Extra Spell Name"
L["Fade In"] = "Fade In"
L["Fade Out"] = "Fade Out"
L["Falling"] = "Falling"
L["Fatigue"] = "Fatigue"
L["Fire"] = "Fire"
L["First Tree"] = "First Tree"
L["Flash"] = "Flash"
L["Flip"] = "Flip"
L["Focus"] = "Focus"
L["Form"] = "Form"
L["Friendly"] = "Friendly"
L["From"] = "From"
L["Frost Rune #1"] = "Frost Rune #1"
L["Frost Rune #2"] = "Frost Rune #2"
L["Frost Runes"] = "Frost Runes"
L["Glancing"] = "Glancing"
L["Global Cooldown"] = "Global Cooldown"
L["Glow"] = "Glow"
L["Gradient"] = "Gradient"
L["Gradient Pulse"] = "Gradient Pulse"
L["Group"] = "Group"
L["Group %s"] = "Group %s"
L["Grow"] = "Grow"
L["Guild"] = "Guild"
L["Happiness"] = "Happiness"
L["HasPet"] = "Having Pet (Alive)"
L["Heal"] = "Heal"
L["Healer"] = "Healer"
L["Health"] = "Health"
L["Health (%)"] = "Health (%)"
L["Heroic"] = "Heroic"
L["Hide"] = "Hide"
L["Higher Than Tank"] = "Higher Than Tank"
L["Holy Power"] = "Holy Power"
L["Hostile"] = "Hostile"
L["Hostility"] = "Hostility"
L["Humanoid"] = "Humanoid"
L["Hunter"] = "Hunter"
L["Icon"] = "Icon"
L["Ignore Rune CD"] = "Ignore Rune CD"
L["Immune"] = "Immune"
L["Include Bank"] = "Include Bank"
L["Include Charges"] = "Include Charges"
L["Include Death Runes"] = "Include Death Runes"
L["In Combat"] = "In Combat"
L["Inherited"] = "Inherited"
L["In Pet Battle"] = "In Pet Battle"
L["Inside"] = "Inside"
L["Instakill"] = "Instakill"
L["Instance Type"] = "Instance Type"
L["Interrupt"] = "Interrupt"
L["Interruptible"] = "Interruptible"
L["In Vehicle"] = "In Vehicle"
L["Inverse"] = "Inverse"
L["Is Exactly"] = "Is Exactly"
L["Item"] = "Item"
L["Item Count"] = "Item Count"
L["Item Equipped"] = "Item Equipped"
L["Lava"] = "Lava"
L["Leech"] = "Leech"
L["Left"] = "Left"
L["Left to Right"] = "Left to Right"
L["Level"] = "Level"
L["Lower Than Tank"] = "Lower Than Tank"
L["Lunar"] = "Lunar"
L["Lunar Power"] = "Lunar Power"
L["Mage"] = "Mage"
L["Magic"] = "Magic"
L["Main Hand"] = "Main Hand"
L["Mana"] = "Mana"
L["Master"] = "Master"
L["Matches (Pattern)"] = "Matches (Pattern)"
L["Message"] = "Message"
L["Message type:"] = "Message type:"
L["Message Type"] = "Message Type"
L["Miss"] = "Miss"
L["Missed"] = "Missed"
L["Missing"] = "Missing"
L["Miss Type"] = "Miss Type"
L["Monochrome Outline"] = "Monochrome Outline"
L["Monster Yell"] = "Monster Yell"
L["Mounted"] = "Mounted"
L["Multi-target"] = "Multi-target"
L["Music"] = "Music"
L["Name"] = "Name"
L["Never"] = "Never"
L["Next"] = "Next"
L["No Children:"] = "No Children:"
L["No Instance"] = "No Instance"
L["None"] = "None"
L["Non-player Character"] = "Non-player Character"
L["Normal"] = "Normal"
L["Not On Threat Table"] = "Not On Threat Table"
L["Number"] = "Number"
L["Number Affected"] = "Number Affected"
L["Off Hand"] = "Off Hand"
L["Officer"] = "Officer"
L["Opaque"] = "Opaque"
L["Orbit"] = "Orbit"
L["Outline"] = "Outline"
L["Outside"] = "Outside"
L["Overhealing"] = "Overhealing"
L["Overkill"] = "Overkill"
L["Paladin"] = "Paladin"
L["Parry"] = "Parry"
L["Party"] = "Party"
L["Party Kill"] = "Party Kill"
L["Paused"] = "Paused"
L["Periodic Spell"] = "Periodic Spell"
L["Pet"] = "Pet"
L["Pet Behavior"] = "Pet Behavior"
L["Player"] = "Player"
L["Player Character"] = "Player Character"
L["Player Class"] = "Player Class"
L["Player Dungeon Role"] = "Player Dungeon Role"
L["Player Level"] = "Player Level"
L["Player Name"] = "Player Name"
L["Player(s) Affected"] = "Player(s) Affected"
L["Player(s) Not Affected"] = "Player(s) Not Affected"
L["Poison"] = "Poison"
L["Power"] = "Power"
L["Power (%)"] = "Power (%)"
L["Power Type"] = "Power Type"
L["Preset"] = "Preset"
L["Priest"] = "Priest"
L["Progress"] = "Progress"
L["Pulse"] = "Pulse"
L["PvP Flagged"] = "PvP Flagged"
L["Radius"] = "Radius"
L["Rage"] = "Rage"
L["Raid"] = "Raid"
L["Raid Warning"] = "Raid Warning"
L["Range"] = "Range"
L["Ranged"] = "Ranged"
L["Receiving display information"] = "Receiving display information from %s..."
L["Reference Spell"] = "Reference Spell"
L["Reflect"] = "Reflect"
L["Relative"] = "Relative"
L["Remaining Time"] = "Remaining Time"
L["Requested display does not exist"] = "Requested display does not exist"
L["Requested display not authorized"] = "Requested display not authorized"
L["Require Valid Target"] = "Require Valid Target"
L["Resist"] = "Resist"
L["Resisted"] = "Resisted"
L["Resolve collisions dialog"] = [=[
You have enabled an addon that defines |cFF8800FFWeakAuras|r displays that have the same names as some of your existing displays.

You need to rename your displays to make room for the addon displays.

Resolved: |cFFFF0000]=]
L["Resolve collisions dialog singular"] = [=[
You have enabled an addon that defines a |cFF8800FFWeakAuras|r display that has the same name as one of your existing displays.

You need to rename your display to make room for the addon display.

Resolved: |cFFFF0000]=]
L["Resolve collisions dialog startup"] = [=[
You have installed an addon that defines |cFF8800FFWeakAuras|r displays that have the same names as some of your existing displays.

You need to rename your displays to make room for the addon displays.

Resolved: |cFFFF0000]=]
L["Resolve collisions dialog startup singular"] = [=[
You have installed an addon that defines a |cFF8800FFWeakAuras|r display that has the same name as one of your existing displays.

You need to rename your display to make room for the addon display.

Resolved: |cFFFF0000]=]
L["Resting"] = "Resting"
L["Resurrect"] = "Resurrect"
L["Right"] = "Right"
L["Right to Left"] = "Right to Left"
L["Rogue"] = "Rogue"
L["Rotate Left"] = "Rotate Left"
L["Rotate Right"] = "Rotate Right"
L["Rune"] = "Rune"
L["Runic Power"] = "Runic Power"
L["Say"] = "Say"
L["Seconds"] = "Seconds"
L["Second Tree"] = "Second Tree"
L["Shadow Orbs"] = "Shadow Orbs"
L["Shake"] = "Shake"
L["Shaman"] = "Shaman"
L["Shards"] = "Shards"
L["Shift-Click to pause"] = "Shift-Click to pause"
L["Shift-Click to resume"] = "Shift-Click to resume"
L["Show"] = "Show"
L["Shrink"] = "Shrink"
L["Slide from Bottom"] = "Slide from Bottom"
L["Slide from Left"] = "Slide from Left"
L["Slide from Right"] = "Slide from Right"
L["Slide from Top"] = "Slide from Top"
L["Slide to Bottom"] = "Slide to Bottom"
L["Slide to Left"] = "Slide to Left"
L["Slide to Right"] = "Slide to Right"
L["Slide to Top"] = "Slide to Top"
L["Slime"] = "Slime"
L["Solar"] = "Solar"
L["Solar Power"] = "Solar Power"
L["Sound Effects"] = "Sound Effects"
L["Source Name"] = "Source Name"
L["Source Unit"] = "Source Unit"
L["Spacing"] = "Spacing"
L["Specific Unit"] = "Specific Unit"
L["Spell"] = "Spell"
L["Spell (Building)"] = "Spell (Building)"
L["Spell Name"] = "Spell Name"
L["Spin"] = "Spin"
L["Spiral"] = "Spiral"
L["Spiral In And Out"] = "Spiral In And Out"
L["Stacks"] = "Stacks"
L["Stance/Form/Aura"] = "Stance/Form/Aura"
L["Status"] = "Status"
L["Stolen"] = "Stolen"
L["Summon"] = "Summon"
L["Swing"] = "Swing"
L["Swing Timer"] = "Swing Timer"
L["Talent selected"] = "Talent selected"
L["Talent Specialization"] = "Talent Specialization"
L["Tank"] = "Tank"
L["Tanking And Highest"] = "Tanking And Highest"
L["Tanking But Not Highest"] = "Tanking But Not Highest"
L["Target"] = "Target"
L["Thick Outline"] = "Thick Outline"
L["Third Tree"] = "Third Tree"
L["Threat Situation"] = "Threat Situation"
L["Thrown"] = "Thrown"
L["Timed"] = "Timed"
L["Top"] = "Top"
L["Top Left"] = "Top Left"
L["Top Right"] = "Top Right"
L["Top to Bottom"] = "Top to Bottom"
L["Total"] = "Total"
L["Totem"] = "Totem"
L["Totem Name"] = "Totem Name"
L["Totem Type"] = "Totem Type"
L["Transmission error"] = "Transmission error"
L["Trigger:"] = "Trigger:"
L["Trigger Update"] = "Trigger Update"
L["Undefined"] = "Undefined"
L["Unholy Rune #1"] = "Unholy Rune #1"
L["Unholy Rune #2"] = "Unholy Rune #2"
L["Unholy Runes"] = "Unholy Runes"
L["Unit"] = "Unit"
L["Unit Characteristics"] = "Unit Characteristics"
L["Unit Destroyed"] = "Unit Destroyed"
L["Unit Died"] = "Unit Died"
L["Up"] = "Up"
L["Version error recevied higher"] = "This display is incompatible with your version of WeakAuras - it was created by version %s, but you have version %s. Please update your version of WeakAuras."
L["Version error recevied lower"] = "This display is incompatible with your version of WeakAuras - it was created by version %s, but you have version %s. Please tell the person you received it from to update their version of WeakAuras."
L["Warlock"] = "Warlock"
L["Warrior"] = "Warrior"
L["Water"] = "Water"
L["WeakAuras"] = "WeakAuras"
L["WeakAurasModelPaths"] = "WeakAuras - 3D Model Paths"
L["WeakAurasModelPaths .toc Notes"] = "Provides a list of most ingame 3D models to use with WA model display."
L["WeakAurasOptions"] = "WeakAuras - Options"
L["WeakAurasOptions .toc Notes"] = "Options GUI for WeakAuras."
L["WeakAuras .toc Notes"] = "A powerful, comprehensive utilty for displaying graphics and information based on buffs, debuffs, and other triggers."
L["WeakAurasTutorials"] = "WeakAuras - Tutorials"
L["WeakAurasTutorials .toc Notes"] = "Indroction and advanced tutorials for WeakAuras."
L["Weapon"] = "Weapon"
L["Weapon Enchant"] = "Weapon Enchant"
L["Whisper"] = "Whisper"
L["Wobble"] = "Wobble"
L["Yell"] = "Yell"
L["Zone"] = "Zone"

--@end-do-not-package@

-- Make missing translations available
setmetatable(WeakAuras.L, {__index = function(self, key)
	self[key] = (key or "")
	return key
end})
-- Lua APIs
local tinsert, tconcat, tremove, wipe = table.insert, table.concat, table.remove, wipe
local fmt, tostring, string_char = string.format, tostring, string.char
local select, pairs, next, type, unpack = select, pairs, next, type, unpack
local loadstring, assert, error = loadstring, assert, error
local setmetatable, getmetatable, rawset, rawget = setmetatable, getmetatable, rawset, rawget
local bit_band, bit_lshift, bit_rshift = bit.band, bit.lshift, bit.rshift
local ceil, min = ceil, min

-- WoW APIs
local GetPvpTalentInfo, GetActiveSpecGroup, GetTalentInfo = GetPvpTalentInfo, GetActiveSpecGroup, GetTalentInfo
local GetNumSpecializationsForClassID, GetSpecialization = GetNumSpecializationsForClassID, GetSpecialization
local UnitClass, UnitHealth, UnitHealthMax, UnitName, UnitStagger, UnitPower, UnitPowerMax = UnitClass, UnitHealth, UnitHealthMax, UnitName, UnitStagger, UnitPower, UnitPowerMax
local UnitAlternatePowerInfo, UnitAlternatePowerTextureInfo = UnitAlternatePowerInfo, UnitAlternatePowerTextureInfo
local GetSpellInfo, GetItemInfo, GetTotemInfo, GetItemCount, GetItemIcon = GetSpellInfo, GetItemInfo, GetTotemInfo, GetItemCount, GetItemIcon
local GetShapeshiftFormInfo, GetNumShapeshiftForms, GetShapeshiftForm = GetShapeshiftFormInfo, GetNumShapeshiftForms, GetShapeshiftForm
local GetRuneCooldown, UnitCastingInfo, UnitChannelInfo = GetRuneCooldown, UnitCastingInfo, UnitChannelInfo

local WeakAuras = WeakAuras;
local L = WeakAuras.L;

local SpellRange = LibStub("SpellRange-1.0")
function WeakAuras.IsSpellInRange(spellId, unit)
  return SpellRange.IsSpellInRange(spellId, unit);
end

WeakAuras.encounter_table = {
  -- The Emerald Nightmare
  [1703] = 1853, -- Nythendra
  [1744] = 1876, -- Elerethe Renferal
  [1738] = 1873, -- Il'gynoth, Heart of Corruption
  [1667] = 1841, -- Ursoc
  [1704] = 1854, -- Dragons of Nightmare
  [1750] = 1877, -- Cenarius
  [1726] = 1864, -- Xavius
  -- The Nighthold
  [1706] = 1849, -- Skorpyron,
  [1725] = 1865, -- Chronomatic Anomaly
  [1731] = 1867, -- Trilliax,
  [1751] = 1871, -- Spellblade Aluriel
  [1762] = 1862, -- Tichondrius
  [1713] = 1842, -- Krosus
  [1761] = 1886, -- High Botanist Tel'arn
  [1732] = 1863, -- Star Augur Etraeus
  [1743] = 1872, -- Grand Magistrix Elisande
  [1737] = 1866, -- Gul'dan
  -- Trial of Valor
  [1819] = 1958, -- Odyn
  [1830] = 1962, -- Guarm
  [1829] = 2008, -- Helya
  -- Tomb of Sargeras
  [1862] = 2032, -- Goroth
  [1867] = 2048, -- Demonic Inquisition
  [1856] = 2048, -- Harjatan
  [1861] = 2037, -- Mistress Sasszine
  [1903] = 2050, -- Sisters of the Moon
  [1896] = 2054, -- Desolate Host
  [1897] = 2052, -- Maiden of Vigilance
  [1873] = 2038, -- Fallen Avatar
  [1898] = 2051, -- Kiljaeden
}

local function get_encounters_list()
   local encounter_list = ""

   EJ_SelectTier(EJ_GetNumTiers())
   local instance_index = 1
   local instance_id = EJ_GetInstanceByIndex(instance_index, true)
   while instance_id do
      EJ_SelectInstance(instance_id)
      local name = EJ_GetInstanceInfo()
      local ej_index = 1
      local boss, _, ej_id = EJ_GetEncounterInfoByIndex(ej_index)
      while boss do
         local encounter_id = WeakAuras.encounter_table[ej_id]
         if encounter_id then
            if ej_index == 1 then
               encounter_list = ("%s|cffffd200%s|r\n"):format(encounter_list, name)
            end
            encounter_list = ("%s%s: %d\n"):format(encounter_list, boss, WeakAuras.encounter_table[ej_id])
         end
         ej_index = ej_index + 1
         boss, _, ej_id = EJ_GetEncounterInfoByIndex(ej_index)
      end
      instance_index = instance_index + 1
      instance_id = EJ_GetInstanceByIndex(instance_index, true)
      encounter_list = encounter_list .. "\n"
   end

   return encounter_list:sub(1, -2)
end

WeakAuras.function_strings = {
  count = [[
    return function(count)
      if(count %s %s) then
        return true
      else
        return false
      end
    end
  ]],
  count_fraction = [[
    return function(count, max)
      local fraction = count/max
      if(fraction %s %s) then
        return true
      else
        return false
      end
    end
  ]],
  always = [[
    return function()
      return true
    end
  ]]
};

WeakAuras.anim_function_strings = {
  straight = [[
    return function(progress, start, delta)
      return start + (progress * delta)
    end
  ]],
  straightTranslate = [[
    return function(progress, startX, startY, deltaX, deltaY)
      return startX + (progress * deltaX), startY + (progress * deltaY)
    end
  ]],
  straightScale = [[
    return function(progress, startX, startY, scaleX, scaleY)
      return startX + (progress * (scaleX - startX)), startY + (progress * (scaleY - startY))
    end
  ]],
  straightColor = [[
    return function(progress, r1, g1, b1, a1, r2, g2, b2, a2)
      return r1 + (progress * (r2 - r1)), g1 + (progress * (g2 - g1)), b1 + (progress * (b2 - b1)), a1 + (progress * (a2 - a1))
    end
  ]],
  circle = [[
    return function(progress, startX, startY, deltaX, deltaY)
      local angle = progress * 2 * math.pi
      return startX + (deltaX * math.cos(angle)), startY + (deltaY * math.sin(angle))
    end
  ]],
  circle2 = [[
    return function(progress, startX, startY, deltaX, deltaY)
      local angle = progress * 2 * math.pi
      return startX + (deltaX * math.sin(angle)), startY + (deltaY * math.cos(angle))
    end
  ]],
  spiral = [[
    return function(progress, startX, startY, deltaX, deltaY)
      local angle = progress * 2 * math.pi
      return startX + (progress * deltaX * math.cos(angle)), startY + (progress * deltaY * math.sin(angle))
    end
  ]],
  spiralandpulse = [[
    return function(progress, startX, startY, deltaX, deltaY)
      local angle = (progress + 0.25) * 2 * math.pi
      return startX + (math.cos(angle) * deltaX * math.cos(angle*2)), startY + (math.abs(math.cos(angle)) * deltaY * math.sin(angle*2))
    end
  ]],
  shake = [[
    return function(progress, startX, startY, deltaX, deltaY)
      local prog
      if(progress < 0.25) then
        prog = progress * 4
      elseif(progress < .75) then
        prog = 2 - (progress * 4)
      else
        prog = (progress - 1) * 4
      end
      return startX + (prog * deltaX), startY + (prog * deltaY)
    end
  ]],
  bounceDecay = [[
    return function(progress, startX, startY, deltaX, deltaY)
      local prog = (progress * 3.5) % 1
      local bounce = math.ceil(progress * 3.5)
      local bounceDistance = math.sin(prog * math.pi) * (bounce / 4)
    return startX + (bounceDistance * deltaX), startY + (bounceDistance * deltaY)
  end
  ]],
  bounce = [[
    return function(progress, startX, startY, deltaX, deltaY)
      local bounceDistance = math.sin(progress * math.pi)
      return startX + (bounceDistance * deltaX), startY + (bounceDistance * deltaY)
    end
  ]],
  flash = [[
    return function(progress, start, delta)
      local prog
      if(progress < 0.5) then
        prog = progress * 2
      else
        prog = (progress - 1) * 2
      end
      return start + (prog * delta)
    end
  ]],
  pulse = [[
    return function(progress, startX, startY, scaleX, scaleY)
      local angle = (progress * 2 * math.pi) - (math.pi / 2)
      return startX + (((math.sin(angle) + 1)/2) * (scaleX - 1)), startY + (((math.sin(angle) + 1)/2) * (scaleY - 1))
    end
  ]],
  alphaPulse = [[
    return function(progress, start, delta)
      local angle = (progress * 2 * math.pi) - (math.pi / 2)
      return start + (((math.sin(angle) + 1)/2) * delta)
    end
  ]],
  pulseColor = [[
    return function(progress, r1, g1, b1, a1, r2, g2, b2, a2)
      local angle = (progress * 2 * math.pi) - (math.pi / 2)
      local newProgress = ((math.sin(angle) + 1)/2);
      return r1 + (newProgress * (r2 - r1)),
           g1 + (newProgress * (g2 - g1)),
           b1 + (newProgress * (b2 - b1)),
           a1 + (newProgress * (a2 - a1))
    end
  ]],
  fauxspin = [[
    return function(progress, startX, startY, scaleX, scaleY)
      local angle = progress * 2 * math.pi
      return math.cos(angle) * scaleX, startY + (progress * (scaleY - startY))
    end
  ]],
  fauxflip = [[
    return function(progress, startX, startY, scaleX, scaleY)
      local angle = progress * 2 * math.pi
      return startX + (progress * (scaleX - startX)), math.cos(angle) * scaleY
    end
  ]],
  backandforth = [[
    return function(progress, start, delta)
    local prog
    if(progress < 0.25) then
      prog = progress * 4
      elseif(progress < .75) then
      prog = 2 - (progress * 4)
    else
      prog = (progress - 1) * 4
    end
    return start + (prog * delta)
    end
  ]],
  wobble = [[
    return function(progress, start, delta)
    local angle = progress * 2 * math.pi
    return start + math.sin(angle) * delta
    end
  ]],
  hide = [[
    return function()
    return 0
    end
  ]]
};

WeakAuras.anim_presets = {
  -- Start and Finish
  slidetop = {
    type = "custom",
    duration = 0.25,
    use_translate = true,
    x = 0, y = 50,
    use_alpha = true,
    alpha = 0
  },
  slideleft = {
    type = "custom",
    duration = 0.25,
    use_translate = true,
    x = -50,
    y = 0,
    use_alpha = true,
    alpha = 0
  },
  slideright = {
    type = "custom",
    duration = 0.25,
    use_translate = true,
    x = 50,
    y = 0,
    use_alpha = true,
    alpha = 0
  },
  slidebottom = {
    type = "custom",
    duration = 0.25,
    use_translate = true,
    x = 0,
    y = -50,
    use_alpha = true,
    alpha = 0
  },
  fade = {
    type = "custom",
    duration = 0.25,
    use_alpha = true,
    alpha = 0
  },
  grow = {
    type = "custom",
    duration = 0.25,
    use_scale = true,
    scalex = 2,
    scaley = 2,
    use_alpha = true,
    alpha = 0
  },
  shrink = {
    type = "custom",
    duration = 0.25,
    use_scale = true,
    scalex = 0,
    scaley = 0,
    use_alpha = true,
    alpha = 0
  },
  spiral = {
    type = "custom",
    duration = 0.5,
    use_translate = true,
    x = 100,
    y = 100,
    translateType = "spiral",
    use_alpha = true,
    alpha = 0
  },
  bounceDecay = {
    type = "custom",
    duration = 1.5,
    use_translate = true,
    x = 50,
    y = 50,
    translateType = "bounceDecay",
    use_alpha = true,
    alpha = 0
  },

  -- Main
  shake = {
    type = "custom",
    duration = 0.5,
    use_translate = true,
    x = 10,
    y = 0,
    translateType = "circle2"
  },
  spin = {
    type = "custom",
    duration = 1,
    use_scale = true,
    scalex = 1,
    scaley = 1,
    scaleType = "fauxspin"
  },
  flip = {
    type = "custom",
    duration = 1,
    use_scale = true,
    scalex = 1,
    scaley = 1,
    scaleType = "fauxflip"
  },
  wobble = {
    type = "custom",
    duration = 0.5,
    use_rotate = true,
    rotate = 3,
    rotateType = "wobble"
  },
  pulse = {
    type = "custom",
    duration = 0.75,
    use_scale = true,
    scalex = 1.05,
    scaley = 1.05,
    scaleType = "pulse"
  },
  alphaPulse = {
    type = "custom",
    duration = 0.5,
    use_alpha = true,
    alpha = 0.5,
    alphaType = "alphaPulse"
  },
  rotateClockwise = {
    type = "custom",
    duration = 4,
    use_rotate = true,
    rotate = -360
  },
  rotateCounterClockwise = {
    type = "custom",
    duration = 4,
    use_rotate = true,
    rotate = 360
  },
  spiralandpulse = {
    type = "custom",
    duration = 6,
    use_translate = true,
    x = 100,
    y = 100,
    translateType = "spiralandpulse"
  },
  circle = {
    type = "custom",
    duration = 4,
    use_translate = true,
    x = 100,
    y = 100,
    translateType = "circle"
  },
  orbit = {
    type = "custom",
    duration = 4,
    use_translate = true,
    x = 100,
    y = 100,
    translateType = "circle",
    use_rotate = true,
    rotate = 360
  },
  bounce = {
    type = "custom",
    duration = 0.6,
    use_translate = true,
    x = 0,
    y = 25,
    translateType = "bounce"
  }
};

WeakAuras.class_ids = {}
local classID = 1;
local _, classFileName;
while(GetClassInfo(classID)) do
  _, classFileName = GetClassInfo(classID)
  WeakAuras.class_ids[classFileName] = classID;
  classID = classID + 1;
end

function WeakAuras.CheckTalentByIndex(index)
  local tier = ceil(index / 3)
  local column = (index - 1) % 3 + 1
  local spec = GetActiveSpecGroup()
  local _, _, _, selected = GetTalentInfo(tier, column, spec)
  return selected
end

function WeakAuras.CheckPvpTalentByIndex(index)
  local tier = ceil(index / 3)
  local column = (index - 1) % 3 + 1
  local spec = GetActiveSpecGroup()
  local _, _, _, selected = GetPvpTalentInfo(tier, column, spec)
  return selected
end


function WeakAuras.CheckNumericIds(loadids, currentId)
  local searchFrom = 0;

  local startI, endI = string.find(loadids, currentId, searchFrom);
  while (startI) do
    searchFrom = endI + 1; -- start next search from end
    if (startI == 1 or tonumber(string.sub(loadids, startI - 1, startI - 1)) == nil) then
      -- Either right at start, or character before is not a number
      if (endI == string.len(loadids) or tonumber(string.sub(loadids, endI + 1, endI + 1)) == nil) then
        return true;
      end
    end
    startI, endI = string.find(loadids, currentId, searchFrom);
  end
  return false;
end

WeakAuras.load_prototype = {
  args = {
    {
      name = "combat",
      display = L["In Combat"],
      type = "tristate",
      width = "normal",
      init = "arg"
    },
    {
      name = "never",
      display = L["Never"],
      type = "toggle",
      width = "normal",
      init = "false"
    },
    {
      name = "ingroup",
      display = L["In Group"],
      type = "tristate",
      width = "normal",
      init = "arg"
    },
    {
      name = "petbattle",
      display = L["In Pet Battle"],
      type = "tristate",
      init = "arg",
      width = "normal",
    },
    {
      name = "vehicle",
      display = L["In Vehicle"],
      type = "tristate",
      init = "arg",
      width = "normal",
    },
    {
      name = "vehicleUi",
      display = L["Has Vehicle UI"],
      type = "tristate",
      init = "arg",
      width = "normal",
    },
    {
      name = "name",
      display = L["Player Name"],
      type = "string",
      init = "arg"
    },
    {
      name = "realm",
      display = L["Realm"],
      type = "string",
      init = "arg"
    },
    {
      name = "class",
      display = L["Player Class"],
      type = "multiselect",
      values = "class_types",
      init = "arg"
    },
    {
      name = "spec",
      display = L["Talent Specialization"],
      type = "multiselect",
      values = function(trigger)
        return function()
          local single_class;
          local min_specs = 4;
          -- First check to use if the class load is on multi-select with only one class selected
          -- Also check the number of specs for each class selected in the multi-select and keep track of the minimum
          -- (i.e., 3 unless Druid is the only thing selected, but this method is flexible in case another spec gets added to another class)
          if(trigger.use_class == false and trigger.class and trigger.class.multi) then
            local num_classes = 0;
            for class in pairs(trigger.class.multi) do
              single_class = class;
              -- If any checked class has only 3 specs, min_specs will become 3
              min_specs = min(min_specs, GetNumSpecializationsForClassID(WeakAuras.class_ids[class]))
              num_classes = num_classes + 1;
            end
            if(num_classes ~= 1) then
              single_class = nil;
            end
          end
          -- If that is not the case, see if it is on single-select
          if((not single_class) and trigger.use_class and trigger.class and trigger.class.single) then
            single_class = trigger.class.single
          end

          if (trigger.use_class == nil) then -- no class selected, fallback to current class
            single_class = select(2, UnitClass("player"));
          end

          -- If a single specific class was found, load the specific list for it
          if(single_class) then
            return WeakAuras.spec_types_specific[single_class];
          else
            -- List 4 specs if no class is specified, but if any multi-selected classes have less than 4 specs, list 3 instead
            if (min_specs < 3) then
              return WeakAuras.spec_types_2;
            elseif(min_specs < 4) then
              return WeakAuras.spec_types_3;
            else
              return WeakAuras.spec_types;
            end
          end
        end
      end,
      init = "arg"
    },
    {
      name = "talent",
      display = L["Talent selected"],
      type = "multiselect",
      values = function(trigger)
        return function()
          local single_class;
          -- First check to use if the class load is on multi-select with only one class selected
          if(trigger.use_class == false and trigger.class and trigger.class.multi) then
            local num_classes = 0;
            for class in pairs(trigger.class.multi) do
              single_class = class;
              num_classes = num_classes + 1;
            end
            if(num_classes ~= 1) then
              single_class = nil;
            end
          end
          -- If that is not the case, see if it is on single-select
          if((not single_class) and trigger.use_class and trigger.class and trigger.class.single) then
            single_class = trigger.class.single
          end

          if (trigger.use_class == nil) then -- no class selected, fallback to current class
            single_class = select(2, UnitClass("player"));
          end

          local single_spec;
          if (single_class) then
            if(trigger.use_spec == false and trigger.spec and trigger.spec.multi) then
              local num_specs = 0;
              for spec in pairs(trigger.spec.multi) do
                single_spec = spec;
                num_specs = num_specs + 1;
              end
              if (num_specs ~= 1) then
                single_spec = nil;
              end
            end
          end
          if ((not single_spec) and trigger.use_spec and trigger.spec and trigger.spec.single) then
            single_spec = trigger.spec.single;
          end

          if (trigger.use_spec == nil) then
            single_spec = GetSpecialization();
          end

          -- If a single specific class was found, load the specific list for it
          if(single_class and WeakAuras.talent_types_specific[single_class]
            and single_spec and WeakAuras.talent_types_specific[single_class][single_spec]) then
              return WeakAuras.talent_types_specific[single_class][single_spec];
          else
            return WeakAuras.talent_types;
          end
        end
      end,
      test = "WeakAuras.CheckTalentByIndex(%d)"
    },
    {
      name = "pvptalent",
      display = L["PvP Talent selected"],
      type = "multiselect",
      values = function(trigger)
        return function()
          local single_class;
          -- First check to use if the class load is on multi-select with only one class selected
          if(trigger.use_class == false and trigger.class and trigger.class.multi) then
            local num_classes = 0;
            for class in pairs(trigger.class.multi) do
              single_class = class;
              num_classes = num_classes + 1;
            end
            if(num_classes ~= 1) then
              single_class = nil;
            end
          end
          -- If that is not the case, see if it is on single-select
          if((not single_class) and trigger.use_class and trigger.class and trigger.class.single) then
            single_class = trigger.class.single
          end

          if (trigger.use_class == nil) then -- no class selected, fallback to current class
            single_class = select(2, UnitClass("player"));
          end

          local single_spec;
          if (single_class) then
            if(trigger.use_spec == false and trigger.spec and trigger.spec.multi) then
              local num_specs = 0;
              for spec in pairs(trigger.spec.multi) do
                single_spec = spec;
                num_specs = num_specs + 1;
              end
              if (num_specs ~= 1) then
                single_spec = nil;
              end
            end
          end
          if ((not single_spec) and trigger.use_spec and trigger.spec and trigger.spec.single) then
            single_spec = trigger.spec.single;
          end

          if (trigger.use_spec == nil) then
            single_spec = GetSpecialization();
          end

          -- print ("Using talent cache", single_class, single_spec);
          -- If a single specific class was found, load the specific list for it
          if(single_class and WeakAuras.pvp_talent_types_specific[single_class]
            and single_spec and WeakAuras.pvp_talent_types_specific[single_class][single_spec]) then
              return WeakAuras.pvp_talent_types_specific[single_class][single_spec];
          else
            return WeakAuras.pvp_talent_types;
          end
        end
      end,
      test = "WeakAuras.CheckPvpTalentByIndex(%d)"
    },
    {
      name = "spellknown",
      display = L["Spell Known"],
      type = "spell",
      test = "IsSpellKnown(%s)"
    },
    {
      name = "race",
      display = L["Player Race"],
      type = "multiselect",
      values = "race_types",
      init = "arg"
    },
    {
      name = "faction",
      display = L["Player Faction"],
      type = "multiselect",
      values = "faction_group",
      init = "arg"
    },
    {
      name = "level",
      display = L["Player Level"],
      type = "number",
      init = "arg"
    },
    {
      name = "zone",
      display = L["Zone"],
      type = "string",
      init = "arg"
    },
    {
      name = "zoneId",
      display = L["Zone ID"],
      type = "string",
      init = "arg",
      desc = L["Zone ID List"],
      test = "WeakAuras.CheckNumericIds([[%s]], zoneId)"
    },
    {
      name = "encounterid",
      display = L["Encounter ID"],
      type = "string",
      init = "arg",
      desc = get_encounters_list,
      test = "WeakAuras.CheckNumericIds([[%s]], encounterid)"
    },
    {
      name = "size",
      display = L["Instance Type"],
      type = "multiselect",
      values = "group_types",
      init = "arg",
      control = "WeakAurasSortedDropdown"
    },
    {
      name = "difficulty",
      display = L["Dungeon Difficulty"],
      type = "multiselect",
      values = "difficulty_types",
      init = "arg"
    },
    {
      name = "role",
      display = L["Player Dungeon Role"],
      type = "multiselect",
      values = "role_types",
      init = "arg"
    },
  }
};

WeakAuras.event_prototypes = {
  ["Unit Characteristics"] = {
    type = "status",
    events = {
      "PLAYER_TARGET_CHANGED",
      "PLAYER_FOCUS_CHANGED",
      "UNIT_LEVEL",
      "INSTANCE_ENCOUNTER_ENGAGE_UNIT",
      "UNIT_FACTION"
    },
    force_events = true,
    name = L["Unit Characteristics"],
    init = function(trigger)
      trigger.unit = trigger.unit or "target";
      local ret = [=[
        local unit = [[%s]];
        local concernedUnit = [[%s]];
      ]=];

    return ret:format(trigger.unit, trigger.unit);
    end,
    statesParameter = "one",
    args = {
      {
        name = "unit",
        required = true,
        display = L["Unit"],
        type = "unit",
        init = "arg",
        values = "actual_unit_types_with_specific"
      },
      {
        name = "name",
        display = L["Name"],
        type = "string",
        init = "UnitName(concernedUnit)",
        store = true
      },
      {
        name = "class",
        display = L["Class"],
        type = "select",
        init = "select(2, UnitClass(unit))",
        values = "class_types",
        store = true
      },
      {
        name = "hostility",
        display = L["Hostility"],
        type = "select",
        init = "UnitIsEnemy('player', concernedUnit) and 'hostile' or 'friendly'",
        values = "hostility_types"
      },
      {
        name = "character",
        display = L["Character Type"],
        type = "select",
        init = "UnitIsPlayer(concernedUnit) and 'player' or 'npc'",
        values = "character_types"
      },
      {
        name = "level",
        display = L["Level"],
        type = "number",
        init = "UnitLevel(concernedUnit)",
        store = true
      },
      {
        name = "attackable",
        display = L["Attackable"],
        type = "tristate",
        init = "UnitCanAttack('player', concernedUnit)",
      },
      {
        hidden = true,
        test = "UnitExists(concernedUnit)"
      }
    },
    automatic = true
  },
  ["Health"] = {
    type = "status",
    events = {
      "UNIT_HEALTH_FREQUENT",
      "PLAYER_TARGET_CHANGED",
      "PLAYER_FOCUS_CHANGED",
      "WA_UNIT_PET",
      "INSTANCE_ENCOUNTER_ENGAGE_UNIT",
      "WA_DELAYED_PLAYER_ENTERING_WORLD"
    },
    force_events = {
      "player",
      "target",
      "focus",
      "pet"
    },
    name = L["Health"],
    init = function(trigger)
    trigger.unit = trigger.unit or "player";
      local ret = [=[
        local unit = unit or [[%s]];
        local concernedUnit = [[%s]];
        if (unit == "pet") then
          WeakAuras.WatchForUnitPet();
        end
      ]=];

    return ret:format(trigger.unit, trigger.unit);
    end,
    args = {
      {
        name = "unit",
        required = true,
        display = L["Unit"],
        type = "unit",
        init = "arg",
        values = "actual_unit_types_with_specific"
      },
      {
        name = "health",
        display = L["Health"],
        type = "number",
        init = "UnitHealth(unit)"
      },
      {
        name = "percenthealth",
        display = L["Health (%)"],
        type = "number",
        init = "(UnitHealth(unit) / math.max(1, UnitHealthMax(unit))) * 100"
      },
      {
        hidden = true,
        test = "UnitExists(concernedUnit)"
      }
    },
    durationFunc = function(trigger)
      return UnitHealth(trigger.unit), UnitHealthMax(trigger.unit), true;
    end,
    nameFunc = function(trigger)
      return UnitName(trigger.unit);
    end,
    automatic = true
  },
  ["Power"] = {
    type = "status",
    events = {
      "UNIT_POWER_FREQUENT",
      "PLAYER_TARGET_CHANGED",
      "PLAYER_FOCUS_CHANGED",
      "INSTANCE_ENCOUNTER_ENGAGE_UNIT",
      "WA_DELAYED_PLAYER_ENTERING_WORLD",
      "UNIT_DISPLAYPOWER"
    },
    force_events = {
      "player",
      "target",
      "focus",
      "pet"
    },
    name = L["Power"],
    init = function(trigger)
      trigger.unit = trigger.unit or "player";
      local ret = [=[
        local unit = unit or [[%s]];
        local concernedUnit = [[%s]];
        local powerType = %s;
      ]=];
    ret = ret:format(trigger.unit, trigger.unit, trigger.use_powertype and trigger.powertype or "nil");
    if (trigger.use_powertype and trigger.powertype == 99) then
      ret = ret .. [[
        local UnitPower = UnitStagger;
        local UnitPowerMax = UnitHealthMax;
      ]]
    end
    return ret
    end,
    args = {
      {
        name = "unit",
        required = true,
        display = L["Unit"],
        type = "unit",
        init = "arg",
        values = "actual_unit_types_with_specific"
      },
      {
        name = "powertype",
        -- required = true,
        display = L["Power Type"],
        type = "select",
        values = "power_types_with_stagger",
        test = "true",
      },
      {
        name = "requirePowerType",
        display = L["Only if Primary"],
        type = "toggle",
        test = "UnitPowerType(unit) == powerType",
        enable = function(trigger)
          return trigger.use_powertype
        end,
      },
      {
        name = "power",
        display = L["Power"],
        type = "number",
        init = "UnitPower(unit, powerType)"
      },
      {
        name = "percentpower",
        display = L["Power (%)"],
        type = "number",
        init = "((UnitPower(unit, powerType) or 0) / math.max(1, UnitPowerMax(unit, powerType))) * 100;"
      },
      {
        hidden = true,
        test = "UnitExists(concernedUnit)"
      }
    },
    durationFunc = function(trigger)
      local powerType = trigger.use_powertype and trigger.powertype;
      if (powerType == 99) then
        return UnitStagger(trigger.unit), math.max(1, UnitHealthMax(trigger.unit)), "fastUpdate";
      end
      return UnitPower(trigger.unit, powerType), math.max(1, UnitPowerMax(trigger.unit, powerType)), "fastUpdate";
    end,
    stacksFunc = function(trigger)
      local powerType = trigger.use_powertype and trigger.powertype;
      if (powerType == 99) then
        return UnitStagger(trigger.unit);
      end
      return UnitPower(trigger.unit, powerType);
    end,
    automatic = true
  },
  ["Alternate Power"] = {
    type = "status",
    events = {
      "UNIT_POWER_FREQUENT",
      "PLAYER_TARGET_CHANGED",
      "PLAYER_FOCUS_CHANGED"
    },
    force_events = {
      "player",
      "target",
      "focus",
      "pet"
    },
    name = L["Alternate Power"],
    init = function(trigger)
      trigger.unit = trigger.unit or "player";
      local ret = [=[
        local unit = unit or [[%s]]
        local concernedUnit = [[%s]]
        local _, _, _, _, _, _, _, _, _, _, name = UnitAlternatePowerInfo([[%s]]);
      ]=]
      return ret:format(trigger.unit, trigger.unit, trigger.unit);
    end,
    args = {
      {
        name = "unit",
        required = true,
        display = L["Unit"],
        type = "unit",
        init = "arg",
        values = "actual_unit_types_with_specific"
      },
      {
        name = "power",
        display = L["Alternate Power"],
        type = "number",
        init = "UnitPower(unit, 10)"
      },
      {
        hidden = true,
        test = "UnitExists(concernedUnit) and name"
      }
    },
    durationFunc = function(trigger)
      return UnitPower(trigger.unit, 10), math.max(1, UnitPowerMax(trigger.unit, 10)), "fastUpdate";
    end,
    nameFunc = function(trigger)
      local _, _, _, _, _, _, _, _, _, _, name = UnitAlternatePowerInfo(trigger.unit);
      return name;
    end,
    iconFunc = function(trigger)
      local icon = UnitAlternatePowerTextureInfo(trigger.unit, 0);
      return icon;
    end,
    automatic = true
  },
  -- Todo: Give useful options to condition based on GUID and flag info
  ["Combat Log"] = {
    type = "event",
    events = {
      "COMBAT_LOG_EVENT_UNFILTERED"
    },
    init = function(trigger)
      local ret = [[
        local use_cloneId = %s;
      ]];
      return ret:format(trigger.use_cloneId and "true" or "false");
    end,
    name = L["Combat Log"],
    canHaveAuto = true,
    statesParameter = "all",
    args = {
      {}, -- timestamp ignored with _ argument
      {}, -- messageType ignored with _ argument (it is checked before the dynamic function)
      {}, -- hideCaster ignored with _ argument
      {
        name = "sourceGUID",
        init = "arg",
        hidden = "true",
        test = "true",
        store = true
      },
      {
        name = "sourceUnit",
        display = L["Source Unit"],
        type = "unit",
        test = "(sourceGUID or '') == (UnitGUID([[%s]]) or '') and sourceGUID",
        values = "actual_unit_types_with_specific",
        enable = function(trigger)
          return not (trigger.subeventPrefix == "ENVIRONMENTAL")
        end,
        store = true
      },
      {
        name = "sourceName",
        display = L["Source Name"],
        type = "string",
        init = "arg",
        enable = function(trigger)
          return not (trigger.subeventPrefix == "ENVIRONMENTAL")
        end,
        store = true
      },
      {}, -- sourceFlags ignored with _ argument
      {}, -- sourceRaidFlags ignored with _ argument
      {
        name = "destGUID",
        init = "arg",
        hidden = "true",
        test = "true",
        store = true
      },
      {
        name = "destUnit",
        display = L["Destination Unit"],
        type = "unit",
        test = "(destGUID or '') == (UnitGUID([[%s]]) or '') and destGUID",
        values = "actual_unit_types_with_specific",
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
        store = true
      },
      {
        name = "destName",
        display = L["Destination Name"],
        type = "string",
        init = "arg",
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
        store = true

      },
      {
        enable = function(trigger)
          return (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end
      },
      {}, -- destFlags ignored with _ argument
      {}, -- destRaidFlags ignored with _ argument
      {
        name = "spellId",
        display = L["Spell Id"],
        type = "string",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventPrefix and (trigger.subeventPrefix:find("SPELL") or trigger.subeventPrefix == "RANGE" or trigger.subeventPrefix:find("DAMAGE"))
        end,
        store = true
      },
      {
        name = "spellName",
        display = L["Spell Name"],
        type = "string",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventPrefix and (trigger.subeventPrefix:find("SPELL") or trigger.subeventPrefix == "RANGE" or trigger.subeventPrefix:find("DAMAGE"))
        end,
        store = true
      },
      {
        enable = function(trigger)
          return trigger.subeventPrefix and (trigger.subeventPrefix:find("SPELL") or trigger.subeventPrefix == "RANGE" or trigger.subeventPrefix:find("DAMAGE"))
        end
      }, -- spellSchool ignored with _ argument
      {
        name = "environmentalType",
        display = L["Environment Type"],
        type = "select",
        values = "environmental_types",
        enable = function(trigger)
          return trigger.subeventPrefix == "ENVIRONMENTAL"
        end
      },
      {
        name = "missType",
        display = L["Miss Type"],
        type = "select",
        init = "arg",
        values = "miss_types",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_MISSED" or trigger.subeventPrefix == "DAMAGE_SHIELD_MISSED")
        end
      },
      {
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_INTERRUPT" or trigger.subeventSuffix == "_DISPEL" or trigger.subeventSuffix == "_DISPEL_FAILED" or trigger.subeventSuffix == "_STOLEN" or trigger.subeventSuffix == "_AURA_BROKEN_SPELL")
        end
      }, -- extraSpellId ignored with _ argument
      {
        name = "extraSpellName",
        display = L["Extra Spell Name"],
        type = "string",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_INTERRUPT" or trigger.subeventSuffix == "_DISPEL" or trigger.subeventSuffix == "_DISPEL_FAILED" or trigger.subeventSuffix == "_STOLEN" or trigger.subeventSuffix == "_AURA_BROKEN_SPELL")
        end,
        store = true
      },
      {
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_INTERRUPT" or trigger.subeventSuffix == "_DISPEL" or trigger.subeventSuffix == "_DISPEL_FAILED" or trigger.subeventSuffix == "_STOLEN" or trigger.subeventSuffix == "_AURA_BROKEN_SPELL")
        end
      }, -- extraSchool ignored with _ argument
      {
        name = "auraType",
        display = L["Aura Type"],
        type = "select",
        init = "arg",
        values = "aura_types",
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix:find("AURA") or trigger.subeventSuffix == "_DISPEL" or trigger.subeventSuffix == "_STOLEN")
        end
      },
      {
        name = "amount",
        display = L["Amount"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventSuffix == "_MISSED" or trigger.subeventSuffix == "_HEAL" or trigger.subeventSuffix == "_ENERGIZE" or trigger.subeventSuffix == "_DRAIN" or trigger.subeventSuffix == "_LEECH" or trigger.subeventPrefix:find("DAMAGE"))
        end,
        store = true
      },
      {
        name = "overkill",
        display = L["Overkill"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end,
        store = true
      },
      {
        name = "overhealing",
        display = L["Overhealing"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventSuffix == "_HEAL"
        end,
        store = true
      },
      {
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end
      }, -- damage school ignored with _ argument
      {
        name = "resisted",
        display = L["Resisted"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end,
        store = true
      },
      {
        name = "blocked",
        display = L["Blocked"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end,
        store = true
      },
      {
        name = "absorbed",
        display = L["Absorbed"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT" or trigger.subeventSuffix == "_HEAL")
        end,
        store = true
      },
      {
        name = "critical",
        display = L["Critical"],
        type = "tristate",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT" or trigger.subeventSuffix == "_HEAL")
        end,
        store = true
      },
      {
        name = "glancing",
        display = L["Glancing"],
        type = "tristate",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end,
        store = true
      },
      {
        name = "crushing",
        display = L["Crushing"],
        type = "tristate",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end,
        store = true
      },
      {
        name = "isOffHand",
        display = L["Is Off Hand"],
        type = "tristate",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end,
        store = true
      },
      {
        name = "multistrike",
        display = L["Multistrike"],
        type = "tristate",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT" or trigger.subeventSuffix == "_HEAL")
        end,
        store = true
      },
      {
        name = "number",
        display = L["Number"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_EXTRA_ATTACKS" or trigger.subeventSuffix:find("DOSE"))
        end,
        store = true
      },
      {
        name = "powerType",
        display = L["Power Type"],
        type = "select", init = "arg",
        values = "power_types",
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_ENERGIZE" or trigger.subeventSuffix == "_DRAIN" or trigger.subeventSuffix == "_LEECH")
        end
      },
      {
        name = "extraAmount",
        display = L["Extra Amount"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_ENERGIZE" or trigger.subeventSuffix == "_DRAIN" or trigger.subeventSuffix == "_LEECH")
        end,
        store = true
      },
      {
        enable = function(trigger)
          return trigger.subeventSuffix == "_CAST_FAILED"
        end
      }, -- failedType ignored with _ argument - theoretically this is not necessary because it is the last argument in the event, but it is added here for completeness
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle",
        test = "true",
        init = "use_cloneId and WeakAuras.GetUniqueCloneId() or ''"
      },
      {
        hidden = true,
        name = "icon",
        init = "spellId and select(3, GetSpellInfo(spellId)) or 'Interface\\\\Icons\\\\INV_Misc_QuestionMark'",
        store = true,
        test = "true"
      }
    }
  },
  ["Cooldown Progress (Spell)"] = {
    type = "status",
    events = function(trigger, untrigger)
      local events = {
        "SPELL_COOLDOWN_READY",
        "SPELL_COOLDOWN_CHANGED",
        "SPELL_COOLDOWN_STARTED",
        "COOLDOWN_REMAINING_CHECK",
        "WA_DELAYED_PLAYER_ENTERING_WORLD"
      };
      if (trigger.use_showgcd) then
        tinsert(events, "GCD_START");
        tinsert(events, "GCD_CHANGE");
        tinsert(events, "GCD_END");
      end
      return events;
    end,
    force_events = "SPELL_COOLDOWN_FORCE",
    name = L["Cooldown Progress (Spell)"],
    init = function(trigger)
      trigger.spellName = trigger.spellName or 0;
      local spellName = type(trigger.spellName) == "number" and GetSpellInfo(trigger.spellName) or trigger.spellName;
      trigger.realSpellName = spellName; -- Cache
      WeakAuras.WatchSpellCooldown(spellName, trigger.use_matchedRune);
      if (trigger.use_showgcd) then
        WeakAuras.WatchGCD();
      end
      local ret = [=[
        local spellname = [[%s]]
        local ignoreRuneCD = %s
        local showgcd = %s;
        local startTime, duration = WeakAuras.GetSpellCooldown(spellname, ignoreRuneCD, showgcd);
        local charges = WeakAuras.GetSpellCharges(spellname);
        if (charges == nil) then
            charges = (duration == 0) and 1 or 0;
        end
        if (duration == 0 and charges == 0) then
          charges = 1;
        end
        local showOn = %s
      ]=];
      if(trigger.use_remaining and trigger.showOn ~= "showOnReady") then
        local ret2 = [[
          local expirationTime = startTime + duration
          local remaining = expirationTime > 0 and (expirationTime - GetTime()) or 0;
          local remainingCheck = %s;
          if(remaining >= remainingCheck) then
            WeakAuras.ScheduleCooldownScan(expirationTime - remainingCheck);
          end
        ]];
        ret = ret..ret2:format(tonumber(trigger.remaining or 0) or 0);
      end
      return ret:format(spellName,
                        (trigger.use_matchedRune and "true" or "false"),
                        (trigger.use_showgcd and "true" or "false"),
                        "[[" .. (trigger.showOn or "") .. "]]");
    end,
    args = {
      {
      }, -- Ignore first argument (id)
      {
        name = "matchedRune",
        display = L["Ignore Rune CD"],
        type = "toggle",
        test = "true",
      },
      {
        name = "showgcd",
        display = L["Show Global Cooldown"],
        type = "toggle",
        test = "true"
      },
      {
        name = "spellName",
        required = true,
        display = L["Spell"],
        type = "spell",
        test = "true"
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return (trigger.showOn ~= "showOnReady") end
      },
      {
        name = "charges",
        display = L["Charges"],
        type = "number"
      },
      {
        name = "showOn",
        display =  L["Show"],
        type = "select",
        values = "cooldown_progress_behavior_types",
        test = "true",
        required = true,
      },
      {
        hidden = true,
        test = "(showOn == \"showOnReady\" and startTime == 0) " ..
               "or (showOn == \"showOnCooldown\" and startTime > 0) " ..
               "or (showOn == \"showAlways\")"
      }
    },
    durationFunc = function(trigger)
      local startTime, duration = WeakAuras.GetSpellCooldown(trigger.realSpellName or 0, trigger.use_matchedRune, trigger.use_showgcd);
      startTime = startTime or 0;
      duration = duration or 0;
      return duration, startTime + duration;
    end,
    nameFunc = function(trigger)
      local name = GetSpellInfo(trigger.realSpellName or 0);
      if(name) then
        return name;
      end
      name = GetSpellInfo(trigger.spellName or 0);
      if (name) then
        return name;
      end
      return "Invalid";
    end,
    iconFunc = function(trigger)
      local _, _, icon = GetSpellInfo(trigger.realSpellName or 0);
      if (not icon) then
        icon = select(3, GetSpellInfo(trigger.spellName or 0));
      end
      return icon;
    end,
    stacksFunc = function(trigger)
      return WeakAuras.GetSpellCharges(trigger.realSpellName);
    end,
    hasSpellID = true,
    automaticrequired = true,
    automaticAutoHide = false
  },
  ["Cooldown Ready (Spell)"] = {
    type = "event",
    events = {
      "SPELL_COOLDOWN_READY",
    },
    name = L["Cooldown Ready (Spell)"],
    init = function(trigger)
    --trigger.spellName = WeakAuras.CorrectSpellName(trigger.spellName) or 0;
    trigger.spellName = trigger.spellName or 0;
      WeakAuras.WatchSpellCooldown(trigger.spellName or 0);
    end,
    args = {
      {
        name = "spellName",
        required = true,
        display = L["Spell"],
        type = "spell",
        init = "arg"
      }
    },
    nameFunc = function(trigger)
      local name = GetSpellInfo(trigger.spellName or 0);
      if(name) then
        return name;
      else
        return "Invalid";
      end
    end,
    iconFunc = function(trigger)
      local _, _, icon = GetSpellInfo(trigger.spellName or 0);
      return icon;
    end,
    hasSpellID = true
  },
  ["Charges Changed (Spell)"] = {
    type = "event",
    events = {
      "SPELL_CHARGES_CHANGED",
    },
    name = L["Charges Changed (Spell)"],
    init = function(trigger)
    --trigger.spellName = WeakAuras.CorrectSpellName(trigger.spellName) or 0;
      trigger.spellName = trigger.spellName or 0;
      WeakAuras.WatchSpellCooldown(trigger.spellName or 0);
      local ret = [[
        local triggerDirection = "%s";
        local directionCheck = triggerDirection == "CHANGED"
           or (triggerDirection == "GAINED" and direction > 0)
           or (triggerDirection == "LOST" and direction < 0)
      ]]
      return ret:format(trigger.direction or "CHANGED");
    end,
    args = {
      {
        name = "spellName",
        required = true,
        display = L["Spell"],
        type = "spell",
        init = "arg"
      },
      {
        name = "direction",
        required = true,
        display = L["Charge gained/lost"],
        type = "select",
        values = "charges_change_type",
        init = "arg",
        test = "directionCheck"
      },
      {
        name = "charges",
        display = L["Charges"],
        type = "number",
        init = "arg",
      }
    },
    nameFunc = function(trigger)
      local name = GetSpellInfo(trigger.spellName or 0);
      if(name) then
        return name;
      else
        return "Invalid";
      end
    end,
    iconFunc = function(trigger)
      local _, _, icon = GetSpellInfo(trigger.spellName or 0);
      return icon;
    end,
    hasSpellID = true
  },
  ["Cooldown Progress (Item)"] = {
    type = "status",
    events = {
      "ITEM_COOLDOWN_READY",
      "ITEM_COOLDOWN_CHANGED",
      "ITEM_COOLDOWN_STARTED",
      "COOLDOWN_REMAINING_CHECK"
    },
    force_events = "ITEM_COOLDOWN_FORCE",
    name = L["Cooldown Progress (Item)"],
    init = function(trigger)
      --trigger.itemName = WeakAuras.CorrectItemName(trigger.itemName) or 0;
      trigger.itemName = trigger.itemName or 0;
      local itemName = type(trigger.itemName) == "number" and trigger.itemName or "[["..trigger.itemName.."]]";
      WeakAuras.WatchItemCooldown(trigger.itemName);
      local ret = [[
        local startTime, duration = WeakAuras.GetItemCooldown(%s);
        local showOn = %s
      ]];
      if(trigger.use_remaining and trigger.showOn ~= "showOnReady") then
        local ret2 = [[
          local expirationTime = startTime + duration
          local remaining = expirationTime > 0 and (expirationTime - GetTime()) or 0;
          local remainingCheck = %s;
          if(remaining >= remainingCheck) then
            WeakAuras.ScheduleCooldownScan(expirationTime - remainingCheck);
          end
        ]];
        ret = ret..ret2:format(tonumber(trigger.remaining or 0) or 0);
      end
      return ret:format(itemName,  "[[" .. (trigger.showOn or "") .. "]]");
    end,
    args = {
      {
        name = "itemName",
        required = true,
        display = L["Item"],
        type = "item",
        test = "true"
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return (trigger.showOn ~= "showOnReady") end,
        init = "remaining"
      },
      {
        name = "showOn",
        display =  L["Show"],
        type = "select",
        values = "cooldown_progress_behavior_types",
        test = "true",
        required = true,
      },
      {
        hidden = true,
        test = "(showOn == \"showOnReady\" and startTime == 0) " ..
               "or (showOn == \"showOnCooldown\" and startTime > 0) " ..
               "or (showOn == \"showAlways\")"
      }
    },
    durationFunc = function(trigger)
      local startTime, duration = WeakAuras.GetItemCooldown(type(trigger.itemName) == "number" and trigger.itemName or 0);
      startTime = startTime or 0;
      duration = duration or 0;
      return duration, startTime + duration;
    end,
    nameFunc = function(trigger)
      local name = GetItemInfo(trigger.itemName or 0);
      if(name) then
        return name;
      else
        return "Invalid";
      end
    end,
    iconFunc = function(trigger)
      local _, _, _, _, _, _, _, _, _, icon = GetItemInfo(trigger.itemName or 0);
      return icon;
    end,
    hasItemID = true,
    automaticrequired = true,
    automaticAutoHide = false
  },
  ["Cooldown Progress (Equipment Slot)"] = {
    type = "status",
    events = {
      "ITEM_SLOT_COOLDOWN_READY",
      "ITEM_SLOT_COOLDOWN_STARTED",
      "ITEM_SLOT_COOLDOWN_CHANGED",
      "COOLDOWN_REMAINING_CHECK",
    },
    force_events = "ITEM_COOLDOWN_FORCE",
    name = L["Cooldown Progress (Equipment Slot)"],
    init = function(trigger)
      WeakAuras.WatchItemSlotCooldown(trigger.itemSlot);
      local ret = [[
        local startTime, duration, enable = WeakAuras.GetItemSlotCooldown(%s);
        local showOn = %s
        local remaining = startTime + duration - GetTime();
      ]];
      if(trigger.use_remaining and trigger.showOn ~= "showOnReady") then
        local ret2 = [[
          local expirationTime = startTime + duration
          local remaining = expirationTime > 0 and (expirationTime - GetTime()) or 0;
          local remainingCheck = %s;
          if(remaining >= remainingCheck) then
            WeakAuras.ScheduleCooldownScan(expirationTime - remainingCheck);
          end
        ]];
        ret = ret..ret2:format(tonumber(trigger.remaining or 0) or 0);
      end
      return ret:format(trigger.itemSlot or "0",  "[[" .. (trigger.showOn or "") .. "]]");
    end,
    args = {
      {
        name = "itemSlot",
        required = true,
        display = L["Equipment Slot"],
        type = "select",
        values = "item_slot_types",
        test = "true"
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return (trigger.showOn ~= "showOnReady") end,
        init = "remaining"
      },
      {
        name = "testForCooldown",
        display = L["is useable"],
        type = "toggle",
        test = "enable == 1"
      },
      {
        name = "showOn",
        display =  L["Show"],
        type = "select",
        values = "cooldown_progress_behavior_types",
        test = "true",
        required = true,
      },
      {
        hidden = true,
        test = "(showOn == \"showOnReady\" and startTime == 0) " ..
               "or (showOn == \"showOnCooldown\" and startTime > 0) " ..
               "or (showOn == \"showAlways\")"
      }
    },
    durationFunc = function(trigger)
      local startTime, duration = GetInventoryItemCooldown("player", trigger.itemSlot or 0);
      startTime = startTime or 0;
      duration = duration or 0;
      return duration, startTime + duration;
    end,
    nameFunc = function(trigger)
      return "";
    end,
    iconFunc = function(trigger)
      return GetInventoryItemTexture("player", trigger.itemSlot or 0);
    end,
    automaticrequired = true,
    automaticAutoHide = false
  },
  ["Cooldown Ready (Item)"] = {
    type = "event",
    events = {
      "ITEM_COOLDOWN_READY"
    },
    name = L["Cooldown Ready (Item)"],
    init = function(trigger)
      --trigger.itemName = WeakAuras.CorrectItemName(trigger.itemName) or 0;
      trigger.itemName = trigger.itemName or 0;
      WeakAuras.WatchItemCooldown(trigger.itemName);
    end,
    args = {
      {
        name = "itemName",
        required = true,
        display = L["Item"],
        type = "item",
        init = "arg"
      }
    },
    nameFunc = function(trigger)
      local name = GetItemInfo(trigger.itemName or 0);
      if(name) then
        return name;
      else
        return "Invalid";
      end
    end,
    iconFunc = function(trigger)
      local _, _, _, _, _, _, _, _, _, icon = GetItemInfo(trigger.itemName or 0);
      return icon;
    end,
    hasItemID = true
  },
  ["GTFO"] = {
    type = "event",
    events = {
      "GTFO_DISPLAY"
    },
    name = L["GTFO Alert"],
    args = {
      {
        name = "alertType",
        display = "Alert Type",
        type = "select",
        init = "arg",
        values = "gtfo_types"
      },
    },
  },
  -- DBM events
  ["DBM Announce"] = {
    type = "event",
    events = {
      "DBM_Announce"
    },
    name = L["DBM Announce"],
    init = function(trigger)
      WeakAuras.RegisterDBMCallback("DBM_Announce");
      local ret = "local use_cloneId = %s;"
      return ret:format(trigger.use_cloneId and "true" or "false");
    end,
    statesParameter = "all",
    canHaveAuto = true,
    args = {
      {
        name = "message",
        init = "arg",
        display = L["Message"],
        type = "longstring",
        store = true
      },
      {
        name = "name",
        init = "message",
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "icon",
        init = "arg",
        store = true,
        hidden = true,
        test = "true"
      },
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle",
        test = "true",
        init = "use_cloneId and WeakAuras.GetUniqueCloneId() or ''"
      },
    }
  },
  ["DBM Timer"] = {
    type = "status",
    events = {
      "DBM_TimerStart", "DBM_TimerStop", "DBM_TimerStopAll", "DBM_TimerUpdate", "DBM_TimerForce"
    },
    force_events = "DBM_TimerForce",
    name = L["DBM Timer"],
    canHaveAuto = true,
    canHaveDuration = true,
    triggerFunction = function(trigger)
      WeakAuras.RegisterDBMCallback("DBM_TimerStart");
      WeakAuras.RegisterDBMCallback("DBM_TimerStop");
      WeakAuras.RegisterDBMCallback("wipe");
      WeakAuras.RegisterDBMCallback("kill");

      local ret = "return function (states, event, id)\n"
      -- ret = ret .. "          print(event, id)\n";
      if (trigger.use_id) then
        ret = ret .. "          local triggerId = \"" .. (trigger.id or "") .. "\"\n";
      else
        ret = ret .. "          local triggerId = nil\n";
      end

      if (trigger.use_message) then
        local ret2 = [=[
          local triggerMessage = [[%s]]
          local triggerOperator = [[%s]]
        ]=]
        ret = ret .. ret2:format(trigger.message or "", trigger.message_operator  or "")
      else
        ret = ret .. [[
          local triggerMessage = nil;
          local triggerOperator = nil;
        ]]
      end

      if (trigger.use_spellId and trigger.spellId) then
        local ret2 = [=[
          local triggerSpellId = [[%s]];
        ]=];
        ret = ret .. ret2:format(trigger.spellId or "");
      else
        ret = ret .. [[
          local triggerSpellId = nil;
        ]];
      end
      local copyOrSchedule;
      if (trigger.use_remaining) then
        local ret2 = [[
          local remainingCheck = %s;
        ]];
        ret = ret .. ret2:format(trigger.remaining or 0);
        copyOrSchedule = [[
          local remainingTime = bar.expirationTime - GetTime()
          if (remainingTime %s %s) then
            WeakAuras.CopyBarToState(bar, states, id);
          elseif (states[id] and states[id].show) then
              states[id].show = false;
              states[id].changed = true;
          end
          if (remainingTime >= remainingCheck) then
            WeakAuras.ScheduleDbmCheck(bar.expirationTime - remainingCheck);
          end
        ]]
        copyOrSchedule = copyOrSchedule:format(trigger.remaining_operator or "<", trigger.remaining or 0);
      else
        copyOrSchedule = [[
          WeakAuras.CopyBarToState(bar, states, id);
          ]];
      end
      if (trigger.use_cloneId) then
        ret = ret .. [[
          if (event == "DBM_TimerStart") then
            if (WeakAuras.DBMTimerMatches(id, triggerId, triggerMessage, triggerOperator, triggerSpellId)) then
              local bar = WeakAuras.GetDBMTimerById(id);
          ]]
        ret = ret .. copyOrSchedule;
        ret = ret .. [[
            end
          elseif (event == "DBM_TimerUpdate") then
            for id, bar in pairs(WeakAuras.GetAllDBMTimers()) do
              if (WeakAuras.DBMTimerMatches(id, triggerId, triggerMessage, triggerOperator, triggerSpellId)) then
                ]]
        ret = ret .. copyOrSchedule;
        ret = ret .. [[
              end
            end

          elseif (event == "DBM_TimerStop") then
            if (states[id]) then
              states[id].show = false;
              states[id].changed = true;
            end
          elseif (event == "DBM_TimerStopAll") then
            for _, state in pairs(states) do
              state.show = false;
              state.changed = false;
            end
          elseif (event == "DBM_TimerForce") then
            wipe(states);
            for id, bar in pairs(WeakAuras.GetAllDBMTimers()) do
              if (WeakAuras.DBMTimerMatches(id, triggerId, triggerMessage, triggerOperator, triggerSpellId)) then
                ]]
        ret = ret .. copyOrSchedule;
        ret = ret .. [[
              end
            end
          end
          return true;
        end
        ]]
        --print(ret);
        return ret
      else -- no clones
        ret = ret .. [[
          local bar = WeakAuras.GetDBMTimer(triggerId, triggerMessage, triggerOperator, triggerSpellId);
          local id = "";
          if (bar) then
        ]]
        ret = ret .. copyOrSchedule;
        ret = ret .. [[
          else
            if (states[""] and states[""].show) then
              states[""].show = false;
              states[""].changed = true;
            end
          end
          return true;
        end]]
        --print(ret);
        return ret;
      end
    end,
    statesParameter = "full",
    canHaveAuto = true,
    args = {
      {
        name = "id", -- TODO Is there ever anything useful in ID?
        display = L["Id"],
        type = "string"
      },
      {
        name = "message",
        display = L["Message"],
        type = "longstring"
      },
      {
        name = "spellId",
        display = L["Spell/Encounter Id"],
        type = "string"
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
      },
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle"
      }
    },
    automaticrequired = true,
    automaticAutoHide = false
  },
  -- BigWigs
  ["BigWigs Message"] = {
    type = "event",
    events = {
      "BigWigs_Message"
    },
    name = L["BigWigs Message"],
    init = function(trigger)
      WeakAuras.RegisterBigWigsCallback("BigWigs_Message");
      local ret = "local use_cloneId = %s;"
      return ret:format(trigger.use_cloneId and "true" or "false");
    end,
    statesParameter = "all",
    canHaveAuto = true,
    args = {
      {
        name = "addon",
        init = "arg",
        display = L["BigWigs Addon"],
        type = "string"
      },
      {
        name = "spellId",
        init = "arg",
        display = L["Spell Id"],
        type = "number",
        store = true
      },
      {
        name = "text",
        init = "arg",
        display = L["Message"],
        type = "longstring",
        store = true
      },
      {
        name = "name",
        init = "text",
        hidden = true,
        test = "true",
        store = true
      },
      {}, -- Importance, might be useful
      {
        name = "icon",
        init = "arg",
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle",
        test = "true",
        init = "use_cloneId and WeakAuras.GetUniqueCloneId() or ''"
      },
    }
  },
  ["BigWigs Timer"] = {
    type = "status",
    events = {
      "BigWigs_StartBar", "BigWigs_StopBar", "BigWigs_Timer_Update",
    },
    force_events = "BigWigs_Timer_Force",
    name = L["BigWigs Timer"],
    canHaveAuto = true,
    canHaveDuration = true,
    triggerFunction = function(trigger)
      WeakAuras.RegisterBigWigsTimer();
      local ret = [=[
        return function(states, event, id)
        local triggerAddon = %s;
        local triggerSpellId = %s;
        local triggerText = %s;
        local triggerTextOperator = [[%s]];
      ]=]

      ret = ret:format(trigger.use_addon and ('[[' .. (trigger.addon or '') .. ']]') or "nil",
                       trigger.use_spellId and tostring(trigger.spellId) or "nil",
                       trigger.use_text and ('[[' .. (trigger.text or '') .. ']]') or "nil",
                       trigger.use_text and trigger.text_operator or ""
                       );

      local copyOrSchedule;
      if (trigger.use_remaining) then
        local ret2 = [[
          local remainingCheck = %s;
        ]];
        ret = ret .. ret2:format(trigger.remaining or 0);
        copyOrSchedule = [[
          local remainingTime = bar.expirationTime - GetTime()
          if (remainingTime %s %s) then
            WeakAuras.CopyBigWigsTimerToState(bar, states, id);
          elseif (states[id] and states[id].show) then
              states[id].show = false;
              states[id].changed = true;
          end
          if (remainingTime >= remainingCheck) then
            WeakAuras.ScheduleBigWigsCheck(bar.expirationTime - remainingCheck);
          end
          ]]
        copyOrSchedule = copyOrSchedule:format(trigger.remaining_operator or "", trigger.remaining or 0);
      else
        copyOrSchedule = [[
          WeakAuras.CopyBigWigsTimerToState(bar, states, id);
          ]];
      end

      if (trigger.use_cloneId) then
        ret = ret .. [[
          if (event == "BigWigs_StartBar") then
            if (WeakAuras.BigWigsTimerMatches(id, triggerAddon, triggerSpellId, triggerTextOperator, triggerText)) then
              local bar = WeakAuras.GetBigWigsTimerById(id);
          ]]
        ret = ret .. copyOrSchedule;
        ret = ret .. [[
            end
          elseif (event == "BigWigs_StopBar") then
            if (states[id]) then
              states[id].show = false;
              states[id].changed = true;
            end
          elseif (event == "BigWigs_Timer_Update") then
            for id, bar in pairs(WeakAuras.GetAllBigWigsTimers()) do
              if (WeakAuras.BigWigsTimerMatches(id, triggerAddon, triggerSpellId, triggerTextOperator, triggerText)) then
                ]]
        ret = ret .. copyOrSchedule;
        ret = ret .. [[
              end
            end
          elseif (event == "BigWigs_Timer_Force") then
            wipe(states);
            for id, bar in pairs(WeakAuras.GetAllBigWigsTimers()) do
              if (WeakAuras.BigWigsTimerMatches(id, triggerAddon, triggerSpellId, triggerTextOperator, triggerText)) then
                ]]
        ret = ret .. copyOrSchedule;
        ret = ret .. [[
              end
            end
          end
          return true;
        end
        ]]
        return ret;
      else
        ret = ret .. [[
          local bar = WeakAuras.GetBigWigsTimer(triggerAddon, triggerSpellId, triggerTextOperator, triggerText);
          local id = "";
          if (bar) then
        ]]
        ret = ret .. copyOrSchedule;
        ret = ret .. [[
          else
            if (states[""] and states[""].show) then
              states[""].show = false;
              states[""].changed = true;
            end
          end
          return true;
        end]]
        --print(ret);
        return ret;
      end
    end,
    statesParameter = "full",
    canHaveAuto = true,
    args = {
      {
        name = "addon",
        display = L["BigWigs Addon"],
        type = "string",
      },
      {
        name = "spellId",
        display = L["Spell Id"], -- Correct?
        type = "number",
      },
      {
        name = "text",
        display = L["Message"],
        type = "longstring",
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
      },
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle",
        test = "true",
        init = "use_cloneId and WeakAuras.GetUniqueCloneId() or ''"
      }
    },
    automaticrequired = true,
    automaticAutoHide = false
  },
  ["Global Cooldown"] = {
    type = "status",
    events = {
      "GCD_START",
      "GCD_CHANGE",
      "GCD_END"
    },
    name = L["Global Cooldown"],
    init = function(trigger)
      WeakAuras.WatchGCD();
      local ret = [[
        local inverse = %s;
        local onGCD = WeakAuras.GetGCDInfo();
      ]];
      return ret:format(trigger.use_inverse and "true" or "false");
    end,
    args = {
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        hidden = true,
        test = "(inverse and onGCD == 0) or (not inverse and onGCD > 0)"
      }
    },
    durationFunc = function(trigger)
      local duration, expirationTime = WeakAuras.GetGCDInfo();
      return duration, expirationTime;
    end,
    nameFunc = function(trigger)
      local _, _, name = WeakAuras.GetGCDInfo();
      return name;
    end,
    iconFunc = function(trigger)
      local _, _, _, icon = WeakAuras.GetGCDInfo();
      return icon;
    end,
    hasSpellID = true,
    automaticrequired = true,
    automaticAutoHide = false
  },
  ["Swing Timer"] = {
    type = "status",
    events = {
      "SWING_TIMER_START",
      "SWING_TIMER_CHANGE",
      "SWING_TIMER_END"
    },
    name = L["Swing Timer"],
    init = function(trigger)
      trigger.hand = trigger.hand or "main";
      WeakAuras.InitSwingTimer();
      local ret = [=[
        local inverse = %s;
        local hand = [[%s]];
        local duration, expirationTime = WeakAuras.GetSwingTimerInfo(hand);
      ]=];
      return ret:format((trigger.use_inverse and "true" or "false"), trigger.hand);
    end,
    args = {
      {
        name = "hand",
        required = true,
        display = L["Weapon"],
        type = "select",
        values = "swing_types",
        test = "true"
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        hidden = true,
        test = "(inverse and duration == 0) or (not inverse and duration > 0)"
      }
    },
    durationFunc = function(trigger)
      local duration, expirationTime = WeakAuras.GetSwingTimerInfo(trigger.hand);
      return duration, expirationTime;
    end,
    nameFunc = function(trigger)
      local _, _, name = WeakAuras.GetSwingTimerInfo(trigger.hand);
      return name;
    end,
    iconFunc = function(trigger)
      local _, _, _, icon = WeakAuras.GetSwingTimerInfo(trigger.hand);
      return icon;
    end,
    automaticrequired = true
  },
  ["Action Usable"] = {
    type = "status",
    events = {
      "SPELL_COOLDOWN_READY",
      "SPELL_COOLDOWN_CHANGED",
      "SPELL_COOLDOWN_STARTED",
      "SPELL_UPDATE_USABLE",
      "PLAYER_TARGET_CHANGED",
      "UNIT_POWER_FREQUENT",
      "RUNE_POWER_UPDATE",
      "RUNE_TYPE_UPDATE"
    },
    force_events = true,
    name = L["Action Usable"],
    init = function(trigger)
      --trigger.spellName = WeakAuras.CorrectSpellName(trigger.spellName) or 0;
      trigger.spellName = trigger.spellName or 0;
      local spellName = type(trigger.spellName) == "number" and GetSpellInfo(trigger.spellName) or trigger.spellName;
      trigger.realSpellName = spellName; -- Cache
      WeakAuras.WatchSpellCooldown(spellName);
      local ret = [=[
        local spellname = [[%s]]
        local startTime, duration = WeakAuras.GetSpellCooldown(spellname);
        local charges = WeakAuras.GetSpellCharges(spellname);
        startTime = startTime or 0;
        duration = duration or 0;
        if (duration == 0 and charges == 0) then
          charges = 1;
        end
        local onCooldown = (duration > 0 and duration ~= WeakAuras.gcdDuration() and charges == nil) or (charges and charges == 0);
        local active = IsUsableSpell(spellname) and not onCooldown
        if (charges == nil) then
          charges = (duration == 0) and 1 or 0;
        end
      ]=]
      if(trigger.use_targetRequired) then
        ret = ret.."active = active and WeakAuras.IsSpellInRange(spellname or '', 'target')\n";
      end
      if(trigger.use_inverse) then
        ret = ret.."active = not active\n";
      end

      return ret:format(spellName)
    end,
    args = {
      {
        name = "spellName",
        display = L["Spell"],
        required = true,
        type = "spell",
        test = "true"
      },
      -- This parameter uses the IsSpellInRange API function, but it does not check spell range at all
      -- IsSpellInRange returns nil for invalid targets, 0 for out of range, 1 for in range (0 and 1 are both "positive" values)
      {
        name = "targetRequired",
        display = L["Require Valid Target"],
        type = "toggle",
        test = "true"
      },
      {
        name = "charges",
        display = L["Charges"],
        type = "number",
        enable = function(trigger) return not(trigger.use_inverse) end
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        hidden = true,
        test = "active"
      }
    },
    nameFunc = function(trigger)
      local name = GetSpellInfo(trigger.realSpellName or 0);
      if(name) then
        return name;
      end
      name = GetSpellInfo(trigger.spellName or 0);
      if (name) then
        return name;
      end
      return "Invalid";
    end,
    iconFunc = function(trigger)
      local _, _, icon = GetSpellInfo(trigger.realSpellName or 0);
      if (not icon) then
        icon = select(3, GetSpellInfo(trigger.spellName or 0));
      end
      return icon;
    end,
    stacksFunc = function(trigger)
      return WeakAuras.GetSpellCharges(trigger.realSpellName);
    end,
    hasSpellID = true,
    automaticrequired = true
  },
  ["Totem"] = {
    type = "status",
    events = {
      "PLAYER_TOTEM_UPDATE",
      "COOLDOWN_REMAINING_CHECK",
      "PLAYER_ENTERING_WORLD"
    },
    force_events = true,
    name = L["Totem"],
    statesParameter = "full",
    canHaveAuto = true,
    canHaveDuration = true,
    triggerFunction = function(trigger)
      local ret = [[return
      function (states)
        local totemType = %s;
        local triggerTotemName = %s
        local clone = %s
        local inverse = %s
        local remainingCheck = %s

        local function checkActive(remaining)
          return remaining %s remainingCheck;
        end

        if (totemType) then -- Check a specific totem slot
          local _, totemName, startTime, duration, icon = GetTotemInfo(totemType);
          active = (startTime and startTime ~= 0);
          if (triggerTotemName) then
            if (triggerTotemName ~= totemName) then
              active = false;
            end
          end
          if (inverse) then
            active = not active;
            if (triggerTotemName) then
              icon = select(3, GetSpellInfo(triggerTotemName));
            end
          elseif (active and remainingCheck) then
            local expirationTime = startTime and (startTime + duration) or 0;
            local remainingTime = expirationTime - GetTime()
            if (remainingTime >= remainingCheck) then
              WeakAuras.ScheduleCooldownScan(expirationTime - remainingCheck);
            end
            active = checkActive(remainingTime);
          end
          states[""] = states[""] or {}
          local state = states[""];
          state.show = active;
          state.changed = true;
          if (active) then
            state.name = totemName;
            state.progressType = "timed";
            state.duration = duration;
            state.expirationTime = startTime and (startTime + duration);
            state.icon = icon;
          end
        elseif inverse then -- inverse without a specific slot
          local found = false;
          for i = 1, 5 do
            local _, totemName, startTime, duration, icon = GetTotemInfo(i);
            if ((startTime and startTime ~= 0) and triggerTotemName == totemName) then
              found = true;
            end
          end
          local cloneId = "";
          states[cloneId] = states[cloneId] or {};
          local state = states[cloneId];
          state.show = not found;
          state.changed = true;
          state.name = triggerTotemName;
          if (triggerTotemName) then
            state.icon = select(3, GetSpellInfo(triggerTotemName));
          end
        else -- check all slots
          for i = 1, 5 do
            local _, totemName, startTime, duration, icon = GetTotemInfo(i);
            active = (startTime and startTime ~= 0);
            if (triggerTotemName) then
              if (triggerTotemName ~= totemName) then
                active = false;
              end
            end
            if (active and remainingCheck) then
              local expirationTime = startTime and (startTime + duration) or 0;
              local remainingTime = expirationTime - GetTime()
              if (remainingTime >= remainingCheck) then
                WeakAuras.ScheduleCooldownScan(expirationTime - remainingCheck);
              end
              active = checkActive(remainingTime);
            end

            local cloneId = clone and tostring(i) or "";
            states[cloneId] = states[cloneId] or {};
            local state = states[cloneId];
            state.show = active;
            state.changed = true;
            if (active) then
              state.name = totemName;
              state.progressType = "timed";
              state.duration = duration;
              state.expirationTime = startTime and (startTime + duration);
              state.icon = icon;
            end
            if (active and not clone) then
              break;
            end
          end
        end
        return true;
      end
      ]];
    local totemName = tonumber(trigger.totemName) and GetSpellInfo(tonumber(trigger.totemName)) or trigger.totemName;
    ret = ret:format(trigger.use_totemType and tonumber(trigger.totemType) or "nil",
                     trigger.use_totemName and "[[" .. (totemName or "")  .. "]]" or "nil",
                     trigger.use_clones and "true" or "false",
                     trigger.use_inverse and "true" or "false",
                     trigger.use_remaining and trigger.remaining or "nil",
                     trigger.use_remaining and trigger.remaining_operator or "<");
    return ret;
    end,
    args = {
      {
        name = "totemType",
        display = L["Totem Number"],
        type = "select",
        values = "totem_types"
      },
      {
        name = "totemName",
        display = L["Totem Name"],
        type = "string",
      },
      {
        name = "clones",
        display = L["Clone per Match"],
        type = "toggle",
        test = "true",
        enable = function(trigger) return not trigger.use_totemType end,
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return not(trigger.use_inverse) end
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true",
        enable = function(trigger) return trigger.use_totemName and not trigger.use_clones end
      }
    },
    automaticrequired = true
  },
  ["Item Count"] = {
    type = "status",
    events = {
      "BAG_UPDATE",
      "ITEM_COUNT_UPDATE",
      "PLAYER_ENTERING_WORLD"
    },
    force_events = true,
    name = L["Item Count"],
    init = function(trigger)
      if(trigger.use_includeCharges) then
        WeakAuras.RegisterItemCountWatch();
      end
      --trigger.itemName = WeakAuras.CorrectItemName(trigger.itemName) or 0;
      trigger.itemName = trigger.itemName or 0;
      local itemName = type(trigger.itemName) == "number" and trigger.itemName or "[["..trigger.itemName.."]]";
      local ret = [[
        local count = GetItemCount(%s, %s, %s);
      ]];
      return ret:format(itemName, trigger.use_includeBank and "true" or "nil", trigger.use_includeCharges and "true" or "nil");
    end,
    args = {
      {
        name = "itemName",
        required = true,
        display = L["Item"],
        type = "item",
        test = "true"
      },
      {
        name = "includeBank",
        display = L["Include Bank"],
        type = "toggle",
        test = "true"
      },
      {
        name = "includeCharges",
        display = L["Include Charges"],
        type = "toggle",
        test = "true"
      },
      {
        name = "count",
        display = L["Item Count"],
        type = "number"
      }
    },
    durationFunc = function(trigger)
      local count = GetItemCount(trigger.itemName, trigger.use_includeBank, trigger.use_includeCharges);
      return count, 0, true;
    end,
    nameFunc = function(trigger)
      return trigger.itemName;
    end,
    iconFunc = function(trigger)
      return GetItemIcon(trigger.itemName);
    end,
    hasItemID = true,
    automaticrequired = true
  },
  ["Stance/Form/Aura"] = {
    type = "status",
    events = {
      "UPDATE_SHAPESHIFT_FORM",
      "WA_DELAYED_PLAYER_ENTERING_WORLD"
    },
    force_events = true,
    name = L["Stance/Form/Aura"],
    init = function(trigger)
    local ret = [[
      local form = GetShapeshiftForm();
      local _, class = UnitClass('player');
      local form_ = %s;
      local inverse = %s;
    ]];

    return ret:format(trigger.form or 0, trigger.use_inverse and "true" or "false");
    end,
    args = {
      {
        name = "form",
        required = true,
        display = L["Form"],
        type = "select",
        values = "form_types",
        test = "true"
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        hidden = true,
        test = "(inverse and form ~= form_ or not inverse and form == form_)"
      }
    },
    nameFunc = function(trigger)
      local _, class = UnitClass("player");
      if(class == trigger.class) then
        local form = GetShapeshiftForm();
        local _, name = form > 0 and GetShapeshiftFormInfo(form) or "Humanoid";
        return name;
      else
        local types = WeakAuras[class:lower().."_form_types"];
        if(types) then
          return types[GetShapeshiftForm()];
        end
      end
    end,
    iconFunc = function(trigger)
      local _, class = UnitClass("player");
      if(class == trigger.class) then
        local form = GetShapeshiftForm();
        local icon = form > 0 and GetShapeshiftFormInfo(form) or "Interface\\Icons\\Achievement_Character_Human_Male";
        return icon;
      else
        return nil;
      end
    end,
    automaticrequired = true
  },
  ["Weapon Enchant"] = {
    type = "status",
    events = {
      "MAINHAND_TENCH_UPDATE",
      "OFFHAND_TENCH_UPDATE"
    },
    force_events = true,
    name = L["Fishing Lure / Weapon Enchant (Old)"],
    init = function(trigger)
      WeakAuras.TenchInit();
      local ret = [[
        local exists, _, name
        local inverse
      ]];
      if(trigger.weapon == "main") then
        ret = ret .. [[
          exists, _, name = WeakAuras.GetMHTenchInfo()
        ]];
      elseif(trigger.weapon == "off") then
        ret = ret .. [[
          exists, _, name = WeakAuras.GetOHTenchInfo()
        ]];
      end

      if(trigger.use_inverse) then
        ret = ret..[[
          inverse = true;
        ]];
      end

      if(trigger.use_enchant and trigger.enchant and trigger.enchant ~= "") then
        ret = ret .. [[
          exists = name == ']] .. trigger.enchant .. [[';
        ]]
      end
      return ret;
    end,
    args = {
      {
        name = "weapon",
        display = L["Weapon"],
        type = "select",
        values = "weapon_types",
        test = "(inverse and not exists) or (not inverse and exists)"
      },
      {
        name = "enchant",
        display = L["Weapon Enchant"],
        type = "string",
        test = "true"
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      }
    },
    durationFunc = function(trigger)
      local expirationTime, duration;
      if(trigger.weapon == "main") then
        expirationTime, duration = WeakAuras.GetMHTenchInfo();
      elseif(trigger.weapon == "off") then
        expirationTime, duration = WeakAuras.GetOHTenchInfo();
      end
      if(expirationTime) then
        return duration, expirationTime;
      else
        return 0, math.huge;
      end
    end,
    nameFunc = function(trigger)
      local _, name;
      if(trigger.weapon == "main") then
        _, _, name = WeakAuras.GetMHTenchInfo();
      elseif(trigger.weapon == "off") then
        _, _, name = WeakAuras.GetOHTenchInfo();
      end
      return name;
    end,
    iconFunc = function(trigger)
      local _, icon;
      if(trigger.weapon == "main") then
        _, _, _, icon = WeakAuras.GetMHTenchInfo();
      elseif(trigger.weapon == "off") then
        _, _, _, icon = WeakAuras.GetOHTenchInfo();
      end
      return icon;
    end,
    automaticrequired = true
  },
  ["Chat Message"] = {
    type = "event",
    events = {
      "CHAT_MSG_INSTANCE_CHAT",
      "CHAT_MSG_INSTANCE_CHAT_LEADER",
      "CHAT_MSG_BG_SYSTEM_ALLIANCE",
      "CHAT_MSG_BG_SYSTEM_HORDE",
      "CHAT_MSG_BG_SYSTEM_NEUTRAL",
      "CHAT_MSG_BN_WHISPER",
      "CHAT_MSG_CHANNEL",
      "CHAT_MSG_EMOTE",
      "CHAT_MSG_GUILD",
      "CHAT_MSG_MONSTER_EMOTE",
      "CHAT_MSG_MONSTER_PARTY",
      "CHAT_MSG_MONSTER_SAY",
      "CHAT_MSG_MONSTER_WHISPER",
      "CHAT_MSG_MONSTER_YELL",
      "CHAT_MSG_OFFICER",
      "CHAT_MSG_PARTY",
      "CHAT_MSG_PARTY_LEADER",
      "CHAT_MSG_RAID",
      "CHAT_MSG_RAID_LEADER",
      "CHAT_MSG_RAID_BOSS_EMOTE",
      "CHAT_MSG_RAID_BOSS_WHISPER",
      "CHAT_MSG_RAID_WARNING",
      "CHAT_MSG_SAY",
      "CHAT_MSG_WHISPER",
      "CHAT_MSG_YELL",
      "CHAT_MSG_SYSTEM"
    },
    name = L["Chat Message"],
    init = function(trigger)
      local ret = [[
        if (event:find('LEADER')) then
          event = event:sub(0, -8);
        end
        if (event == 'CHAT_MSG_TEXT_EMOTE') then
          event = 'CHAT_MSG_EMOTE';
        end
         local use_cloneId = %s;
      ]];
      return ret:format(trigger.use_cloneId and "true" or "false");
    end,
    statesParameter = "all",
    args = {
      {
        name = "messageType",
        display = L["Message Type"],
        type = "select",
        values = "chat_message_types",
        test = "event=='%s'",
        control = "WeakAurasSortedDropdown"
      },
      {
        name = "message",
        display = L["Message"],
        init = "arg",
        type = "longstring",
        store = true
      },
      {
        name = "sourceName",
        display = L["Source Name"],
        init = "arg",
        type = "string",
        store = true
      },
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle",
        test = "true",
        init = "use_cloneId and WeakAuras.GetUniqueCloneId() or ''"
      },
    }
  },
  ["Ready Check"] = {
    type = "event",
    events = {
      "READY_CHECK",
    },
    name = L["Ready Check"],
    args = {}
  },
  ["Combat Events"] = {
    type = "event",
    events = {
      "PLAYER_REGEN_ENABLED",
      "PLAYER_REGEN_DISABLED"
    },
    name = L["Entering/Leaving Combat"],
    args = {
      {
        name = "eventtype",
        required = true,
        display = L["Type"],
        type = "select",
        values = "combat_event_type",
        test = "event == (\"%s\")"
      }
    }
  },
  ["Death Knight Rune"] = {
    type = "status",
    events = {
      "RUNE_POWER_UPDATE",
      "RUNE_TYPE_UPDATE",
      "RUNE_COOLDOWN_READY",
      "RUNE_COOLDOWN_CHANGED",
      "RUNE_COOLDOWN_STARTED",
      "COOLDOWN_REMAINING_CHECK",
      "WA_DELAYED_PLAYER_ENTERING_WORLD"
    },
    force_events = "RUNE_COOLDOWN_FORCE",
    name = L["Death Knight Rune"],
    init = function(trigger)
    trigger.rune = trigger.rune or 0;
    if (trigger.use_rune) then
      WeakAuras.WatchRuneCooldown(trigger.rune);
    else
      for i = 1, 6 do
        WeakAuras.WatchRuneCooldown(i);
      end
    end
    local ret = [[
      local rune = %s;
      local startTime, duration = WeakAuras.GetRuneCooldown(rune);
      local inverse = %s;

      local numRunes = 0;
      for index = 1, 6 do
        local startTime = WeakAuras.GetRuneCooldown(index);
        if startTime == 0 then
          numRunes = numRunes  + 1;
        end
      end

    ]];
    if(trigger.use_remaining and not trigger.use_inverse) then
      local ret2 = [[
        local expirationTime = startTime + duration
        local remaining = expirationTime - GetTime();
        local remainingCheck = %s;
        if(remaining >= remainingCheck) then
          WeakAuras.ScheduleCooldownScan(expirationTime - remainingCheck);
        end
      ]];
      ret = ret..ret2:format(tonumber(trigger.remaining or 0) or 0);
    end
    return ret:format(trigger.rune, (trigger.use_inverse and "true" or "false"));
  end,
    args = {
      {
        name = "rune",
        display = L["Rune"],
        type = "select",
        values = "rune_specific_types",
        test = "(inverse and startTime == 0) or (not inverse and startTime > 0)",
        enable = function(trigger) return not trigger.use_runesCount end
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return trigger.use_rune and not(trigger.use_inverse) end
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true",
        enable = function(trigger) return trigger.use_rune end
      },
      {
        name = "runesCount",
        display = L["Runes Count"],
        type = "number",
        init = "numRunes",
        enable = function(trigger) return not trigger.use_rune end
      },
    },
    durationFunc = function(trigger)
      if trigger.use_rune then
        local startTime, duration
        if not(trigger.use_inverse) then
          startTime, duration = WeakAuras.GetRuneCooldown(trigger.rune);
        end

        startTime = startTime or 0;
        duration = duration or 0;

        return duration, startTime + duration;
      else
        local numRunes = 0;
        for index = 1, 6 do
          local startTime = GetRuneCooldown(index);
          if startTime == 0 then
            numRunes = numRunes  + 1;
          end
        end
        return numRunes, 6, true;
      end
    end,
    stacksFunc = function(trigger)
      local numRunes = 0;
      for index = 1, 6 do
        local startTime = select(1, GetRuneCooldown(index));
        if startTime == 0 then
          numRunes = numRunes  + 1;
        end
      end
      return numRunes;
    end,
    iconFunc = function(trigger)
      return "Interface\\PlayerFrame\\UI-PlayerFrame-Deathknight-SingleRune";
    end,
    automaticrequired = true,
    automaticAutoHide = false
  },
  ["Item Equipped"] = {
    type = "status",
    events = {
      "UNIT_INVENTORY_CHANGED",
      "WA_DELAYED_PLAYER_ENTERING_WORLD"
    },
    force_events = true,
    name = L["Item Equipped"],
    init = function(trigger)
    --trigger.itemName = WeakAuras.CorrectItemName(trigger.itemName) or 0;
    trigger.itemName = trigger.itemName or 0;
    local itemName = type(trigger.itemName) == "number" and trigger.itemName or "[[" .. trigger.itemName .. "]]";

      local ret = [[
        local inverse = %s;
        local equipped = IsEquippedItem(%s);
      ]];

    return ret:format(trigger.use_inverse and "true" or "false", itemName);
    end,
    args = {
      {
        name = "itemName",
        display = L["Item"],
        type = "item",
        required = true,
        test = "true"
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        hidden = true,
        test = "(inverse and not equipped) or (equipped and not inverse)"
      }
    },
    nameFunc = function(trigger)
      if not trigger.use_inverse then
        local name = GetItemInfo(trigger.itemName);
        return name;
      else
        return nil;
      end
    end,
    iconFunc = function(trigger)
      if not trigger.use_inverse then
        local texture = select(10, GetItemInfo(trigger.itemName));
        return texture;
      else
        return nil;
      end
    end,
    hasItemID = true,
    automaticrequired = true
  },
  ["Item Set Equipped"] = {
    type = "status",
    events = {
      "PLAYER_EQUIPMENT_CHANGED",
      "WEAR_EQUIPMENT_SET",
      "EQUIPMENT_SETS_CHANGED",
      "EQUIPMENT_SWAP_FINISHED",
      "WA_DELAYED_PLAYER_ENTERING_WORLD"
    },
    force_events = "PLAYER_EQUIPMENT_CHANGED",
    name = L["Item Set Equipped"],
    init = function(trigger)
      trigger.itemSetName = trigger.itemSetName or 0;
      local itemSetName = type(trigger.itemSetName) == "number" and trigger.itemSetName or "'" .. trigger.itemSetName .. "'";

      local ret = [[
        local useItemSetName = %s;
        local itemSetName = %s;
        local inverse = %s;
        local partial = %s;

        local equipped = WeakAuras.GetEquipmentSetInfo(useItemSetName and itemSetName or nil, partial);
      ]];

      return ret:format(trigger.use_itemSetName and "true" or "false",
                        itemSetName,
                        trigger.use_inverse and "true" or "false",
                        trigger.use_partial and "true" or "false");
    end,
    args = {
      {
        name = "itemSetName",
        display = L["Item Set"],
        type = "string",
        test = "true"
      },
      {
        name = "partial",
        display = L["Allow partial matches"],
        type = "toggle",
        test = "true"
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        hidden = true,
        test = "(inverse and not equipped) or (equipped and not inverse)"
      }
    },
    nameFunc = function(trigger)
      return WeakAuras.GetEquipmentSetInfo(trigger.use_itemSetName and trigger.itemSetName or nil, trigger.use_partial);
    end,
    iconFunc = function(trigger)
      local _, icon = WeakAuras.GetEquipmentSetInfo(trigger.use_itemSetName and trigger.itemSetName or nil, trigger.use_partial);
      return icon;
    end,
    durationFunc = function(trigger)
      local _, _, numEquipped, numItems = WeakAuras.GetEquipmentSetInfo(trigger.use_itemSetName and trigger.itemSetName or nil, trigger.use_partial);
      return numEquipped, numItems, true;
    end,
    hasItemID = true,
    automaticrequired = true
  },
  ["Threat Situation"] = {
    type = "status",
    events = {
      "UNIT_THREAT_SITUATION_UPDATE",
      "PLAYER_TARGET_CHANGED"
    },
    force_events = true,
    name = L["Threat Situation"],
    init = function(trigger)
      local ret = [[
        local status = UnitThreatSituation('player', %s) or -1;
        local aggro = status == 2 or status == 3;
      ]];

    return ret:format(trigger.threatUnit and trigger.threatUnit ~= "none" and "[["..trigger.threatUnit.."]]" or "nil");
    end,
    args = {
      {
        name = "threatUnit",
        display = L["Unit"],
        required = true,
        type = "select",
        values = "threat_unit_types",
        test = "true"
      },
      {
        name = "status",
        display = L["Status"],
        type = "select",
        values = "unit_threat_situation_types"
      },
      {
        name = "aggro",
        display = L["Aggro"],
        type = "tristate"
      },
      {
        hidden = true,
        test = "status ~= -1"
      },
    },
    automatic = true
  },
  ["Crowd Controlled"] = {
    type = "status",
    events = {
      "UNIT_AURA"
    },
    force_events = true,
    name = L["Crowd Controlled"],
    args = {
      {
        name = "controlled",
        display = L["Crowd Controlled"],
        type = "tristate",
        init = "not HasFullControl()"
      }
    },
    automaticrequired = true
  },
  ["Cast"] = {
    type = "status",
    events = {
      "UNIT_SPELLCAST_CHANNEL_START",
      "UNIT_SPELLCAST_CHANNEL_STOP",
      "UNIT_SPELLCAST_CHANNEL_UPDATE",
      "UNIT_SPELLCAST_START",
      "UNIT_SPELLCAST_STOP",
      "UNIT_SPELLCAST_DELAYED",
      "UNIT_SPELLCAST_INTERRUPTIBLE",
      "UNIT_SPELLCAST_NOT_INTERRUPTIBLE",
      "PLAYER_TARGET_CHANGED",
      "PLAYER_FOCUS_CHANGED"
    },
    force_events = true,
    name = L["Cast"],
    init = function(trigger)
      trigger.unit = trigger.unit or "";
      local ret = [=[
        local unit = [[%s]]
        local inverse = %s
        local spell, interruptible, _;
        local castType;
        spell, _, _, _, _, _, _, _, interruptible = UnitCastingInfo(unit)
        if(spell) then
          castType = "cast"
        else
          spell, _, _, _, _, _, _, interruptible = UnitChannelInfo(unit)
          if(spell) then
            castType = "channel"
          end
        end
        interruptible = not interruptible;
      ]=];
      return ret:format(trigger.unit, trigger.use_inverse and "true" or "false");
    end,
    args = {
      {
        name = "unit",
        display = L["Unit"],
        type = "unit",
        init = "arg",
        values = "actual_unit_types_with_specific",
        required = true
      },
      {
        name = "spell",
        display = L["Spell Name"],
        type = "string" ,
        enable = function(trigger) return not(trigger.use_inverse) end,
      },
      {
        name = "castType",
        display = L["Cast Type"],
        type = "select",
        values = "cast_types",
        enable = function(trigger) return not(trigger.use_inverse) end,
      },
      {
        name = "interruptible",
        display = L["Interruptible"],
        type = "tristate",
        enable = function(trigger) return not(trigger.use_inverse) end,
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        hidden = true,
        test = "UnitExists(unit) and ((not inverse and spell) or (inverse and not spell))"
      }
    },
    durationFunc = function(trigger)
      local _, _, _, _, startTime, endTime = UnitCastingInfo(trigger.unit);
      if not(startTime) then
        local _, _, _, _, startTime, endTime = UnitChannelInfo(trigger.unit);
        if not(startTime) then
          return 0, math.huge;
        else
          return (endTime - startTime)/1000, endTime/1000;
        end
      else
        return (endTime - startTime)/1000, endTime/1000, nil, true;
      end
    end,
    nameFunc = function(trigger)
      local name = UnitCastingInfo(trigger.unit);
      if not(name) then
        local name = UnitChannelInfo(trigger.unit);
        if not(name) then
          return trigger.spell or L["Spell Name"];
        else
          return name;
        end
      else
        return name;
      end
    end,
    iconFunc = function(trigger)
      local _, _, _, icon = UnitCastingInfo(trigger.unit);
      if not(icon) then
        local _, _, _, icon = UnitChannelInfo(trigger.unit);
        if not(icon) then
          return "Interface\\AddOns\\WeakAuras\\icon";
        else
          return icon;
        end
      else
        return icon;
      end
    end,
    automaticrequired = true,
    automaticAutoHide = false
  },
  ["Conditions"] = {
    type = "status",
    events = function(trigger, untrigger)
      local events = {};
      tinsert(events,  "CONDITIONS_CHECK");
      if (trigger.use_incombat ~= nil) then
        tinsert(events, "PLAYER_REGEN_ENABLED");
        tinsert(events, "PLAYER_REGEN_DISABLED");
      end
      if (trigger.use_pvpflagged ~= nil) then
        tinsert(events, "PLAYER_FLAGS_CHANGED");
      end

      if (trigger.use_alive ~= nil) then
        tinsert(events, "PLAYER_DEAD");
        tinsert(events, "PLAYER_ALIVE");
        tinsert(events, "PLAYER_UNGHOST");
      end

      if (trigger.use_vehicle ~= nil) then
        tinsert(events, "UNIT_ENTERED_VEHICLE");
        tinsert(events, "UNIT_EXITED_VEHICLE");
      end

      if (trigger.use_resting ~= nil) then
        tinsert(events, "PLAYER_UPDATE_RESTING");
      end

      if (trigger.use_mounted ~= nil) then
        tinsert(events, "MOUNTED_UPDATE");
      end

      if (trigger.use_HasPet ~= nil) then
        tinsert(events, "PET_UPDATE");
      end

      if (trigger.use_ismoving ~= nil) then
        tinsert(events, "PLAYER_MOVING_UPDATE");
      end

      return events;
    end,
    force_events = "CONDITIONS_CHECK",
    name = L["Conditions"],
    init = function(trigger)
      if(trigger.use_mounted ~= nil) then
        WeakAuras.WatchForMounts();
      end
      if (trigger.use_HasPet ~= nil) then
        WeakAuras.WatchForPetDeath();
      end
      if (trigger.use_ismoving ~= nil) then
        WeakAuras.WatchForPlayerMoving();
      end
      return "";
    end,
    args = {
      {
        name = "alwaystrue",
        display = L["Always active trigger"],
        type = "tristate",
        init = "true"
      },
      {
        name = "incombat",
        display = L["In Combat"],
        type = "tristate",
        init = "UnitAffectingCombat('player')"
      },
      {
        name = "pvpflagged",
        display = L["PvP Flagged"],
        type = "tristate",
        init = "UnitIsPVP('player')"
      },
      {
        name = "alive",
        display = L["Alive"],
        type = "tristate",
        init = "not UnitIsDeadOrGhost('player')"
      },
      {
        name = "vehicle",
        display = L["In Vehicle"],
        type = "tristate",
        init = "UnitInVehicle('player')"
      },
      {
        name = "resting",
        display = L["Resting"],
        type = "tristate",
        init = "IsResting()"
      },
      {
        name = "mounted",
        display = L["Mounted"],
        type = "tristate",
        init = "IsMounted()"
      },
      {
        name = "HasPet",
        display = L["HasPet"],
        type = "tristate",
        init = "UnitExists('pet') and not UnitIsDead('pet')"
      },
      {
        name = "ismoving",
        display = L["Is Moving"],
        type = "tristate",
        init = "IsPlayerMoving()"
      }
    },
    automaticrequired = true
  },
  ["Pet Behavior"] = {
    type = "status",
    events = {
      "PET_BAR_UPDATE",
      "UNIT_PET",
      "WA_DELAYED_PLAYER_ENTERING_WORLD"
    },
    force_events = true,
    name = L["Pet Behavior"],
    init = function(trigger)
      local ret = [[
          local inverse = %s
          local check_behavior = "%s"
          local name,_,_,_,active,_,_,exists
          local behavior
          local index = 1
          repeat
            name,_,_,_,active,_,_,exists = GetPetActionInfo(index);
            index = index + 1
            if(name == "PET_MODE_ASSIST" and active == true) then
              behavior = "assist"
            elseif(name == "PET_MODE_DEFENSIVE" and active == true) then
              behavior = "defensive"
            elseif(name == "PET_MODE_PASSIVE" and active == true) then
              behavior = "passive"
            end
          until index == 12
      ]]
      return ret:format(trigger.use_inverse and "true" or "false", trigger.behavior or "");
    end,
    args = {
      {
        name = "behavior",
        display = L["Pet Behavior"],
        required = true,
        type = "select",
        values = "pet_behavior_types",
        test = "true"
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        hidden = true,
        test = "UnitExists('pet') and ((inverse and check_behavior ~= behavior) or (not inverse and check_behavior == behavior))"
      }
    },
    automaticrequired = true
  }
};

WeakAuras.dynamic_texts = {
  ["%%p"] = {
    unescaped = "%p",
    name = L["Progress"],
    value = "progress",
    static = "8.0"
  },
  ["%%t"] = {
    unescaped = "%t",
    name = L["Total"],
    value = "duration",
    static = "12.0"
  },
  ["%%n"] = {
    unescaped = "%n",
    name = L["Name"],
    value = "name"
  },
  ["%%i"] = {
    unescaped = "%i",
    name = L["Icon"],
    value = "icon"
  },
  ["%%s"] = {
    unescaped = "%s",
    name = L["Stacks"],
    value = "stacks",
    static = 1
  },
  ["%%c"] = {
    unescaped = "%c",
    name = L["Custom"],
    value = "custom",
    static = L["Custom"]
  }
};

-- For All Indents And Purposes
local revision = 19
-- Maintainer: kristofer.karlsson@gmail.com

-- For All Indents And Purposes -
-- a indentation + syntax highlighting library
-- All valid lua code should be processed correctly.

-- Usage (for developers)
--------
-- Variant 1: - non embedded
-- 1) Add ForAllIndentsAndPurposes to your dependencies (or optional dependencies)

-- Variant 2: - embedded
-- 1.a) Copy indent.lua to your addon directory
-- 1.b) Put indent.lua first in your list of files in the TOC

-- For both variants:
-- 2) hook the editboxes that you want to have indentation like this:
-- IndentationLib.enable(editbox [, colorTable [, tabWidth] ])
-- if you don't select a color table, it will use the default.
-- Read through this code for further usage help.
-- (The documentation IS the code)

-- GLOBALS: IndentationLib

if not IndentationLib then
    IndentationLib = {}
end

if not IndentationLib.revision or revision > IndentationLib.revision then
    local lib = IndentationLib
    lib.revision = revision

    local stringlen = string.len
    local stringformat = string.format
    local stringfind = string.find
    local stringsub = string.sub
    local stringbyte = string.byte
    local stringchar = string.char
    local stringrep = string.rep
    local stringgsub = string.gsub

    local defaultTabWidth = 2
    local defaultColorTable

    local workingTable = {}
    local workingTable2 = {}
    local function tableclear(t)
        for k in next,t do
            t[k] = nil
        end
    end

    local function stringinsert(s, pos, insertStr)
        return stringsub(s, 1, pos) .. insertStr .. stringsub(s, pos + 1)
    end
    lib.stringinsert = stringinsert

    local function stringdelete(s, pos1, pos2)
        return stringsub(s, 1, pos1 - 1) .. stringsub(s, pos2 + 1)
    end
    lib.stringdelete = stringdelete

    -- token types
    local tokens = {}
    lib.tokens = tokens
    tokens.TOKEN_UNKNOWN = 0
    tokens.TOKEN_NUMBER = 1
    tokens.TOKEN_LINEBREAK = 2
    tokens.TOKEN_WHITESPACE = 3
    tokens.TOKEN_IDENTIFIER = 4
    tokens.TOKEN_ASSIGNMENT = 5
    tokens.TOKEN_EQUALITY = 6
    tokens.TOKEN_MINUS = 7
    tokens.TOKEN_COMMENT_SHORT = 8
    tokens.TOKEN_COMMENT_LONG = 9
    tokens.TOKEN_STRING = 10
    tokens.TOKEN_LEFTBRACKET = 11
    tokens.TOKEN_PERIOD = 12
    tokens.TOKEN_DOUBLEPERIOD = 13
    tokens.TOKEN_TRIPLEPERIOD = 14
    tokens.TOKEN_LTE = 15
    tokens.TOKEN_LT = 16
    tokens.TOKEN_GTE = 17
    tokens.TOKEN_GT = 18
    tokens.TOKEN_NOTEQUAL = 19
    tokens.TOKEN_COMMA = 20
    tokens.TOKEN_SEMICOLON = 21
    tokens.TOKEN_COLON = 22
    tokens.TOKEN_LEFTPAREN = 23
    tokens.TOKEN_RIGHTPAREN = 24
    tokens.TOKEN_PLUS = 25
    tokens.TOKEN_SLASH = 27
    tokens.TOKEN_LEFTWING = 28
    tokens.TOKEN_RIGHTWING = 29
    tokens.TOKEN_CIRCUMFLEX = 30
    tokens.TOKEN_ASTERISK = 31
    tokens.TOKEN_RIGHTBRACKET = 32
    tokens.TOKEN_KEYWORD = 33
    tokens.TOKEN_SPECIAL = 34
    tokens.TOKEN_VERTICAL = 35
    tokens.TOKEN_TILDE = 36
    -- WoW specific tokens
    tokens.TOKEN_COLORCODE_START = 37
    tokens.TOKEN_COLORCODE_STOP = 38
    -- new as of lua 5.1
    tokens.TOKEN_HASH = 39
    tokens.TOKEN_PERCENT = 40


    -- ascii codes
    local bytes = {}
    lib.bytes = bytes
    bytes.BYTE_LINEBREAK_UNIX = stringbyte("\n")
    bytes.BYTE_LINEBREAK_MAC = stringbyte("\r")
    bytes.BYTE_SINGLE_QUOTE = stringbyte("'")
    bytes.BYTE_DOUBLE_QUOTE = stringbyte('"')
    bytes.BYTE_0 = stringbyte("0")
    bytes.BYTE_9 = stringbyte("9")
    bytes.BYTE_PERIOD = stringbyte(".")
    bytes.BYTE_SPACE = stringbyte(" ")
    bytes.BYTE_TAB = stringbyte("\t")
    bytes.BYTE_E = stringbyte("E")
    bytes.BYTE_e = stringbyte("e")
    bytes.BYTE_MINUS = stringbyte("-")
    bytes.BYTE_EQUALS = stringbyte("=")
    bytes.BYTE_LEFTBRACKET = stringbyte("[")
    bytes.BYTE_RIGHTBRACKET = stringbyte("]")
    bytes.BYTE_BACKSLASH = stringbyte("\\")
    bytes.BYTE_COMMA = stringbyte(",")
    bytes.BYTE_SEMICOLON = stringbyte(";")
    bytes.BYTE_COLON = stringbyte(":")
    bytes.BYTE_LEFTPAREN = stringbyte("(")
    bytes.BYTE_RIGHTPAREN = stringbyte(")")
    bytes.BYTE_TILDE = stringbyte("~")
    bytes.BYTE_PLUS = stringbyte("+")
    bytes.BYTE_SLASH = stringbyte("/")
    bytes.BYTE_LEFTWING = stringbyte("{")
    bytes.BYTE_RIGHTWING = stringbyte("}")
    bytes.BYTE_CIRCUMFLEX = stringbyte("^")
    bytes.BYTE_ASTERISK = stringbyte("*")
    bytes.BYTE_LESSTHAN = stringbyte("<")
    bytes.BYTE_GREATERTHAN = stringbyte(">")
    -- WoW specific chars
    bytes.BYTE_VERTICAL = stringbyte("|")
    bytes.BYTE_r = stringbyte("r")
    bytes.BYTE_c = stringbyte("c")
    -- new as of lua 5.1
    bytes.BYTE_HASH = stringbyte("#")
    bytes.BYTE_PERCENT = stringbyte("%")


    local linebreakCharacters = {}
    lib.linebreakCharacters = linebreakCharacters
    linebreakCharacters[bytes.BYTE_LINEBREAK_UNIX] = 1
    linebreakCharacters[bytes.BYTE_LINEBREAK_MAC] = 1

    local whitespaceCharacters = {}
    lib.whitespaceCharacters = whitespaceCharacters
    whitespaceCharacters[bytes.BYTE_SPACE] = 1
    whitespaceCharacters[bytes.BYTE_TAB] = 1

    local specialCharacters = {}
    lib.specialCharacters = specialCharacters
    specialCharacters[bytes.BYTE_PERIOD] = -1
    specialCharacters[bytes.BYTE_LESSTHAN] = -1
    specialCharacters[bytes.BYTE_GREATERTHAN] = -1
    specialCharacters[bytes.BYTE_LEFTBRACKET] = -1
    specialCharacters[bytes.BYTE_EQUALS] = -1
    specialCharacters[bytes.BYTE_MINUS] = -1
    specialCharacters[bytes.BYTE_SINGLE_QUOTE] = -1
    specialCharacters[bytes.BYTE_DOUBLE_QUOTE] = -1
    specialCharacters[bytes.BYTE_TILDE] = -1
    specialCharacters[bytes.BYTE_RIGHTBRACKET] = tokens.TOKEN_RIGHTBRACKET
    specialCharacters[bytes.BYTE_COMMA] = tokens.TOKEN_COMMA
    specialCharacters[bytes.BYTE_COLON] = tokens.TOKEN_COLON
    specialCharacters[bytes.BYTE_SEMICOLON] = tokens.TOKEN_SEMICOLON
    specialCharacters[bytes.BYTE_LEFTPAREN] = tokens.TOKEN_LEFTPAREN
    specialCharacters[bytes.BYTE_RIGHTPAREN] = tokens.TOKEN_RIGHTPAREN
    specialCharacters[bytes.BYTE_PLUS] = tokens.TOKEN_PLUS
    specialCharacters[bytes.BYTE_SLASH] = tokens.TOKEN_SLASH
    specialCharacters[bytes.BYTE_LEFTWING] = tokens.TOKEN_LEFTWING
    specialCharacters[bytes.BYTE_RIGHTWING] = tokens.TOKEN_RIGHTWING
    specialCharacters[bytes.BYTE_CIRCUMFLEX] = tokens.TOKEN_CIRCUMFLEX
    specialCharacters[bytes.BYTE_ASTERISK] = tokens.TOKEN_ASTERISK
    -- WoW specific
    specialCharacters[bytes.BYTE_VERTICAL] = -1
    -- new as of lua 5.1
    specialCharacters[bytes.BYTE_HASH] = tokens.TOKEN_HASH
    specialCharacters[bytes.BYTE_PERCENT] = tokens.TOKEN_PERCENT

    local function nextNumberExponentPartInt(text, pos)
        while true do
            local byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_NUMBER, pos
            end

            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then
                pos = pos + 1
            else
                return tokens.TOKEN_NUMBER, pos
            end
        end
    end

    local function nextNumberExponentPart(text, pos)
        local byte = stringbyte(text, pos)
        if not byte then
            return tokens.TOKEN_NUMBER, pos
        end

        if byte == bytes.BYTE_MINUS then
            -- handle this case: a = 1.2e-- some comment
            -- i decide to let 1.2e be parsed as a a number
            byte = stringbyte(text, pos + 1)
            if byte == bytes.BYTE_MINUS then
                return tokens.TOKEN_NUMBER, pos
            end
            return nextNumberExponentPartInt(text, pos + 1)
        end

        return nextNumberExponentPartInt(text, pos)
    end

    local function nextNumberFractionPart(text, pos)
        while true do
            local byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_NUMBER, pos
            end

            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then
                pos = pos + 1
            elseif byte == bytes.BYTE_E or byte == bytes.BYTE_e then
                return nextNumberExponentPart(text, pos + 1)
            else
                return tokens.TOKEN_NUMBER, pos
            end
        end
    end

    local function nextNumberIntPart(text, pos)
        while true do
            local byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_NUMBER, pos
            end

            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then
                pos = pos + 1
            elseif byte == bytes.BYTE_PERIOD then
                return nextNumberFractionPart(text, pos + 1)
            elseif byte == bytes.BYTE_E or byte == bytes.BYTE_e then
                return nextNumberExponentPart(text, pos + 1)
            else
                return tokens.TOKEN_NUMBER, pos
            end
        end
    end

    local function nextIdentifier(text, pos)
        while true do
            local byte = stringbyte(text, pos)

            if not byte or
            linebreakCharacters[byte] or
            whitespaceCharacters[byte] or
            specialCharacters[byte] then
                return tokens.TOKEN_IDENTIFIER, pos
            end
            pos = pos + 1
        end
    end

    -- returns false or: true, nextPos, equalsCount
    local function isBracketStringNext(text, pos)
        local byte = stringbyte(text, pos)
        if byte == bytes.BYTE_LEFTBRACKET then
            local pos2 = pos + 1
            byte = stringbyte(text, pos2)
            while byte == bytes.BYTE_EQUALS do
                pos2 = pos2 + 1
                byte = stringbyte(text, pos2)
            end
            if byte == bytes.BYTE_LEFTBRACKET then
                return true, pos2 + 1, (pos2 - 1) - pos
            else
                return false
            end
        else
            return false
        end
    end

    -- Already parsed the [==[ part when get here
    local function nextBracketString(text, pos, equalsCount)
        local state = 0
        while true do
            local byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_STRING, pos
            end

            if byte == bytes.BYTE_RIGHTBRACKET then
                if state == 0 then
                    state = 1
                elseif state == equalsCount + 1 then
                    return tokens.TOKEN_STRING, pos + 1
                else
                    state = 0
                end
            elseif byte == bytes.BYTE_EQUALS then
                if state > 0 then
                    state = state + 1
                end
            else
                state = 0
            end
            pos = pos + 1
        end
    end

    local function nextComment(text, pos)
        -- When we get here we have already parsed the "--"
        -- Check for long comment
        local isBracketString, nextPos, equalsCount = isBracketStringNext(text, pos)
        if isBracketString then
            local tokenType, nextPos2 = nextBracketString(text, nextPos, equalsCount)
            return tokens.TOKEN_COMMENT_LONG, nextPos2
        end

        local byte = stringbyte(text, pos)

        -- Short comment, find the first linebreak
        while true do
            byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_COMMENT_SHORT, pos
            end
            if linebreakCharacters[byte] then
                return tokens.TOKEN_COMMENT_SHORT, pos
            end
            pos = pos + 1
        end
    end

    local function nextString(text, pos, character)
        local even = true
        while true do
            local byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_STRING, pos
            end

            if byte == character then
                if even then
                    return tokens.TOKEN_STRING, pos + 1
                end
            end
            if byte == bytes.BYTE_BACKSLASH then
                even = not even
            else
                even = true
            end

            pos = pos + 1
        end
    end

    -- INPUT
    -- 1: text: text to search in
    -- 2: tokenPos:  where to start searching
    -- OUTPUT
    -- 1: token type
    -- 2: position after the last character of the token
    local function nextToken(text, pos)
        local byte = stringbyte(text, pos)
        if not byte then
            return nil
        end

        if linebreakCharacters[byte] then
            return tokens.TOKEN_LINEBREAK, pos + 1
        end

        if whitespaceCharacters[byte] then
            while true do
                pos = pos + 1
                byte = stringbyte(text, pos)
                if not byte or not whitespaceCharacters[byte] then
                    return tokens.TOKEN_WHITESPACE, pos
                end
            end
        end

        local token = specialCharacters[byte]
        if token then
            if token ~= -1 then
                return token, pos + 1
            end

            -- WoW specific (for color codes)
            if byte == bytes.BYTE_VERTICAL then
                byte = stringbyte(text, pos + 1)
                if byte == bytes.BYTE_VERTICAL then
                    return tokens.TOKEN_VERTICAL, pos + 2
                end
                if byte == bytes.BYTE_c then
                    return tokens.TOKEN_COLORCODE_START, pos + 10
                end
                if byte == bytes.BYTE_r then
                    return tokens.TOKEN_COLORCODE_STOP, pos + 2
                end
                return tokens.TOKEN_UNKNOWN, pos + 1
            end

            if byte == bytes.BYTE_MINUS then
                byte = stringbyte(text, pos + 1)
                if byte == bytes.BYTE_MINUS then
                    return nextComment(text, pos + 2)
                end
                return tokens.TOKEN_MINUS, pos + 1
            end

            if byte == bytes.BYTE_SINGLE_QUOTE then
                return nextString(text, pos + 1, bytes.BYTE_SINGLE_QUOTE)
            end

            if byte == bytes.BYTE_DOUBLE_QUOTE then
                return nextString(text, pos + 1, bytes.BYTE_DOUBLE_QUOTE)
            end

            if byte == bytes.BYTE_LEFTBRACKET then
                local isBracketString, nextPos, equalsCount = isBracketStringNext(text, pos)
                if isBracketString then
                    return nextBracketString(text, nextPos, equalsCount)
                else
                    return tokens.TOKEN_LEFTBRACKET, pos + 1
                end
            end

            if byte == bytes.BYTE_EQUALS then
                byte = stringbyte(text, pos + 1)
                if not byte then
                    return tokens.TOKEN_ASSIGNMENT, pos + 1
                end
                if byte == bytes.BYTE_EQUALS then
                    return tokens.TOKEN_EQUALITY, pos + 2
                end
                return tokens.TOKEN_ASSIGNMENT, pos + 1
            end

            if byte == bytes.BYTE_PERIOD then
                byte = stringbyte(text, pos + 1)
                if not byte then
                    return tokens.TOKEN_PERIOD, pos + 1
                end
                if byte == bytes.BYTE_PERIOD then
                    byte = stringbyte(text, pos + 2)
                    if byte == bytes.BYTE_PERIOD then
                        return tokens.TOKEN_TRIPLEPERIOD, pos + 3
                    end
                    return tokens.TOKEN_DOUBLEPERIOD, pos + 2
                elseif byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then
                    return nextNumberFractionPart(text, pos + 2)
                end
                return tokens.TOKEN_PERIOD, pos + 1
            end

            if byte == bytes.BYTE_LESSTHAN then
                byte = stringbyte(text, pos + 1)
                if byte == bytes.BYTE_EQUALS then
                    return tokens.TOKEN_LTE, pos + 2
                end
                return tokens.TOKEN_LT, pos + 1
            end

            if byte == bytes.BYTE_GREATERTHAN then
                byte = stringbyte(text, pos + 1)
                if byte == bytes.BYTE_EQUALS then
                    return tokens.TOKEN_GTE, pos + 2
                end
                return tokens.TOKEN_GT, pos + 1
            end

            if byte == bytes.BYTE_TILDE then
                byte = stringbyte(text, pos + 1)
                if byte == bytes.BYTE_EQUALS then
                    return tokens.TOKEN_NOTEQUAL, pos + 2
                end
                return tokens.TOKEN_TILDE, pos + 1
            end

            return tokens.TOKEN_UNKNOWN, pos + 1
        elseif byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then
            return nextNumberIntPart(text, pos + 1)
        else
            return nextIdentifier(text, pos + 1)
        end
    end

    -- Cool stuff begins here! (indentation and highlighting)

    local noIndentEffect = {0, 0}
    local indentLeft = {-1, 0}
    local indentRight = {0, 1}
    local indentBoth = {-1, 1}

    local keywords = {}
    lib.keywords = keywords
    keywords["and"] = noIndentEffect
    keywords["break"] = noIndentEffect
    keywords["false"] = noIndentEffect
    keywords["for"] = noIndentEffect
    keywords["if"] = noIndentEffect
    keywords["in"] = noIndentEffect
    keywords["local"] = noIndentEffect
    keywords["nil"] = noIndentEffect
    keywords["not"] = noIndentEffect
    keywords["or"] = noIndentEffect
    keywords["return"] = noIndentEffect
    keywords["true"] = noIndentEffect
    keywords["while"] = noIndentEffect

    keywords["until"] = indentLeft
    keywords["elseif"] = indentLeft
    keywords["end"] = indentLeft

    keywords["do"] = indentRight
    keywords["then"] = indentRight
    keywords["repeat"] = indentRight
    keywords["function"] = indentRight

    keywords["else"] = indentBoth

    local tokenIndentation = {}
    lib.tokenIndentation = tokenIndentation
    tokenIndentation[tokens.TOKEN_LEFTPAREN] = indentRight
    tokenIndentation[tokens.TOKEN_LEFTBRACKET] = indentRight
    tokenIndentation[tokens.TOKEN_LEFTWING] = indentRight

    tokenIndentation[tokens.TOKEN_RIGHTPAREN] = indentLeft
    tokenIndentation[tokens.TOKEN_RIGHTBRACKET] = indentLeft
    tokenIndentation[tokens.TOKEN_RIGHTWING] = indentLeft

    local function fillWithTabs(n)
        return stringrep("\t", n)
    end

    local function fillWithSpaces(a, b)
        return stringrep(" ", a*b)
    end

    function lib.colorCodeCode(code, colorTable, caretPosition)
        local stopColor = colorTable and colorTable[0]
        if not stopColor then
            return code, caretPosition
        end

        local stopColorLen = stringlen(stopColor)

        tableclear(workingTable)
        local tsize = 0
        local totalLen = 0

        local numLines = 0
        local newCaretPosition
        local prevTokenWasColored = false
        local prevTokenWidth = 0

        local pos = 1
        local level = 0

        while true do
            if caretPosition and not newCaretPosition and pos >= caretPosition then
                if pos == caretPosition then
                    newCaretPosition = totalLen
                else
                    newCaretPosition = totalLen
                    local diff = pos - caretPosition
                    if diff > prevTokenWidth then
                        diff = prevTokenWidth
                    end
                    if prevTokenWasColored then
                        diff = diff + stopColorLen
                    end
                    newCaretPosition = newCaretPosition - diff
                end
            end

            prevTokenWasColored = false
            prevTokenWidth = 0

            local tokenType, nextPos = nextToken(code, pos)

            if not tokenType then
                break
            end

            if tokenType == tokens.TOKEN_COLORCODE_START or tokenType == tokens.TOKEN_COLORCODE_STOP or tokenType == tokens.TOKEN_UNKNOWN then
                -- ignore color codes
            elseif tokenType == tokens.TOKEN_LINEBREAK or tokenType == tokens.TOKEN_WHITESPACE then
                if tokenType == tokens.TOKEN_LINEBREAK then
                    numLines = numLines + 1
                end
                local str = stringsub(code, pos, nextPos - 1)
                prevTokenWidth = nextPos - pos

                tsize = tsize + 1
                workingTable[tsize] = str
                totalLen = totalLen + stringlen(str)
            else
                local str = stringsub(code, pos, nextPos - 1)

                prevTokenWidth = nextPos - pos

                -- Add coloring
                if keywords[str] then
                    tokenType = tokens.TOKEN_KEYWORD
                end

                local color
                if stopColor then
                    color = colorTable[str]
                    if not color then
                        color = colorTable[tokenType]
                        if not color then
                            if tokenType == tokens.TOKEN_IDENTIFIER then
                                color = colorTable[tokens.TOKEN_IDENTIFIER]
                            else
                                color = colorTable[tokens.TOKEN_SPECIAL]
                            end
                        end
                    end
                end

                if color then
                    tsize = tsize + 1
                    workingTable[tsize] = color
                    tsize = tsize + 1
                    workingTable[tsize] = str
                    tsize = tsize + 1
                    workingTable[tsize] = stopColor

                    totalLen = totalLen + stringlen(color) + (nextPos - pos) + stopColorLen
                    prevTokenWasColored = true
                else
                    tsize = tsize + 1
                    workingTable[tsize] = str

                    totalLen = totalLen + stringlen(str)
                end
            end

            pos = nextPos
        end
        return table.concat(workingTable), newCaretPosition, numLines
    end

    function lib.indentCode(code, tabWidth, colorTable, caretPosition)
        local fillFunction
        if tabWidth == nil then
            tabWidth = defaultTabWidth
        end
        if tabWidth then
            fillFunction = fillWithSpaces
        else
            fillFunction = fillWithTabs
        end

        tableclear(workingTable)
        local tsize = 0
        local totalLen = 0

        tableclear(workingTable2)
        local tsize2 = 0
        local totalLen2 = 0

        local stopColor = colorTable and colorTable[0]
        local stopColorLen = not stopColor or stringlen(stopColor)

        local newCaretPosition
        local newCaretPositionFinalized = false
        local prevTokenWasColored = false
        local prevTokenWidth = 0

        local pos = 1
        local level = 0

        local hitNonWhitespace = false
        local hitIndentRight = false
        local preIndent = 0
        local postIndent = 0
        while true do
            if caretPosition and not newCaretPosition and pos >= caretPosition then
                if pos == caretPosition then
                    newCaretPosition = totalLen + totalLen2
                else
                    newCaretPosition = totalLen + totalLen2
                    local diff = pos - caretPosition
                    if diff > prevTokenWidth then
                        diff = prevTokenWidth
                    end
                    if prevTokenWasColored then
                        diff = diff + stopColorLen
                    end
                    newCaretPosition = newCaretPosition - diff
                end
            end

            prevTokenWasColored = false
            prevTokenWidth = 0

            local tokenType, nextPos = nextToken(code, pos)

            if not tokenType or tokenType == tokens.TOKEN_LINEBREAK then
                level = level + preIndent
                if level < 0 then level = 0 end

                local s = fillFunction(level, tabWidth)

                tsize = tsize + 1
                workingTable[tsize] = s
                totalLen = totalLen + stringlen(s)

                if newCaretPosition and not newCaretPositionFinalized then
                    newCaretPosition = newCaretPosition + stringlen(s)
                    newCaretPositionFinalized = true
                end

                for k, v in next,workingTable2 do
                    tsize = tsize + 1
                    workingTable[tsize] = v
                    totalLen = totalLen + stringlen(v)
                end

                if not tokenType then
                    break
                end

                tsize = tsize + 1
                workingTable[tsize] = stringsub(code, pos, nextPos - 1)
                totalLen = totalLen + nextPos - pos

                level = level + postIndent
                if level < 0 then level = 0 end

                tableclear(workingTable2)
                tsize2 = 0
                totalLen2 = 0

                hitNonWhitespace = false
                hitIndentRight = false
                preIndent = 0
                postIndent = 0
            elseif tokenType == tokens.TOKEN_WHITESPACE then
                if hitNonWhitespace then
                    prevTokenWidth = nextPos - pos
                    tsize2 = tsize2 + 1
                    local s = stringsub(code, pos, nextPos - 1)
                    workingTable2[tsize2] = s
                    totalLen2 = totalLen2 + stringlen(s)
                end
            elseif tokenType == tokens.TOKEN_COLORCODE_START or tokenType == tokens.TOKEN_COLORCODE_STOP or tokenType == tokens.TOKEN_UNKNOWN then
                -- skip these, though they shouldn't be encountered here anyway
            else
                hitNonWhitespace = true
                local str = stringsub(code, pos, nextPos - 1)
                prevTokenWidth = nextPos - pos

                -- See if this is an indent-modifier
                local indentTable
                if tokenType == tokens.TOKEN_IDENTIFIER then
                    indentTable = keywords[str]
                else
                    indentTable = lib.tokenIndentation[tokenType]
                end

                if indentTable then
                    if hitIndentRight then
                        postIndent = postIndent + indentTable[1] + indentTable[2]
                    else
                        local pre = indentTable[1]
                        local post = indentTable[2]
                        if post > 0 then
                            hitIndentRight = true
                        end
                        preIndent = preIndent + pre
                        postIndent = postIndent + post
                    end
                end

                -- Add coloring
                if keywords[str] then
                    tokenType = tokens.TOKEN_KEYWORD
                end

                local color
                if stopColor then
                    color = colorTable[str]
                    if not color then
                        color = colorTable[tokenType]
                        if not color then
                            if tokenType == tokens.TOKEN_IDENTIFIER then
                                color = colorTable[tokens.TOKEN_IDENTIFIER]
                            else
                                color = colorTable[tokens.TOKEN_SPECIAL]
                            end
                        end
                    end
                end

                if color then
                    tsize2 = tsize2 + 1
                    workingTable2[tsize2] = color
                    totalLen2 = totalLen2 + stringlen(color)

                    tsize2 = tsize2 + 1
                    workingTable2[tsize2] = str
                    totalLen2 = totalLen2 + nextPos - pos

                    tsize2 = tsize2 + 1
                    workingTable2[tsize2] = stopColor
                    totalLen2 = totalLen2 + stopColorLen

                    prevTokenWasColored = true
                else
                    tsize2 = tsize2 + 1
                    workingTable2[tsize2] = str
                    totalLen2 = totalLen2 + nextPos - pos

                end
            end
            pos = nextPos
        end
        return table.concat(workingTable), newCaretPosition
    end

    -- WoW specific code:
    local GetTime = GetTime

    local editboxSetText
    local editboxGetText

    -- Caret code (thanks Tem!)
    local function critical_enter(editbox)
        local script = editbox:GetScript("OnTextSet")
        if script then
            editbox:SetScript("OnTextSet", nil)
        end
        return script
    end

    local function critical_leave(editbox, script)
        if script then
            editbox:SetScript("OnTextSet", script)
        end
    end

    local function setCaretPos_main(editbox, pos)
        local text = editboxGetText(editbox)

        if stringlen(text) > 0 then
            editboxSetText(editbox, stringinsert(text, pos, "a"))
            editbox:HighlightText(pos, pos + 1)
            editbox:Insert("\0")
        end
    end

    local function getCaretPos(editbox)
        local script = critical_enter(editbox)

        local text = editboxGetText(editbox)
        editbox:Insert("\1")
        local pos = stringfind(editboxGetText(editbox), "\1", 1, 1)
        editboxSetText(editbox, text)

        if pos then
            setCaretPos_main(editbox, pos - 1)
        end
        critical_leave(editbox, script)

        return (pos or 0) - 1
    end

    local function setCaretPos(editbox, pos)
        local script, script2 = critical_enter(editbox)
        setCaretPos_main(editbox, pos)
        critical_leave(editbox, script, script2)
    end
    -- end of caret code

    function lib.stripWowColors(code)

        -- HACK!
        -- This is a fix for a bug, where an unfinished string causes a lot of newlines to be created.
        -- The reason for the bug, is that a |r\n\n gets converted to \n\n|r after the next indent-run
        -- The fix is to remove those last two linebreaks when stripping
        code = stringgsub(code, "|r\n\n$", "|r")

        tableclear(workingTable)
        local tsize = 0

        local pos = 1

        local prevVertical = false
        local even = true
        local selectionStart = 1

        while true do
            local byte = stringbyte(code, pos)
            if not byte then
                break
            end
            if byte == bytes.BYTE_VERTICAL then
                even = not even
                prevVertical = true
            else
                if prevVertical and not even then
                    if byte == bytes.BYTE_c then

                        if pos - 2 >= selectionStart then
                            tsize = tsize + 1
                            workingTable[tsize] = stringsub(code, selectionStart, pos - 2)
                        end

                        pos = pos + 8
                        selectionStart = pos + 1
                    elseif byte == bytes.BYTE_r then

                        if pos - 2 >= selectionStart then
                            tsize = tsize + 1
                            workingTable[tsize] = stringsub(code, selectionStart, pos - 2)
                        end
                        selectionStart = pos + 1
                    end
                end
                prevVertical = false
                even = true
            end
            pos = pos + 1
        end
        if pos >= selectionStart then
            tsize = tsize + 1
            workingTable[tsize] = stringsub(code, selectionStart, pos - 1)
        end
        return table.concat(workingTable)
    end

    function lib.decode(code)
        if code then
            code = lib.stripWowColors(code)
            code = stringgsub(code, "||", "|")
        end
        return code or ""
    end

    function lib.encode(code)
        if code then
            code = stringgsub(code, "|", "||")
        end
        return code or ""
    end

    function lib.stripWowColorsWithPos(code, pos)
        code = stringinsert(code, pos, "\2")
        code = lib.stripWowColors(code)
        pos = stringfind(code, "\2", 1, 1)
        code = stringdelete(code, pos, pos)
        return code, pos
    end

    -- returns the padded code, and true if modified, false if unmodified
    local linebreak = stringbyte("\n")
    function lib.padWithLinebreaks(code)
        local len = stringlen(code)
        if stringbyte(code, len) == linebreak then
            if stringbyte(code, len - 1) == linebreak then
                return code, false
            end
            return code .. "\n", true
        end
        return code .. "\n\n", true

    end

    -- Data tables
    -- No weak table magic, since editboxes can never be removed in WoW
    local enabled = {}
    local dirty = {}

    local editboxIndentCache = {}
    local decodeCache = {}
    local editboxStringCache = {}
    local editboxNumLinesCache = {}

    function lib.colorCodeEditbox(editbox)
        dirty[editbox] = nil

        local colorTable = editbox.faiap_colorTable or defaultColorTable
        local tabWidth = editbox.faiap_tabWidth

        local orgCode = editboxGetText(editbox)
        local prevCode = editboxStringCache[editbox]
        if prevCode == orgCode then
            return
        end

        local pos = getCaretPos(editbox)

        local code
        code, pos = lib.stripWowColorsWithPos(orgCode, pos)

        colorTable[0] = "|r"

        local newCode, newPos, numLines = lib.colorCodeCode(code, colorTable, pos)
        newCode = lib.padWithLinebreaks(newCode)

        editboxStringCache[editbox] = newCode
        if orgCode ~= newCode then
            local script, script2 = critical_enter(editbox)
            decodeCache[editbox] = nil
            local stringlenNewCode = stringlen(newCode)

            editboxSetText(editbox, newCode)
            if newPos then
                if newPos < 0 then newPos = 0 end
                if newPos > stringlenNewCode then newPos = stringlenNewCode end

                setCaretPos(editbox, newPos)
            end
            critical_leave(editbox, script, script2)
        end

        if editboxNumLinesCache[editbox] ~= numLines then
            lib.indentEditbox(editbox)
        end
        editboxNumLinesCache[editbox] = numLines
    end

    function lib.indentEditbox(editbox)
        dirty[editbox] = nil

        local colorTable = editbox.faiap_colorTable or defaultColorTable
        local tabWidth = editbox.faiap_tabWidth

        local orgCode = editboxGetText(editbox)
        local prevCode = editboxIndentCache[editbox]
        if prevCode == orgCode then
            return
        end

        local pos = getCaretPos(editbox)

        local code
        code, pos = lib.stripWowColorsWithPos(orgCode, pos)

        colorTable[0] = "|r"
        local newCode, newPos = lib.indentCode(code, tabWidth, colorTable, pos)
        newCode = lib.padWithLinebreaks(newCode)
        editboxIndentCache[editbox] = newCode
        if code ~= newCode then
            local script, script2 = critical_enter(editbox)
            decodeCache[editbox] = nil

            local stringlenNewCode = stringlen(newCode)

            editboxSetText(editbox, newCode)

            if newPos then
                if newPos < 0 then newPos = 0 end
                if newPos > stringlenNewCode then newPos = stringlenNewCode end

                setCaretPos(editbox, newPos)
            end
            critical_leave(editbox, script, script2)
        end
    end

    local function hookHandler(editbox, handler, newFun)
        local oldFun = editbox:GetScript(handler)
        if oldFun == newFun then
            -- already hooked, ignore it
            return
        end
        editbox["faiap_old_" .. handler] = oldFun
        editbox:SetScript(handler, newFun)
    end

    local function textChangedHook(editbox, ...)
        local oldFun = editbox["faiap_old_OnTextChanged"]
        if oldFun then
            oldFun(editbox, ...)
        end
        if enabled[editbox] then
            dirty[editbox] = GetTime()
        end
    end

    local function tabPressedHook(editbox, ...)
        local oldFun = editbox["faiap_old_OnTabPressed"]
        if oldFun then
            oldFun(editbox, ...)
        end
        if enabled[editbox] then
            return lib.indentEditbox(editbox)
        end
    end

    local function onUpdateHook(editbox, ...)
        local oldFun = editbox["faiap_old_OnUpdate"]
        if oldFun then
            oldFun(editbox, ...)
        end
        if enabled[editbox] then
            local now = GetTime()
            local lastUpdate = dirty[editbox] or now
            if now - lastUpdate > 0.2 then
                decodeCache[editbox] = nil
                return lib.colorCodeEditbox(editbox)
            end
        end
    end

    local function newGetText(editbox)
        local decoded = decodeCache[editbox]
        if not decoded then
            decoded = lib.decode(editboxGetText(editbox))
            decodeCache[editbox] = decoded
        end
        return decoded or ""
    end

    local function newSetText(editbox, text)
        decodeCache[editbox] = nil
        if text then
            local encoded = lib.encode(text)

            return editboxSetText(editbox, encoded)
        end
    end

    function lib.enable(editbox, colorTable, tabWidth)
        if not editboxSetText then
            editboxSetText = editbox.SetText
            editboxGetText = editbox.GetText
        end

        local modified
        if editbox.faiap_colorTable ~= colorTable then
            editbox.faiap_colorTable = colorTable
            modified = true
        end
        if editbox.faiap_tabWidth ~= tabWidth then
            editbox.faiap_tabWidth = tabWidth
            modified = true
        end

        if enabled[editbox] then
            if modified then
                lib.indentEditbox(editbox)
            end
            return
        end

        -- Editbox is possibly hooked, but disabled
        enabled[editbox] = true

        editbox.oldMaxBytes = editbox:GetMaxBytes()
        editbox.oldMaxLetters = editbox:GetMaxLetters()
        editbox:SetMaxBytes(0)
        editbox:SetMaxLetters(0)

        editbox.GetText = newGetText
        editbox.SetText = newSetText

        hookHandler(editbox, "OnTextChanged", textChangedHook)
        hookHandler(editbox, "OnTabPressed", tabPressedHook)
        hookHandler(editbox, "OnUpdate", onUpdateHook)

        lib.indentEditbox(editbox)
    end

    -- Deprecated function
    lib.addSmartCode = lib.enable

    function lib.disable(editbox)
        if not enabled[editbox] then
            return
        end
        enabled[editbox] = nil

        -- revert settings for max bytes / letters
        editbox:SetMaxBytes(editbox.oldMaxBytes)
        editbox:SetMaxLetters(editbox.oldMaxLetters)

        -- try a real unhooking, if possible
        if editbox:GetScript("OnTextChanged") == textChangedHook then
            editbox:SetScript("OnTextChanged", editbox.faiap_old_OnTextChanged)
            editbox.faiap_old_OnTextChanged = nil
        end

        if editbox:GetScript("OnTabPressed") == tabPressedHook then
            editbox:SetScript("OnTabPressed", editbox.faiap_old_OnTabPressed)
            editbox.faiap_old_OnTabPressed = nil
        end

        if editbox:GetScript("OnUpdate") == onUpdateHook then
            editbox:SetScript("OnUpdate", editbox.faiap_old_OnUpdate)
            editbox.faiap_old_OnUpdate = nil
        end

        editbox.GetText = nil
        editbox.SetText = nil

        -- change the text back to unformatted
        editbox:SetText(newGetText(editbox))

        -- clear caches
        editboxIndentCache[editbox] = nil
        decodeCache[editbox] = nil
        editboxStringCache[editbox] = nil
        editboxNumLinesCache[editbox] = nil
    end

    defaultColorTable = {}
    lib.defaultColorTable = defaultColorTable
    defaultColorTable[tokens.TOKEN_SPECIAL] = "|c00ff99ff"
    defaultColorTable[tokens.TOKEN_KEYWORD] = "|c006666ff"
    defaultColorTable[tokens.TOKEN_COMMENT_SHORT] = "|c00999999"
    defaultColorTable[tokens.TOKEN_COMMENT_LONG] = "|c00999999"

    local stringColor = "|c00ffff77"
    defaultColorTable[tokens.TOKEN_STRING] = stringColor
    defaultColorTable[".."] = stringColor

    local tableColor = "|c00ff9900"
    defaultColorTable["..."] = tableColor
    defaultColorTable["{"] = tableColor
    defaultColorTable["}"] = tableColor
    defaultColorTable["["] = tableColor
    defaultColorTable["]"] = tableColor

    local arithmeticColor = "|c0033ff55"
    defaultColorTable[tokens.TOKEN_NUMBER] = arithmeticColor
    defaultColorTable["+"] = arithmeticColor
    defaultColorTable["-"] = arithmeticColor
    defaultColorTable["/"] = arithmeticColor
    defaultColorTable["*"] = arithmeticColor

    local logicColor1 = "|c0055ff88"
    defaultColorTable["=="] = logicColor1
    defaultColorTable["<"] = logicColor1
    defaultColorTable["<="] = logicColor1
    defaultColorTable[">"] = logicColor1
    defaultColorTable[">="] = logicColor1
    defaultColorTable["~="] = logicColor1

    local logicColor2 = "|c0088ffbb"
    defaultColorTable["and"] = logicColor2
    defaultColorTable["or"] = logicColor2
    defaultColorTable["not"] = logicColor2

    defaultColorTable[0] = "|r"

end

-- just for testing
--[[
function testTokenizer()
  local str = ""
  for line in io.lines("indent.lua") do
   str = str .. line .. "\n"
  end

  local pos = 1

  while true do
   local tokenType, nextPos = nextToken(str, pos)

   if not tokenType then
  break
   end

   if true or tokenType ~= tokens.TOKEN_WHITESPACE and tokenType ~= tokens.TOKEN_LINEBREAK then
  print(stringformat("Found token %d (%d-%d): (%s)", tokenType, pos, nextPos - 1, stringsub(str, pos, nextPos - 1)))
   end

   if tokenType == tokens.TOKEN_UNKNOWN then
  print("unknown token!")
  break
   end

   pos = nextPos
  end
end


function testIndenter(i)
  local lib = IndentationLib
  local str = ""
  for line in io.lines("test.lua") do
   str = str .. line .. "\n"
  end

  local colorTable = lib.defaultColorTable
  print(lib.indentCode(str, 4, colorTable, i))
end


testIndenter()

--]]

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

-- GLOBALS: WeakAuras UIParent AceGUIWidgetLSMlists

-- Create region options table
local function createOptions(id, data)
	-- Region options
    local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20;
    local options = {
        texture = {
            type = "select",
            dialogControl = "LSM30_Statusbar",
            order = 0,
            width = "double",
            name = L["Bar Texture"],
            values = AceGUIWidgetLSMlists.statusbar
        },
        displayTextLeft = {
            type = "input",
            name = function()
                if(data.orientation == "HORIZONTAL") then
                    return L["Left Text"];
                elseif(data.orientation == "HORIZONTAL_INVERSE") then
                    return L["Right Text"];
                elseif(data.orientation == "VERTICAL") then
                    return L["Bottom Text"];
                else
                    return L["Top Text"];
                end
            end,
            desc = function()
                 local ret = L["Dynamic text tooltip"];
                 ret = ret .. WeakAuras.GetAdditionalProperties(data);
                 return ret
            end,
            order = 9
        },
        displayTextRight = {
            type = "input",
            name = function()
                if(data.orientation == "HORIZONTAL") then
                    return L["Right Text"];
                elseif(data.orientation == "HORIZONTAL_INVERSE") then
                    return L["Left Text"];
                elseif(data.orientation == "VERTICAL") then
                    return L["Top Text"];
                else
                    return L["Bottom Text"];
                end
            end,
            desc = function()
                 local ret = L["Dynamic text tooltip"];
                 ret = ret .. WeakAuras.GetAdditionalProperties(data);
                 return ret
            end,
            order = 10
        },
        customTextUpdate = {
            type = "select",
            width = "double",
            hidden = function()
                return not (
                    data.displayTextLeft:find("%%c")
                    or data.displayTextRight:find("%%c")
                );
            end,
            name = L["Update Custom Text On..."],
            values = WeakAuras.text_check_types,
            order = 10.1
        },
        customText = {
            type = "input",
            width = "normal",
            hidden = function()
                return not (
                    data.displayTextLeft:find("%%c")
                    or data.displayTextRight:find("%%c")
                );
            end,
            multiline = true,
            name = L["Custom Function"],
            order = 10.2
        },
        customText_expand = {
            type = "execute",
            order = 10.3,
            name = L["Expand Text Editor"],
            func = function()
                WeakAuras.OpenTextEditor(data, {"customText"})
            end,
            hidden = function()
                return not (
                    data.displayTextLeft:find("%%c")
                    or data.displayTextRight:find("%%c")
                );
            end
        },
        progressPrecision = {
            type = "select",
            order = 11,
            name = L["Remaining Time Precision"],
            values = WeakAuras.precision_types,
            get = function() return data.progressPrecision or 1 end,
            hidden = function()
                return not (
                    data.displayTextLeft:find("%%p")
                    or data.displayTextLeft:find("%%t")
                    or data.displayTextRight:find("%%p")
                    or data.displayTextRight:find("%%t")
                );
            end,
            disabled = function()
                return not (
                    data.displayTextLeft:find("%%p")
                    or data.displayTextRight:find("%%p")
                );
            end,
        },
        totalPrecision = {
            type = "select",
            order = 11.5,
            name = L["Total Time Precision"],
            values = WeakAuras.precision_types,
            get = function() return data.totalPrecision or 1 end,
            hidden = function()
                return not (
                    data.displayTextLeft:find("%%p")
                    or data.displayTextLeft:find("%%t")
                    or data.displayTextRight:find("%%p")
                    or data.displayTextRight:find("%%t")
                );
            end,
            disabled = function()
                return not (
                    data.displayTextLeft:find("%%t")
                    or data.displayTextRight:find("%%t")
                );
            end,
        },
        rotateText = {
            type = "select",
            name = L["Rotate Text"],
            values = WeakAuras.text_rotate_types,
            order = 19.5
        },
        orientation = {
            type = "select",
            name = L["Orientation"],
            order = 25,
            values = WeakAuras.orientation_types,
            set = function(info, v)
                if(
                    (
                        data.orientation:find("INVERSE")
                        and not v:find("INVERSE")
                    )
                    or (
                        v:find("INVERSE")
                        and not data.orientation:find("INVERSE")
                    )
                ) then
                    data.icon_side = data.icon_side == "LEFT" and "RIGHT" or "LEFT";
                end

                if(
                    (
                        data.orientation:find("HORIZONTAL")
                        and v:find("VERTICAL")
                    )
                    or (
                        data.orientation:find("VERTICAL")
                        and v:find("HORIZONTAL")
                    )
                ) then
                    local temp = data.width;
                    data.width = data.height;
                    data.height = temp;
                    data.icon_side = data.icon_side == "LEFT" and "RIGHT" or "LEFT";

                    if(data.rotateText == "LEFT" or data.rotateText == "RIGHT") then
                        data.rotateText = "NONE";
                    elseif(data.rotateText == "NONE") then
                        data.rotateText = "LEFT"
                    end
                end

                data.orientation = v;
                WeakAuras.Add(data);
                WeakAuras.SetThumbnail(data);
                WeakAuras.SetIconNames(data);
                WeakAuras.ResetMoverSizer();
            end
        },
        inverse = {
            type = "toggle",
            name = L["Inverse"],
            order = 35
        },
        stickyDuration = {
            type = "toggle",
            name = L["Sticky Duration"],
            desc = L["Prevents duration information from decreasing when an aura refreshes. May cause problems if used with multiple auras with different durations."],
            order = 36
        },
        useTooltip = {
            type = "toggle",
            name = L["Tooltip on Mouseover"],
            hidden = function() return not WeakAuras.CanHaveTooltip(data) end,
            order = 37
        },
        symbol_header = {
            type = "header",
            name = L["Symbol Settings"],
            order = 38
        },
        icon = {
            type = "toggle",
            name = L["Icon"],
            order = 38.1
        },
        auto = {
            type = "toggle",
            name = L["Auto"],
            desc = L["Choose whether the displayed icon is automatic or defined manually"],
            order = 38.2,
            disabled = function() return not WeakAuras.CanHaveAuto(data); end,
            get = function() return WeakAuras.CanHaveAuto(data) and data.auto end,
            hidden = function() return not data.icon end,
        },
        displayIcon = {
            type = "input",
            name = L["Display Icon"],
            hidden = function() return WeakAuras.CanHaveAuto(data) and data.auto or not data.icon; end,
            disabled = function() return not data.icon end,
            order = 38.3,
            get = function()
                return data.displayIcon and tostring(data.displayIcon) or "";
            end,
            set = function(info, v)
                data.displayIcon = v;
                WeakAuras.Add(data);
                WeakAuras.SetThumbnail(data);
                WeakAuras.SetIconNames(data);
            end
        },
        displaySpace = {
            type = "execute",
            name = "",
            width = "half",
            hidden = function() return WeakAuras.CanHaveAuto(data) and data.auto or not data.icon; end,
            image = function() return data.displayIcon and tostring(data.displayIcon) or "", 18, 18 end,
            order = 38.4
        },
        chooseIcon = {
            type = "execute",
            name = L["Choose"],
            width = "half",
            hidden = function() return WeakAuras.CanHaveAuto(data) and data.auto or not data.icon; end,
            disabled = function() return not data.icon end,
            order = 38.5,
            func = function() WeakAuras.OpenIconPicker(data, "displayIcon"); end
        },
        icon_side = {
            type = "select",
            name = L["Icon"],
            values = WeakAuras.icon_side_types,
            hidden = function() return data.orientation:find("VERTICAL") or not data.icon end,
            order = 38.6,
        },
        icon_side2 = {
            type = "select",
            name = L["Icon"],
            values = WeakAuras.rotated_icon_side_types,
            hidden = function() return data.orientation:find("HORIZONTAL") or not data.icon end,
            order = 38.7,
            get = function()
                return data.icon_side;
            end,
            set = function(info, v)
                data.icon_side = v;
                WeakAuras.Add(data);
                WeakAuras.SetThumbnail(data);
                WeakAuras.SetIconNames(data);
            end
        },
        desaturate = {
            type = "toggle",
            name = L["Desaturate"],
            order = 38.8,
            hidden = function() return not data.icon end,
        },
        icon_color = {
            type = "color",
            name = L["Icon Color"],
            hasAlpha = true,
            order = 38.9,
            hidden = function() return not data.icon end,
        },
        zoom = {
            type = "range",
            name = L["Zoom"],
            order = 38.91,
            min = 0,
            max = 1,
            bigStep = 0.01,
            isPercent = true,
            hidden = function() return not data.icon end,
        },
		bar_header = {
			type = "header",
			name = L["Bar Color Settings"],
			order = 39
		},
        barColor = {
            type = "color",
            name = L["Bar Color"],
            hasAlpha = true,
            order = 39.5
        },
        backgroundColor = {
            type = "color",
            name = L["Background Color"],
            hasAlpha = true,
            order = 40
        },
        alpha = {
            type = "range",
            name = L["Bar Alpha"],
            order = 41,
            min = 0,
            max = 1,
            bigStep = 0.01,
            isPercent = true
        },
        spark_header = {
            type = "header",
            name = L["Spark Settings"],
            order = 42
        },
        spark = {
            type = "toggle",
            name = L["Spark"],
            order = 43
        },
        sparkTexture = {
            type = "input",
            name = L["Spark Texture"],
            order = 44,
            width = "double",
            disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        sparkDesaturate = {
            type = "toggle",
            name = L["Desaturate"],
            order = 44.1,
            disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        spaceSpark = {
            type = "execute",
            name = "",
            width = "half",
            order = 44.2,
            image = function() return "", 0, 0 end,
            disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        sparkChooseTexture = {
            type = "execute",
            name = L["Choose"],
            width = "half",
            order = 44.3,
            func = function()
                WeakAuras.OpenTexturePicker(data, "sparkTexture", WeakAuras.texture_types);
            end,
            disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        sparkColor = {
            type = "color",
            name = L["Color"],
            hasAlpha = true,
            order = 44.4,
            disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        sparkBlendMode = {
            type = "select",
            name = L["Blend Mode"],
            order = 44.5,
            values = WeakAuras.blend_types,
            disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        sparkWidth = {
            type = "range",
            name = L["Width"],
            order = 44.6,
            min = 1,
            softMax = screenWidth,
            bigStep = 1,
			disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        sparkHeight = {
            type = "range",
            name = L["Height"],
            order = 44.7,
            min = 1,
            softMax = screenHeight,
            bigStep = 1,
			disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        sparkOffsetX = {
            type = "range",
            name = L["X Offset"],
            order = 44.8,
            min = -screenWidth,
            max = screenWidth,
            bigStep = 1,
            disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        sparkOffsetY = {
            type = "range",
            name = L["Y Offset"],
            order = 44.9,
            min = -screenHeight,
            max = screenHeight,
            bigStep = 1,
            disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        sparkRotationMode = {
            type = "select",
            values = WeakAuras.spark_rotation_types,
            name = L["Rotation Mode"],
            order = 45,
            disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        sparkRotation = {
            type = "range",
            name = L["Rotation"],
            min = 0,
            max = 360,
            step = 90,
            order = 45.1,
            disabled = function() return not data.spark or data.sparkRotationMode == "AUTO" end,
            hidden = function() return not data.spark or data.sparkRotationMode == "AUTO" end,
        },
        sparkMirror = {
            type = "toggle",
            name = L["Mirror"],
            order = 45.2,
            disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
        sparkHidden = {
            type = "select",
            values = WeakAuras.spark_hide_types,
            name = L["Hide on"],
            order = 45.3,
            disabled = function() return not data.spark end,
            hidden = function() return not data.spark end,
        },
		border_header = {
			type = "header",
			name = L["Border Settings"],
			order = 46.0
		},
		barInFront  = {
            type = "toggle",
            name = L["Bar in Front"],
            order = 46.7,
            disabled = function() return not data.border end,
            hidden = function() return not data.border end,
        },
		text_header = {
			type = "header",
            name = function()
                if(data.orientation == "HORIZONTAL") then
                    return L["Left Text"];
                elseif(data.orientation == "HORIZONTAL_INVERSE") then
                    return L["Right Text"];
                elseif(data.orientation == "VERTICAL") then
                    return L["Bottom Text"];
                else
                    return L["Top Text"];
                end
            end,
			order = 47
		},
        text = {
            type = "toggle",
            name = function()
                if(data.orientation == "HORIZONTAL") then
                    return L["Left Text"];
                elseif(data.orientation == "HORIZONTAL_INVERSE") then
                    return L["Right Text"];
                elseif(data.orientation == "VERTICAL") then
                    return L["Bottom Text"];
                else
                    return L["Top Text"];
                end
            end,
            order = 47.5
        },
        textColor = {
            type = "color",
            name = L["Text Color"],
            hasAlpha = true,
            order = 48,
            disabled = function() return not data.text end,
            hidden = function() return not data.text end,
        },
        textFont = {
            type = "select",
            dialogControl = "LSM30_Font",
            name = L["Font Type"],
            order = 49,
            values = AceGUIWidgetLSMlists.font,
            disabled = function() return not data.text end,
            hidden = function() return not data.text end,
        },
        textSize = {
            type = "range",
            name = L["Font Size"],
            order = 50,
            min = 6,
            softMax = 72,
            step = 1,
            disabled = function() return not data.text end,
            hidden = function() return not data.text end,
        },
        textFlags = {
            type = "select",
            name = L["Font Flags"],
            order = 51,
            values = WeakAuras.font_flags,
            disabled = function() return not data.text end,
            hidden = function() return not data.text end,
        },
		timer_header = {
			type = "header",
            name = function()
                if(data.orientation == "HORIZONTAL") then
                    return L["Right Text"];
                elseif(data.orientation == "HORIZONTAL_INVERSE") then
                    return L["Left Text"];
                elseif(data.orientation == "VERTICAL") then
                    return L["Top Text"];
                else
                    return L["Bottom Text"];
                end
            end,
			order = 52
		},
        timer = {
            type = "toggle",
            name = function()
                if(data.orientation == "HORIZONTAL") then
                    return L["Right Text"];
                elseif(data.orientation == "HORIZONTAL_INVERSE") then
                    return L["Left Text"];
                elseif(data.orientation == "VERTICAL") then
                    return L["Top Text"];
                else
                    return L["Bottom Text"];
                end
            end,
            order = 52.5
        },
        timerColor = {
            type = "color",
            name = L["Text Color"],
            hasAlpha = true,
            order = 53,
            disabled = function() return not data.timer end,
            hidden = function() return not data.timer end,
        },
        timerFont = {
            type = "select",
            dialogControl = "LSM30_Font",
            name = L["Font Type"],
            order = 54,
            values = AceGUIWidgetLSMlists.font,
            disabled = function() return not data.timer end,
            hidden = function() return not data.timer end,
        },
        timerSize = {
            type = "range",
            name = L["Font Size"],
            order = 55,
            min = 6,
            softMax = 72,
            step = 1,
            disabled = function() return not data.timer end,
            hidden = function() return not data.timer end,
        },
        timerFlags = {
            type = "select",
            name = L["Font Flags"],
            order = 56,
            values = WeakAuras.font_flags,
            disabled = function() return not data.timer end,
            hidden = function() return not data.timer end,
        },
		stacks_header = {
			type = "header",
			name = L["Stacks Settings"],
			order = 57.1
		},
        stacks = {
            type = "toggle",
            name = L["Stacks"],
            order = 57.2
        },
		stacksColor = {
            type = "color",
            name = L["Text Color"],
            hasAlpha = true,
            order = 57.3,
            disabled = function() return not data.stacks end,
            hidden = function() return not data.stacks end,
        },
        stacksFont = {
            type = "select",
            dialogControl = "LSM30_Font",
            name = L["Font Type"],
            order = 57.4,
            values = AceGUIWidgetLSMlists.font,
            disabled = function() return not data.stacks end,
            hidden = function() return not data.stacks end,
        },
        stacksSize = {
            type = "range",
            name = L["Font Size"],
            order = 57.5,
            min = 6,
            softMax = 72,
            step = 1,
            disabled = function() return not data.stacks end,
            hidden = function() return not data.stacks end,
        },
		stacksFlags = {
            type = "select",
            name = L["Font Flags"],
            order = 57.6,
            values = WeakAuras.font_flags,
            disabled = function() return not data.stacks end,
            hidden = function() return not data.stacks end,
        },
        spacer = {
            type = "header",
            name = "",
            order = 58
        },
    };

	-- Positioning options
	options = WeakAuras.AddPositionOptions(options, id, data);

	-- Border options
	options = WeakAuras.AddBorderOptions(options, id, data);

	-- Return options
    return options;
end

-- Create preview thumbnail
local function createThumbnail(parent, fullCreate)
	-- Preview frame
    local borderframe = CreateFrame("FRAME", nil, parent);
    borderframe:SetWidth(32);
    borderframe:SetHeight(32);

	-- Preview border
    local border = borderframe:CreateTexture(nil, "OVERLAY");
    border:SetAllPoints(borderframe);
    border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
    border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

	-- Main region
    local region = CreateFrame("FRAME", nil, borderframe);
    borderframe.region = region;
    region:SetWidth(32);
    region:SetHeight(32);

	-- Status-bar frame
    local bar = CreateFrame("FRAME", nil, region);
    borderframe.bar = bar;

	-- Fake status-bar
    local texture = bar:CreateTexture(nil, "OVERLAY");
    borderframe.texture = texture;

	-- Fake icon
    local icon = region:CreateTexture();
    borderframe.icon = icon;
    icon:SetTexture("Interface\\Icons\\INV_Misc_QuestionMark");

	-- Return preview
    return borderframe;
end

-- Modify preview thumbnail
local function modifyThumbnail(parent, borderframe, data, fullModify, width, height)
	-- Localize
    local region, bar, texture, icon = borderframe.region, borderframe.bar, borderframe.texture, borderframe.icon;

	-- Defaut size
    width  = width or 26;
    height = height or 15;

	-- Fake orientation (main region)
    if(data.orientation:find("HORIZONTAL")) then
        region:SetWidth(width);
        region:SetHeight(height);
        region:ClearAllPoints();
        if(data.orientation == "HORIZONTAL_INVERSE") then
            region:SetPoint("RIGHT", borderframe, "RIGHT", -2, 0);
        else
            region:SetPoint("LEFT", borderframe, "LEFT", 2, 0);
        end
    else
        region:SetWidth(height);
        region:SetHeight(width);
        region:ClearAllPoints();
        if(data.orientation == "VERTICAL_INVERSE") then
            region:SetPoint("TOP", borderframe, "TOP", 0, -2);
        else
            region:SetPoint("BOTTOM", borderframe, "BOTTOM", 0, 2);
        end
    end

	-- Fake bar alpha
    region:SetAlpha(data.alpha);

	-- Fake status-bar style
    texture:SetTexture(SharedMedia:Fetch("statusbar", data.texture));
    texture:SetVertexColor(data.barColor[1], data.barColor[2], data.barColor[3], data.barColor[4]);

	-- Fake icon size
    local iconsize = height;
    icon:SetWidth(iconsize);
    icon:SetHeight(iconsize);

	-- Fake layout variables
    local percent, length;
    if(data.icon) then
        length = width - height;
        percent = 1 - (width / 100);
    else
        length = width;
        percent = 1 - (width / 100);
    end

	-- Reset region members
    icon:ClearAllPoints();
    bar:ClearAllPoints();
    texture:ClearAllPoints();

	-- Fake orientation (region members)
    if(data.orientation == "HORIZONTAL_INVERSE") then
        icon:SetPoint("LEFT", region, "LEFT");
        bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
        if(data.icon) then
            bar:SetPoint("TOPLEFT", icon, "TOPRIGHT");
        else
            bar:SetPoint("TOPLEFT", region, "TOPLEFT");
        end
        texture:SetPoint("BOTTOMRIGHT", bar, "BOTTOMRIGHT");
        texture:SetPoint("TOPRIGHT", bar, "TOPRIGHT");
        texture:SetTexCoord(1, 0, 1, 1, percent, 0, percent, 1);
        texture:SetWidth(length);
    elseif(data.orientation == "HORIZONTAL") then
        icon:SetPoint("RIGHT", region, "RIGHT");
        bar:SetPoint("BOTTOMLEFT", region, "BOTTOMLEFT");
        if(data.icon) then
            bar:SetPoint("TOPRIGHT", icon, "TOPLEFT");
        else
            bar:SetPoint("TOPRIGHT", region, "TOPRIGHT");
        end
        texture:SetPoint("BOTTOMLEFT", bar, "BOTTOMLEFT");
        texture:SetPoint("TOPLEFT", bar, "TOPLEFT");
        texture:SetTexCoord(percent, 0, percent, 1, 1, 0, 1, 1);
        texture:SetWidth(length);
    elseif(data.orientation == "VERTICAL_INVERSE") then
        icon:SetPoint("BOTTOM", region, "BOTTOM");
        bar:SetPoint("TOPLEFT", region, "TOPLEFT");
        if(data.icon) then
            bar:SetPoint("BOTTOMRIGHT", icon, "TOPRIGHT");
        else
            bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
        end
        texture:SetPoint("TOPLEFT", bar, "TOPLEFT");
        texture:SetPoint("TOPRIGHT", bar, "TOPRIGHT");
        texture:SetTexCoord(percent, 0, 1, 0, percent, 1, 1, 1);
        texture:SetHeight(length);
    elseif(data.orientation == "VERTICAL") then
        icon:SetPoint("TOP", region, "TOP");
        bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
        if(data.icon) then
            bar:SetPoint("TOPLEFT", icon, "BOTTOMLEFT");
        else
            bar:SetPoint("TOPLEFT", region, "TOPLEFT");
        end
        texture:SetPoint("BOTTOMLEFT", bar, "BOTTOMLEFT");
        texture:SetPoint("BOTTOMRIGHT", bar, "BOTTOMRIGHT");
        texture:SetTexCoord(1, 0, percent, 0, 1, 1, percent, 1);
        texture:SetHeight(length);
    end

	-- Fake icon (code)
    if(data.icon) then
        function borderframe:SetIcon(path)
            local success = icon:SetTexture(data.auto and path or data.displayIcon) and (data.auto and path or data.displayIcon);
            if not(success) then
                icon:SetTexture("Interface\\Icons\\INV_Misc_QuestionMark");
            end
        end
        icon:Show();
    else
        icon:Hide();
    end
end

-- Create "new region" preview
local function createIcon()
	-- Default data
    local data = {
        icon = true,
        auto = true,
        texture = "Runes",
        orientation = "HORIZONTAL",
        alpha = 1.0,
        barColor = {1, 0, 0, 1}
    };

	-- Create and configure thumbnail
    local thumbnail = createThumbnail(UIParent);
    modifyThumbnail(UIParent, thumbnail, data, nil, 32, 18);
    thumbnail:SetIcon("Interface\\Icons\\INV_Sword_122");

	-- Return thumbnail
    return thumbnail;
end

local templates = {
  {
    title = L["Default"],
    data = {
    };
  },
  {
    title = L["Horizontal Blizzard Raid Bar"],
    data = {
      texture = "Blizzard Raid Bar",
      width = 200,
      height = 15,
    };
  },
  {
    title = L["Horizontal Bar"],
    data = {
      width = 200,
      height = 30,
      barColor = { 1, 1, 0, 1}
    }
  },
  {
    title = L["Vertical Bar"],
    data = {
      width = 30,
      height = 200,
      barColor = { 0, 1, 0, 1},
      rotateText = "LEFT",
      orientation = "VERTICAL_INVERSE",
      texture = "Blizzard Raid Bar",
      icon = false
    }
  },
}

-- Register new region type options with WeakAuras
WeakAuras.RegisterRegionOptions("aurabar", createOptions, createIcon, L["Progress Bar"], createThumbnail, modifyThumbnail, L["Shows a progress bar with name, timer, and icon"], templates);

local L = WeakAuras.L

-- GLOBALS: WeakAuras UIParent AceGUIWidgetLSMlists

local function createOptions(id, data)
    local options = {
        texture = {
            type = "input",
            width = "double",
            name = L["Texture"],
            order = 0
        },
		desaturate = {
            type = "toggle",
            name = L["Desaturate"],
            order = 2,
        },
        space2 = {
            type = "execute",
            name = "",
            width = "half",
            order = 5,
            image = function() return "", 0, 0 end,
        },
        chooseTexture = {
            type = "execute",
            name = L["Choose"],
            width = "half",
            order = 7,
            func = function()
                WeakAuras.OpenTexturePicker(data, "texture", WeakAuras.texture_types);
            end
        },
        color = {
            type = "color",
            name = L["Color"],
            hasAlpha = true,
            order = 10
        },
        blendMode = {
            type = "select",
            name = L["Blend Mode"],
            order = 12,
            values = WeakAuras.blend_types
        },
        mirror = {
            type = "toggle",
            name = L["Mirror"],
            order = 20
        },
        rotate = {
            type = "toggle",
            name = L["Allow Full Rotation"],
            order = 25
        },
        space3 = {
            type = "execute",
            name = "",
            order = 30,
            image = function() return "", 0, 0 end,
        },
        rotation = {
            type = "range",
            name = L["Rotation"],
            min = 0,
            max = 360,
            step = 1,
            bigStep = 3,
            order = 35,
            hidden = function() return not data.rotate end
        },
        discrete_rotation = {
            type = "range",
            name = L["Discrete Rotation"],
            min = 0,
            max = 360,
            step = 90,
            order = 35,
            hidden = function() return data.rotate end
        },
        spacer = {
            type = "header",
            name = "",
            order = 50
        }
    };
    options = WeakAuras.AddPositionOptions(options, id, data);

    return options;
end

local function createThumbnail(parent, fullCreate)
    local borderframe = CreateFrame("FRAME", nil, parent);
    borderframe:SetWidth(32);
    borderframe:SetHeight(32);

    local border = borderframe:CreateTexture(nil, "OVERLAY");
    border:SetAllPoints(borderframe);
    border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
    border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

    local texture = borderframe:CreateTexture();
    borderframe.texture = texture;
    texture:SetPoint("CENTER", borderframe, "CENTER");

    return borderframe;
end

local function modifyThumbnail(parent, region, data, fullModify, size)
    size = size or 30;
    local scale;
    if(data.height > data.width) then
        scale = size/data.height;
        region.texture:SetWidth(scale * data.width);
        region.texture:SetHeight(size);
    else
        scale = size/data.width;
        region.texture:SetWidth(size);
        region.texture:SetHeight(scale * data.height);
    end

    region.texture:SetTexture(data.texture);
    region.texture:SetVertexColor(data.color[1], data.color[2], data.color[3], data.color[4]);
    region.texture:SetBlendMode(data.blendMode);

    local ulx,uly , llx,lly , urx,ury , lrx,lry;
    if(data.rotate) then
        local angle = rad(135 - data.rotation);
        local vx = math.cos(angle);
        local vy = math.sin(angle);

        ulx,uly , llx,lly , urx,ury , lrx,lry = 0.5+vx,0.5-vy , 0.5-vy,0.5-vx , 0.5+vy,0.5+vx , 0.5-vx,0.5+vy;
    else
        if(data.discrete_rotation == 0 or data.discrete_rotation == 360) then
            ulx,uly , llx,lly , urx,ury , lrx,lry = 0,0 , 0,1 , 1,0 , 1,1;
        elseif(data.discrete_rotation == 90) then
            ulx,uly , llx,lly , urx,ury , lrx,lry = 1,0 , 0,0 , 1,1 , 0,1;
        elseif(data.discrete_rotation == 180) then
            ulx,uly , llx,lly , urx,ury , lrx,lry = 1,1 , 1,0 , 0,1 , 0,0;
        elseif(data.discrete_rotation == 270) then
            ulx,uly , llx,lly , urx,ury , lrx,lry = 0,1 , 1,1 , 0,0 , 1,0;
        end
    end
    if(data.mirror) then
        region.texture:SetTexCoord(urx,ury , lrx,lry , ulx,uly , llx,lly);
    else
        region.texture:SetTexCoord(ulx,uly , llx,lly , urx,ury , lrx,lry);
    end
end

local function createIcon()
    local data = {
        height = 40,
        width = 40,
        texture = "Textures\\SpellActivationOverlays\\Eclipse_Sun",
        color = {1, 1, 1, 1},
        blendMode = "ADD",
        rotate = true;
        rotation = 0;
    };

    local thumbnail = createThumbnail(UIParent);
    modifyThumbnail(UIParent, thumbnail, data, nil, 50);

    return thumbnail;
end

local templates = {
  {
    title = L["Default"],
    data = {
    };
  },
  {
    title = L["Star"],
    data = {
      texture = "Spells\\T_Star3",
      blendMode = "ADD",
      width = 200,
      height = 200,
      discrete_rotation = 0,
    }
  },
  {
    title = L["Leaf"],
    data = {
      texture = "Spells\\Nature_Rune_128",
      blendMode = "ADD",
      width = 200,
      height = 200,
      discrete_rotation = 0,
    }
  },
  {
    title = L["Hawk"],
    data = {
      texture = "Spells\\Aspect_Hawk",
      blendMode = "ADD",
      width = 200,
      height = 200,
      discrete_rotation = 0,
    }
  },
  {
    title = L["Low Mana"],
    data = {
      texture = "Interface\\Addons\\WeakAuras\\PowerAurasMedia\\Auras\\Aura70",
      blendMode = "ADD",
      width = 200,
      height = 200,
      discrete_rotation = 0,
    }
  },
}

WeakAuras.RegisterRegionOptions("texture", createOptions, createIcon, L["Texture"], createThumbnail, modifyThumbnail, L["Shows a custom texture"], templates);

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

-- GLOBALS: WeakAuras UIParent AceGUIWidgetLSMlists

local function createOptions(id, data)
    local options = {
        cooldown = {
            type = "toggle",
            name = L["Cooldown"],
            order = 4,
            disabled = function() return not WeakAuras.CanHaveDuration(data); end,
            get = function() return WeakAuras.CanHaveDuration(data) and data.cooldown; end
        },
        auto = {
            type = "toggle",
            name = L["Automatic Icon"],
            order = 8,
            disabled = function() return not WeakAuras.CanHaveAuto(data); end,
            get = function() return WeakAuras.CanHaveAuto(data) and data.auto; end
        },
        displayIcon = {
            type = "input",
            name = L["Display Icon"],
            hidden = function() return WeakAuras.CanHaveAuto(data) and data.auto; end,
            order = 12,
            get = function()
                return data.displayIcon and tostring(data.displayIcon) or "";
            end,
            set = function(info, v)
                data.displayIcon = v;
                WeakAuras.Add(data);
                WeakAuras.SetThumbnail(data);
                WeakAuras.SetIconNames(data);
            end
        },
        chooseIcon = {
            type = "execute",
            name = L["Choose"],
            hidden = function() return WeakAuras.CanHaveAuto(data) and data.auto; end,
            order = 18,
            func = function() WeakAuras.OpenIconPicker(data, "displayIcon"); end
        },

        desaturate = {
            type = "toggle",
            name = L["Desaturate"],
            order = 18.5,
        },
        inverse = {
            type = "toggle",
            name = L["Inverse"],
            order = 6,
            disabled = function() return not (WeakAuras.CanHaveDuration(data) and data.cooldown); end,
            get = function() return data.inverse and WeakAuras.CanHaveDuration(data) and data.cooldown; end
        },
        displayStacks = {
            type = "input",
            name = L["Text"],
            desc = function()
                 local ret = L["Dynamic text tooltip"];
                 ret = ret .. WeakAuras.GetAdditionalProperties(data);
                 return ret
            end,
            order = 40
        },
        textColor = {
            type = "color",
            name = L["Color"],
            hasAlpha = true,
            order = 42
        },
        stacksPoint = {
            type = "select",
            name = L["Text Position"],
            order = 41,
            values = WeakAuras.point_types
        },
        customTextUpdate = {
            type = "select",
            width = "double",
            hidden = function() return not data.displayStacks:find("%%c"); end,
            name = L["Update Custom Text On..."],
            values = WeakAuras.text_check_types,
            order = 41.1
        },
        customText = {
            type = "input",
            width = "normal",
            hidden = function()
                return not data.displayStacks:find("%%c")
            end,
            multiline = true,
            name = L["Custom Function"],
            order = 41.2
        },
        customText_expand = {
            type = "execute",
            order = 41.2,
            name = L["Expand Text Editor"],
            func = function()
                WeakAuras.OpenTextEditor(data, {"customText"})
            end,
            hidden = function()
                return not data.displayStacks:find("%%c")
            end,
        },
        stacksContainment = {
            type = "select",
            name = " ",
            order = 43,
            values = WeakAuras.containment_types
        },
        progressPrecision = {
            type = "select",
            order = 44,
            name = L["Remaining Time Precision"],
            values = WeakAuras.precision_types,
            get = function() return data.progressPrecision or 1 end,
            hidden = function()
                return not (data.displayStacks:find("%%p") or data.displayStacks:find("%%t"));
            end,
            disabled = function()
                return not data.displayStacks:find("%%p");
            end
        },
        totalPrecision = {
            type = "select",
            order = 44.5,
            name = L["Total Time Precision"],
            values = WeakAuras.precision_types,
            get = function() return data.totalPrecision or 1 end,
            hidden = function()
                return not (data.displayStacks:find("%%p") or data.displayStacks:find("%%t"));
            end,
            disabled = function()
                return not data.displayStacks:find("%%t");
            end
        },
        color = {
            type = "color",
            name = L["Color"],
            hasAlpha = true,
            order = 7
        },
        font = {
            type = "select",
            dialogControl = "LSM30_Font",
            name = L["Font"],
            order = 45,
            values = AceGUIWidgetLSMlists.font
        },
        fontSize = {
            type = "range",
            name = L["Size"],
            order = 47,
            min = 6,
            softMax = 72,
            step = 1
        },
        zoom = {
            type = "range",
            name = L["Zoom"],
            order = 49,
            min = 0,
            max = 1,
            bigStep = 0.01,
            isPercent = true
        },
        fontFlags = {
            type = "select",
            name = L["Outline"],
            order = 48,
            values = WeakAuras.font_flags
        },
		iconInset = {
            type = "range",
            name = L["Icon Inset"],
            order = 49.25,
            min = 0,
            max = 1,
            bigStep = 0.01,
            isPercent = true,
			hidden = function()
                return not LBF;
            end
        },
        stickyDuration = {
            type = "toggle",
            name = L["Sticky Duration"],
            desc = L["Prevents duration information from decreasing when an aura refreshes. May cause problems if used with multiple auras with different durations."],
            order = 49
        },
        useTooltip = {
            type = "toggle",
            name = L["Tooltip on Mouseover"],
            hidden = function() return not WeakAuras.CanHaveTooltip(data) end,
            order = 49.5
        },
        spacer = {
            type = "header",
            name = "",
            order = 50
        }
    };
    options = WeakAuras.AddPositionOptions(options, id, data);

    return options;
end

local function createThumbnail(parent, fullCreate)
    local icon = parent:CreateTexture();
    icon:SetTexture("Interface\\Icons\\INV_Misc_QuestionMark");

    return icon;
end

local function modifyThumbnail(parent, icon, data, fullModify)
    local texWidth = 0.25 * data.zoom;
    icon:SetTexCoord(texWidth, 1 - texWidth, texWidth, 1 - texWidth);

    function icon:SetIcon(path)
        local success = icon:SetTexture(data.auto and path or data.displayIcon) and (data.auto and path or data.displayIcon);
        if not(success) then
            icon:SetTexture("Interface\\Icons\\INV_Misc_QuestionMark");
        end
    end
end

local templates = {
  {
    title = L["Default"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
    };
  },
  {
    title = L["Tiny Icon"],
    description = L["A 20x20 pixels icon"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
      width = 20,
      height = 20,
      cooldown = true
    };
  },
  {
    title = L["Small Icon"],
    description = L["A 32x32 pixels icon"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
      width = 32,
      height = 32,
      cooldown = true
    };
  },
  {
    title = L["Medium Icon"],
    description = L["A 40x40 pixels icon"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
      width = 40,
      height = 40,
      cooldown = true
    };
  },
  {
    title = L["Big Icon"],
    description = L["A 48x48 pixels icon"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
      width = 48,
      height = 48,
      cooldown = true
    };
  },
  {
    title = L["Huge Icon"],
    description = L["A 64x64 pixels icon"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
      width = 64,
      height = 64,
      cooldown = true
    };
  }
}

WeakAuras.RegisterRegionOptions("icon", createOptions, "Interface\\ICONS\\Temp.blp", L["Icon"], createThumbnail, modifyThumbnail, L["Shows a spell icon with an optional cooldown overlay"], templates);

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;
local dynamics = WeakAuras.dynamic_texts;

-- GLOBALS: WeakAuras UIParent AceGUIWidgetLSMlists

local function createOptions(id, data)
    local options = {
        displayText = {
            type = "input",
            width = "double",
            desc = function()
                 local ret = L["Dynamic text tooltip"];
                 ret = ret .. WeakAuras.GetAdditionalProperties(data);
                 return ret
            end,
            multiline = true,
            name = L["Display Text"],
            order = 10,
            get = function()
                local ret = data.displayText;
                for symbol, v in pairs(WeakAuras.dynamic_texts) do
                    ret = ret:gsub("("..symbol..")", "|cFFFF0000%1|r");
                end
                return ret;
            end,
            set = function(info, v)
                v = v:gsub("|cFFFF0000", "");
                v = v:gsub("|r", "");
                data.displayText = v;
                WeakAuras.Add(data);
                WeakAuras.SetThumbnail(data);
                WeakAuras.SetIconNames(data);
                WeakAuras.ResetMoverSizer();
            end
        },
        customTextUpdate = {
            type = "select",
            width = "double",
            hidden = function() return not data.displayText:find("%%c"); end,
            name = L["Update Custom Text On..."],
            values = WeakAuras.text_check_types,
            order = 36
        },
        customText = {
            type = "input",
            width = "normal",
            hidden = function()
                return not data.displayText:find("%%c")
            end,
            multiline = true,
            name = L["Custom Function"],
            order = 37
        },
        customText_expand = {
            type = "execute",
            order = 38,
            name = L["Expand Text Editor"],
            func = function()
                WeakAuras.OpenTextEditor(data, {"customText"})
            end,
            hidden = function()
                return not data.displayText:find("%%c")
            end,
        },
        progressPrecision = {
            type = "select",
            order = 39,
            name = L["Remaining Time Precision"],
            values = WeakAuras.precision_types,
            get = function() return data.progressPrecision or 1 end,
            hidden = function()
                return not (data.displayText:find("%%p") or data.displayText:find("%%t"));
            end,
            disabled = function()
                return not data.displayText:find("%%p");
            end
        },
        totalPrecision = {
            type = "select",
            order = 39.5,
            name = L["Total Time Precision"],
            values = WeakAuras.precision_types,
            get = function() return data.totalPrecision or 1 end,
            hidden = function()
                return not (data.displayText:find("%%p") or data.displayText:find("%%t"));
            end,
            disabled = function()
                return not data.displayText:find("%%t");
            end
        },
        color = {
            type = "color",
            name = L["Text Color"],
            hasAlpha = true,
            order = 40
        },
        justify = {
            type = "select",
            name = L["Justify"],
            order = 43,
            values = WeakAuras.justify_types
        },
        font = {
            type = "select",
            dialogControl = "LSM30_Font",
            name = L["Font"],
            order = 45,
            values = AceGUIWidgetLSMlists.font
        },
        fontSize = {
            type = "range",
            name = L["Size"],
            order = 47,
            min = 6,
            softMax = 72,
            step = 1
        },
        outline = {
            type = "select",
            name = L["Outline"],
            order = 48,
            values = WeakAuras.font_flags
        },
        spacer = {
            type = "header",
            name = "",
            order = 50
        }
    };
    options = WeakAuras.AddPositionOptions(options, id, data);

    options.width = nil;
    options.height = nil;

    return options;
end

local function createThumbnail(parent, fullCreate)
    local borderframe = CreateFrame("FRAME", nil, parent);
    borderframe:SetWidth(32);
    borderframe:SetHeight(32);

    local border = borderframe:CreateTexture(nil, "OVERLAY");
    border:SetAllPoints(borderframe);
    border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
    border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

    local mask = CreateFrame("ScrollFrame", nil, borderframe);
    borderframe.mask = mask;
    mask:SetPoint("BOTTOMLEFT", borderframe, "BOTTOMLEFT", 2, 2);
    mask:SetPoint("TOPRIGHT", borderframe, "TOPRIGHT", -2, -2);

    local content = CreateFrame("Frame", nil, mask);
    borderframe.content = content;
    content:SetPoint("CENTER", mask, "CENTER");
    mask:SetScrollChild(content);

    local text = content:CreateFontString(nil, "OVERLAY");
    borderframe.text = text;
    text:SetNonSpaceWrap(true);

    borderframe.values = {};

    return borderframe;
end

local function modifyThumbnail(parent, borderframe, data, fullModify, size)
    local mask, content, text = borderframe.mask, borderframe.content, borderframe.text;

    size = size or 28;

    local fontPath = SharedMedia:Fetch("font", data.font) or data.font;
    text:SetFont(fontPath, data.fontSize, data.outline and "OUTLINE" or nil);
    text:SetTextHeight(data.fontSize);
    text:SetText(data.displayText);
    text:SetTextColor(data.color[1], data.color[2], data.color[3], data.color[4]);
    text:SetJustifyH(data.justify);

    text:ClearAllPoints();
    text:SetPoint("CENTER", UIParent, "CENTER");
    content:SetWidth(math.max(text:GetStringWidth(), size));
    content:SetHeight(math.max(text:GetStringHeight(), size));
    text:ClearAllPoints();
    text:SetPoint("CENTER", content, "CENTER");

    local function rescroll()
        content:SetWidth(math.max(text:GetStringWidth(), size));
        content:SetHeight(math.max(text:GetStringHeight(), size));
        local xo = 0;
        if(data.justify == "CENTER") then
            xo = mask:GetHorizontalScrollRange() / 2;
        elseif(data.justify == "RIGHT") then
            xo = mask:GetHorizontalScrollRange();
        end
        mask:SetHorizontalScroll(xo);
        mask:SetVerticalScroll(mask:GetVerticalScrollRange() / 2);
    end

    rescroll();
    mask:SetScript("OnScrollRangeChanged", rescroll);

    local function UpdateText()
        local textStr = data.displayText
        for symbol, v in pairs(WeakAuras.dynamic_texts) do
            if(v.static) then
                textStr = textStr:gsub(symbol, v.static);
            else
                textStr = textStr:gsub(symbol, borderframe.values[v.value] or "?");
            end
        end
        text:SetText(textStr);
        rescroll();
    end

    function borderframe:SetIcon(path)
        local icon = (
            WeakAuras.CanHaveAuto(data)
            and path ~= ""
            and path
            or data.displayIcon
            or "Interface\\Icons\\INV_Misc_QuestionMark"
        );
        borderframe.values.icon = "|T"..icon..":12:12:0:0:64:64:4:60:4:60|t";
        UpdateText();
    end

    function borderframe:SetName(name)
        borderframe.values.name = WeakAuras.CanHaveAuto(data) and name or data.id;
        UpdateText();
    end

    UpdateText();
end

local function createIcon()
    local data = {
        outline = true,
        color = {1, 1, 0, 1},
        justify = "CENTER",
        font = "Friz Quadrata TT",
        fontSize = 12,
        displayText = "World\nof\nWarcraft";
    };

    local thumbnail = createThumbnail(UIParent);
    modifyThumbnail(UIParent, thumbnail, data);
    thumbnail.mask:SetPoint("BOTTOMLEFT", thumbnail, "BOTTOMLEFT", 3, 3);
    thumbnail.mask:SetPoint("TOPRIGHT", thumbnail, "TOPRIGHT", -3, -3);

    return thumbnail;
end

local templates = {
  {
    title = L["Default"],
    description = L["Displays a text, works best in combination with other displays"],
    data = {
    };
  }
}

WeakAuras.RegisterRegionOptions("text", createOptions, createIcon, L["Text"], createThumbnail, modifyThumbnail, L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"], templates);

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

-- GLOBALS: WeakAuras UIParent AceGUIWidgetLSMlists

-- Calculate bounding box
local function getRect(data)
  -- Temp variables
  local blx, bly, trx, try;
  blx, bly = data.xOffset, data.yOffset;

  -- Calc bounding box
  if(data.selfPoint:find("LEFT")) then
    trx = blx + data.width;
  elseif(data.selfPoint:find("RIGHT")) then
    trx = blx;
    blx = blx - data.width;
  else
    blx = blx - (data.width/2);
    trx = blx + data.width;
  end
  if(data.selfPoint:find("BOTTOM")) then
    try = bly + data.height;
  elseif(data.selfPoint:find("TOP")) then
    try = bly;
    bly = bly - data.height;
  else
    bly = bly - (data.height/2);
    try = bly + data.height;
  end

  -- Return data
  return blx, bly, trx, try;
end

-- Create region options table
local function createOptions(id, data)
  -- Region options
  local options = {
    align_h = {
      type = "select",
      name = L["Horizontal Align"],
      order = 10,
      values = WeakAuras.align_types,
      get = function()
        if(#data.controlledChildren < 1) then
          return nil;
        end
        local alignedCenter, alignedRight, alignedLeft = "CENTER", "RIGHT", "LEFT";
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local left, _, right = getRect(childData);
            local center = (left + right) / 2;
            if(math.abs(right) >= 0.01) then
              alignedRight = nil;
            end
            if(math.abs(left) >= 0.01) then
              alignedLeft = nil;
            end
            if(math.abs(center) >= 0.01) then
              alignedCenter = nil;
            end
          end
        end
        return (alignedCenter or alignedRight or alignedLeft);
      end,
      set = function(info, v)
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            if(v == "CENTER") then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = 0 - (childData.width / 2);
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = 0 + (childData.width / 2);
              else
                childData.xOffset = 0;
              end
            elseif(v == "LEFT") then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = 0;
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = 0 + childData.width;
              else
                childData.xOffset = 0 + (childData.width / 2);
              end
            elseif(v == "RIGHT") then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = 0 - childData.width;
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = 0;
              else
                childData.xOffset = 0 - (childData.width / 2);
              end
            end
            WeakAuras.Add(childData);
          end
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
      end
    },
    align_v = {
      type = "select",
      name = L["Vertical Align"],
      order = 15,
      values = WeakAuras.rotated_align_types,
      get = function()
        if(#data.controlledChildren < 1) then
          return nil;
        end
        local alignedCenter, alignedBottom, alignedTop = "CENTER", "RIGHT", "LEFT";
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local _, bottom, _, top = getRect(childData);
            local center = (bottom + top) / 2;
            if(math.abs(bottom) >= 0.01) then
              alignedBottom = nil;
            end
            if(math.abs(top) >= 0.01) then
              alignedTop = nil;
            end
            if(math.abs(center) >= 0.01) then
              alignedCenter = nil;
            end
          end
        end
        return alignedCenter or alignedBottom or alignedTop;
      end,
      set = function(info, v)
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            if(v == "CENTER") then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = 0 - (childData.height / 2);
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = 0 + (childData.height / 2);
              else
                childData.yOffset = 0;
              end
            elseif(v == "RIGHT") then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = 0;
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = 0 + childData.height;
              else
                childData.yOffset = 0 + (childData.height / 2);
              end
            elseif(v == "LEFT") then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = 0 - childData.height;
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = 0;
              else
                childData.yOffset = 0 - (childData.height / 2);
              end
            end
            WeakAuras.Add(childData);
          end
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
      end
    },
    distribute_h = {
      type = "range",
      name = L["Distribute Horizontally"],
      order = 20,
      softMin = -100,
      softMax = 100,
      bigStep = 1,
      get = function()
        if(#data.controlledChildren < 2) then
          return nil;
        end
        local spaced;
        local previousData;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local left, _, right = getRect(childData);
            if not(previousData) then
              if not(math.abs(left) < 0.01 or math.abs(right) < 0.01) then
                return nil;
              end
              previousData = childData;
            else
              local pleft, _, pright = getRect(previousData);
              if(left - pleft > 0) then
                if not(spaced) then
                  spaced = left - pleft;
                else
                  if(math.abs(spaced - (left - pleft)) > 0.01) then
                    return nil;
                  end
                end
              elseif(right - pright < 0) then
                if not(spaced) then
                  spaced = right - pright;
                else
                  if(math.abs(spaced - (right - pright)) > 0.01) then
                    return nil;
                  end
                end
              else
                return nil;
              end
            end
            previousData = childData;
          end
        end
        return spaced;
      end,
      set = function(info, v)
        local xOffset = 0;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            if(v > 0) then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = xOffset;
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = xOffset + childData.width;
              else
                childData.xOffset = xOffset + (childData.width / 2);
              end
              xOffset = xOffset + v;
            elseif(v < 0) then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = xOffset - childData.width;
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = xOffset;
              else
                childData.xOffset = xOffset - (childData.width / 2);
              end
              xOffset = xOffset + v;
            end
            WeakAuras.Add(childData);
          end
        end

        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
      end
    },
    distribute_v = {
      type = "range",
      name = L["Distribute Vertically"],
      order = 25,
      softMin = -100,
      softMax = 100,
      bigStep = 1,
      get = function()
        if(#data.controlledChildren < 2) then
          return nil;
        end
        local spaced;
        local previousData;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local _, bottom, _, top = getRect(childData);
            if not(previousData) then
              if not(math.abs(bottom) < 0.01 or math.abs(top) < 0.01) then
                return nil;
              end
              previousData = childData;
            else
              local _, pbottom, _, ptop = getRect(previousData);
              if(bottom - pbottom > 0) then
                if not(spaced) then
                  spaced = bottom - pbottom;
                else
                  if(math.abs(spaced - (bottom - pbottom)) > 0.01) then
                    return nil;
                  end
                end
              elseif(top - ptop < 0) then
                if not(spaced) then
                  spaced = top - ptop;
                else
                  if(math.abs(spaced - (top - ptop)) > 0.01) then
                    return nil;
                  end
                end
              else
                return nil;
              end
            end
            previousData = childData;
          end
        end
        return spaced;
      end,
      set = function(info, v)
        local yOffset = 0;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            if(v > 0) then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = yOffset;
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = yOffset + childData.height;
              else
                childData.yOffset = yOffset + (childData.height / 2);
              end
              yOffset = yOffset + v;
            elseif(v < 0) then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = yOffset - childData.height;
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = yOffset;
              else
                childData.yOffset = yOffset - (childData.height / 2);
              end
              yOffset = yOffset + v;
            end
            WeakAuras.Add(childData);
          end
        end

        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
      end
    },
    space_h = {
      type = "range",
      name = L["Space Horizontally"],
      order = 30,
      softMin = -100,
      softMax = 100,
      bigStep = 1,
      get = function()
        if(#data.controlledChildren < 2) then
          return nil;
        end
        local spaced;
        local previousData;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local left, _, right = getRect(childData);
            if not(previousData) then
              if not(math.abs(left) < 0.01 or math.abs(right) < 0.01) then
                return nil;
              end
              previousData = childData;
            else
              local pleft, _, pright = getRect(previousData);
              if(left - pright > 0) then
                if not(spaced) then
                  spaced = left - pright;
                else
                  if(math.abs(spaced - (left - pright)) > 0.01) then
                    return nil;
                  end
                end
              elseif(right - pleft < 0) then
                if not(spaced) then
                  spaced = right - pleft;
                else
                  if(math.abs(spaced - (right - pleft)) > 0.01) then
                    return nil;
                  end
                end
              else
                return nil;
              end
            end
            previousData = childData;
          end
        end
        return spaced;
      end,
      set = function(info, v)
        local xOffset = 0;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            if(v > 0) then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = xOffset;
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = xOffset + childData.width;
              else
                childData.xOffset = xOffset + (childData.width / 2);
              end
              xOffset = xOffset + v + childData.width;
            elseif(v < 0) then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = xOffset - childData.width;
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = xOffset;
              else
                childData.xOffset = xOffset - (childData.width / 2);
              end
              xOffset = xOffset + v - childData.width;
            end
            WeakAuras.Add(childData);
          end
        end

        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
      end
    },
    space_v = {
      type = "range",
      name = L["Space Vertically"],
      order = 35,
      softMin = -100,
      softMax = 100,
      bigStep = 1,
      get = function()
        if(#data.controlledChildren < 2) then
          return nil;
        end
        local spaced;
        local previousData;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local _, bottom, _, top = getRect(childData);
            if not(previousData) then
              if not(math.abs(bottom) < 0.01 or math.abs(top) < 0.01) then
                return nil;
              end
              previousData = childData;
            else
              local _, pbottom, _, ptop = getRect(previousData);
              if(bottom - ptop > 0) then
                if not(spaced) then
                  spaced = bottom - ptop;
                else
                  if(math.abs(spaced - (bottom - ptop)) > 0.01) then
                    return nil;
                  end
                end
              elseif(top - pbottom < 0) then
                if not(spaced) then
                  spaced = top - pbottom;
                else
                  if(math.abs(spaced - (top - pbottom)) > 0.01) then
                    return nil;
                  end
                end
              else
                return nil;
              end
            end
            previousData = childData;
          end
        end
        return spaced;
      end,
      set = function(info, v)
        local yOffset = 0;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            if(v > 0) then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = yOffset;
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = yOffset + childData.height;
              else
                childData.yOffset = yOffset + (childData.height / 2);
              end
              yOffset = yOffset + v + childData.height;
            elseif(v < 0) then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = yOffset - childData.height;
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = yOffset;
              else
                childData.yOffset = yOffset - (childData.height / 2);
              end
              yOffset = yOffset + v - childData.height;
            end
            WeakAuras.Add(childData);
          end
        end

        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
      end
    },
  border_header = {
    type = "header",
    name = L["Border Settings"],
    order = 46.0
  },
    spacer = {
      type = "header",
      name = "",
      order = 50
    }
  };

  -- Positioning options
  options = WeakAuras.AddPositionOptions(options, id, data);

  -- Border options
  options = WeakAuras.AddBorderOptions(options, id, data);

  -- Remove some poition options
  options.width = nil;
  options.height = nil;
  options.selfPoint.disabled = true;
  options.selfPoint.values = {["BOTTOMLEFT"] = "Anchor Point"};

  -- Return options
  return options;
end

-- Create preview thumbnail
local function createThumbnail(parent, fullCreate)
  -- Preview frame
  local borderframe = CreateFrame("FRAME", nil, parent);
  borderframe:SetWidth(32);
  borderframe:SetHeight(32);

  -- Preview border
  local border = borderframe:CreateTexture(nil, "OVERLAY");
  border:SetAllPoints(borderframe);
  border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
  border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

  -- Main region
  local region = CreateFrame("FRAME", nil, borderframe);
  borderframe.region = region;

  -- Preview children
  region.children = {};

  -- Return preview
  return borderframe;
end

-- Modify preview thumbnail
local function modifyThumbnail(parent, borderframe, data, fullModify, size)
  local region = borderframe.region;
  size = size or 24;

  local leftest, rightest, lowest, highest = 0, 0, 0, 0;
  for index, childId in ipairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    if(childData) then
      local blx, bly, trx, try = getRect(childData);
      leftest = math.min(leftest, blx);
      rightest = math.max(rightest, trx);
      lowest = math.min(lowest, bly);
      highest = math.max(highest, try);
    end
  end

  local maxWidth, maxHeight = rightest - leftest, highest - lowest;

  local scale=1;
  if maxHeight > 0 and (maxHeight > maxWidth) then
    scale = size / maxHeight;
  elseif maxWidth > 0 and (maxWidth >= maxHeight) then
    scale = size / maxWidth;
  end

  region:SetPoint("CENTER", borderframe, "CENTER");
  region:SetWidth(maxWidth * scale);
  region:SetHeight(maxHeight * scale);

  for index, childId in pairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    if(childData) then
      if not(region.children[index]) then
        region.children[index] = CreateFrame("FRAME", nil, region);
        region.children[index].texture = region.children[index]:CreateTexture(nil, "ARTWORK");
        region.children[index].texture:SetAllPoints(region.children[index]);
      end
      region.children[index]:Show();
      local r, g, b;
      if(childData.color) then
        r, g, b = childData.color[1], childData.color[2], childData.color[3];
      end
      if(childData.barColor and not(r and g and b)) then
        r, g, b = childData.barColor[1], childData.barColor[2], childData.barColor[3];
      end
      if(childData.foregroundColor and not(r and g and b)) then
        r, g, b = childData.foregroundColor[1], childData.foregroundColor[2], childData.foregroundColor[3];
      end
      if not(r and g and b) then
        r, g, b = 0.2, 0.8, 0.2;
      end
      region.children[index].texture:SetColorTexture(r, g, b, 0.5);

      local blx, bly, trx, try = getRect(childData);

      region.children[index]:ClearAllPoints();
      region.children[index]:SetPoint("BOTTOMLEFT", region, "BOTTOMLEFT", (blx - leftest) * scale, (bly - lowest) * scale);
      region.children[index]:SetWidth(childData.width * scale);
      region.children[index]:SetHeight(childData.height * scale);
    end
  end
  for i=#data.controlledChildren+1,#region.children do
    region.children[i]:Hide();
  end
end

-- Create "new region" preview
local function createIcon()
  local thumbnail = createThumbnail(UIParent);
  local t1 = thumbnail:CreateTexture(nil, "ARTWORK");
  t1:SetWidth(24);
  t1:SetHeight(8);
  t1:SetColorTexture(0.8, 0, 0, 0.5);
  t1:SetPoint("TOP", thumbnail, "TOP", 0, -6);
  local t2 = thumbnail:CreateTexture(nil, "ARTWORK");
  t2:SetWidth(20);
  t2:SetHeight(20);
  t2:SetColorTexture(0.2, 0.8, 0.2, 0.5);
  t2:SetPoint("TOP", t1, "BOTTOM", 0, 5);
  local t3 = thumbnail:CreateTexture(nil, "ARTWORK");
  t3:SetWidth(20);
  t3:SetHeight(12);
  t3:SetColorTexture(0.1, 0.25, 1, 0.5);
  t3:SetPoint("TOP", t2, "BOTTOM", -5, 8);

  return thumbnail;
end

-- Register new region type options with WeakAuras
WeakAuras.RegisterRegionOptions("group", createOptions, createIcon, L["Group"], createThumbnail, modifyThumbnail, L["Controls the positioning and configuration of multiple displays at the same time"]);
local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

-- GLOBALS: WeakAuras UIParent AceGUIWidgetLSMlists

local function createOptions(id, data)
  local options = {
    grow = {
      type = "select",
      name = L["Grow"],
      order = 5,
      values = WeakAuras.grow_types
    },
    align = {
      type = "select",
      name = L["Align"],
      order = 10,
      values = WeakAuras.align_types,
      hidden = function() return (data.grow == "LEFT" or data.grow == "RIGHT" or data.grow == "HORIZONTAL" or data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") end,
      disabled = function() return data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE" end
    },
    rotated_align = {
      type = "select",
      name = L["Align"],
      order = 10,
      values = WeakAuras.rotated_align_types,
      hidden = function() return (data.grow == "UP" or data.grow == "DOWN" or data.grow == "VERTICAL" or data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") end,
      get = function() return data.align; end,
      set = function(info, v) data.align = v; WeakAuras.Add(data); end
    },
    constantFactor = {
      type = "select",
      name = L["Constant Factor"],
      order = 10,
      values = WeakAuras.circular_group_constant_factor_types,
      hidden = function() return data.grow ~= "CIRCLE" or data.grow == "COUNTERCIRCLE" end
    },
    space = {
      type = "range",
      name = L["Space"],
      order = 15,
      softMin = 0,
      softMax = 300,
      bigStep = 1,
      hidden = function() return (data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") and data.constantFactor == "RADIUS" end
    },
    rotation = {
      type = "range",
      name = L["Rotation"],
      order = 15,
      min = 0,
      max = 360,
      bigStep = 3,
      hidden = function() return data.grow ~= "CIRCLE" and data.grow ~= "COUNTERCIRCLE" end
    },
    stagger = {
      type = "range",
      name = L["Stagger"],
      order = 20,
      min = -50,
      max = 50,
      step = 0.1,
      bigStep = 1,
      hidden = function() return data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE" end
    },
    radius = {
      type = "range",
      name = L["Radius"],
      order = 20,
      softMin = 0,
      softMax = 500,
      bigStep = 1,
      hidden = function() return not((data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") and data.constantFactor == "RADIUS") end
    },
    animate = {
      type = "toggle",
      width = "double",
      name = L["Animated Expand and Collapse"],
      order = 30
    },
    border = {
      type = "select",
      dialogControl = "LSM30_Border",
      name = L["Border"],
      order = 35,
      values = AceGUIWidgetLSMlists.border
    },
    background = {
      type = "select",
      dialogControl = "LSM30_Background",
      name = L["Background"],
      order = 40,
      values = function()
        local list = {};
        for i,v in pairs(AceGUIWidgetLSMlists.background) do
          list[i] = v;
        end
        list["None"] = L["None"];

        return list;
      end
    },
    borderOffset = {
      type = "range",
      name = L["Border Offset"],
      order = 45,
      softMin = 0,
      softMax = 32,
      bigStep = 1
    },
    backgroundInset = {
      type = "range",
      name = L["Background Inset"],
      order = 47,
      softMin = 0,
      softMax = 32,
      bigStep = 1
    },
    sort = {
      type = "select",
      name = L["Sort"],
      order = 48,
      values = WeakAuras.group_sort_types
    },
    hybridPosition = {
      type = "select",
      name = L["Hybrid Position"],
      order = 48.1,
      values = WeakAuras.group_hybrid_position_types,
      hidden = function() return not(data.sort == "hybrid") end,
    },
    hybridSortMode = {
      type = "select",
      name = L["Hybrid Sort Mode"],
      order = 48.2,
      values = WeakAuras.group_hybrid_sort_types,
      hidden = function() return not(data.sort == "hybrid") end,
    },
    sortHybrid = {
            type = "multiselect",
            name = L["Select the auras you always want to be listed first"],
            order = 49,
            hidden = function() return not(data.sort == "hybrid") end,
            values = function()
				return data.controlledChildren
            end,
            get = function(info, id)
				return data.sortHybridTable and data.sortHybridTable [id] or false;
            end,
            set = function(info, id)
				if not data.sortHybridTable then data.sortHybridTable = {}; end
					local cur = data.sortHybridTable and data.sortHybridTable[id] or false;
                    data.sortHybridTable[id] = not(cur);
            end,
    },
    spacer = {
      type = "header",
      name = "",
      order = 50
    }
  };
  options = WeakAuras.AddPositionOptions(options, id, data);

  options.width = nil;
  options.height = nil;
  options.selfPoint.disabled = true;

  return options;
end

local function createThumbnail(parent, fullCreate)
  local borderframe = CreateFrame("FRAME", nil, parent);
  borderframe:SetWidth(32);
  borderframe:SetHeight(32);

  local border = borderframe:CreateTexture(nil, "OVERLAY");
  border:SetAllPoints(borderframe);
  border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
  border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

  local region = CreateFrame("FRAME", nil, borderframe);
  borderframe.region = region;

  region.children = {};

  return borderframe;
end

local function modifyThumbnail(parent, borderframe, data, fullModify, size)
  local region = borderframe.region;
  size = size or 24;

  local selfPoint,actualSelfPoint;
  if(data.grow == "RIGHT" or data.grow == "HORIZONTAL") then
    selfPoint = "LEFT";
    if(data.align == "LEFT") then
      selfPoint = "TOP"..selfPoint;
    elseif(data.align == "RIGHT") then
      selfPoint = "BOTTOM"..selfPoint;
    end
  elseif(data.grow == "LEFT") then
    selfPoint = "RIGHT";
    if(data.align == "LEFT") then
      selfPoint = "TOP"..selfPoint;
    elseif(data.align == "RIGHT") then
      selfPoint = "BOTTOM"..selfPoint;
    end
  elseif(data.grow == "UP") then
    selfPoint = "BOTTOM";
    if(data.align == "LEFT") then
      selfPoint = selfPoint.."LEFT";
    elseif(data.align == "RIGHT") then
      selfPoint = selfPoint.."RIGHT";
    end
  elseif(data.grow == "DOWN" or data.grow == "VERTICAL") then
    selfPoint = "TOP";
    if(data.align == "LEFT") then
      selfPoint = selfPoint.."LEFT";
    elseif(data.align == "RIGHT") then
      selfPoint = selfPoint.."RIGHT";
    end
  elseif(data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") then
    selfPoint = "CENTER";
    actualSelfPoint = "CENTER";
  end
  data.selfPoint = selfPoint;

  local maxWidth, maxHeight = 0, 0;
  local radius = 0;
  if(data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") then
    if(data.constantFactor == "RADIUS") then
      radius = data.radius;
    else
      if(#data.controlledChildren == 1) then
        radius = 0;
      else
        radius = (#data.controlledChildren * data.space) / (2 * math.pi)
      end
    end
  end
  for index, childId in ipairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    if(childData) then
      if(data.grow == "LEFT" or data.grow == "RIGHT" or data.grow == "HORIZONTAL") then
        maxWidth = maxWidth + childData.width;
        maxWidth = maxWidth + (index > 1 and data.space or 0);
        maxHeight = math.max(maxHeight, childData.height);
      elseif(data.grow == "UP" or data.grow == "DOWN" or data.grow == "VERTICAL") then
        maxHeight = maxHeight + childData.height;
        maxHeight = maxHeight + (index > 1 and data.space or 0);
        maxWidth = math.max(maxWidth, childData.width);
      elseif(data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") then
        maxWidth = math.max(maxWidth, childData.width);
        maxHeight = math.max(maxHeight, childData.height);
      end
    end
  end
  if(data.grow == "LEFT" or data.grow == "RIGHT" or data.grow == "HORIZONTAL") then
    maxHeight = maxHeight + (math.abs(data.stagger) * (#data.controlledChildren - 1));
  elseif(data.grow == "UP" or data.grow == "DOWN" or data.grow == "VERTICAL") then
    maxWidth = maxWidth + (math.abs(data.stagger) * (#data.controlledChildren - 1));
  elseif(data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") then
    maxWidth = maxWidth + (2 * radius);
    maxHeight = maxHeight + (2 * radius);
  end

  local scale=1;
  if maxHeight > 0 and (maxHeight > maxWidth) then
    scale = size / maxHeight;
  elseif maxWidth > 0 and (maxWidth >= maxHeight) then
    scale = size / maxWidth;
  end

  region:SetPoint("CENTER", borderframe, "CENTER");
  region:SetWidth(maxWidth * scale);
  region:SetHeight(maxHeight * scale);

  local xOffset, yOffset = 0, 0;
  if(math.abs(data.stagger) > 0.1 and not (data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE")) then
    if(data.grow == "RIGHT" or data.grow == "LEFT" or data.grow == "HORIZONTAL") then
      if(data.align == "LEFT" and data.stagger > 0) then
        yOffset = yOffset - (data.stagger * (#data.controlledChildren - 1));
      elseif(data.align == "RIGHT" and data.stagger < 0) then
        yOffset = yOffset - (data.stagger * (#data.controlledChildren - 1));
      elseif(data.align == "CENTER") then
        if(data.stagger < 0) then
          yOffset = yOffset - (data.stagger * (#data.controlledChildren - 1) / 2);
        else
          yOffset = yOffset - (data.stagger * (#data.controlledChildren - 1) / 2);
        end
      end
    else
      if(data.align == "LEFT" and data.stagger < 0) then
        xOffset = xOffset - (data.stagger * (#data.controlledChildren - 1));
      elseif(data.align == "RIGHT" and data.stagger > 0) then
        xOffset = xOffset - (data.stagger * (#data.controlledChildren - 1));
      elseif(data.align == "CENTER") then
        if(data.stagger < 0) then
          xOffset = xOffset - (data.stagger * (#data.controlledChildren - 1) / 2);
        else
          xOffset = xOffset - (data.stagger * (#data.controlledChildren - 1) / 2);
        end
      end
    end
  end

  local angle = data.rotation or 0;
  local angleInc = 360 / (#data.controlledChildren ~= 0 and #data.controlledChildren or 1);
  if (data.grow == "COUNTERCIRCLE") then
    angleInc = -angleInc;
  end
  local radius = 0;
  if(data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") then
    if(data.constantFactor == "RADIUS") then
      radius = data.radius;
    else
      if(#data.controlledChildren <= 1) then
        radius = 0;
      else
        radius = (#data.controlledChildren * data.space) / (2 * math.pi);
      end
    end
  end
  for index, childId in pairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    if(childData) then
      if(data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") then
        yOffset = cos(angle) * radius * -1;
        xOffset = sin(angle) * radius;
        angle = angle + angleInc;
      end
      if not(region.children[index]) then
        region.children[index] = CreateFrame("FRAME", nil, region);
        region.children[index].texture = region.children[index]:CreateTexture(nil, "OVERLAY");
        region.children[index].texture:SetAllPoints(region.children[index]);
      end
      local r, g, b;
      if(childData.color) then
        r, g, b = childData.color[1], childData.color[2], childData.color[3];
      elseif(childData.barColor) then
        r, g, b = childData.barColor[1], childData.barColor[2], childData.barColor[3];
      elseif(childData.foregroundColor) then
        r, g, b = childData.foregroundColor[1], childData.foregroundColor[2], childData.foregroundColor[3];
      end
      r, g, b = r or 0.2, g or 0.8, b or 0.2;

      region.children[index].texture:SetColorTexture(r, g, b);

      region.children[index]:ClearAllPoints();
      region.children[index]:SetPoint(selfPoint, region, selfPoint, xOffset * scale, yOffset * scale);
      region.children[index]:SetWidth(childData.width * scale);
      region.children[index]:SetHeight(childData.height * scale);
      if(data.grow == "RIGHT" or data.grow == "HORIZONTAL") then
        xOffset = xOffset + (childData.width + data.space);
        yOffset = yOffset + data.stagger;
      elseif(data.grow == "LEFT") then
        xOffset = xOffset - (childData.width + data.space);
        yOffset = yOffset + data.stagger;
      elseif(data.grow == "UP") then
        yOffset = yOffset + (childData.height + data.space);
        xOffset = xOffset + data.stagger;
      elseif(data.grow == "DOWN" or data.grow == "VERTICAL") then
        yOffset = yOffset - (childData.height + data.space);
        xOffset = xOffset + data.stagger;
      end
    end
  end

  local index = #data.controlledChildren + 1;
  if not(region.children[index]) then
    region.children[index] = CreateFrame("FRAME", nil, region);
    region.children[index].texture = region.children[index]:CreateTexture(nil, "OVERLAY");
    region.children[index].texture:SetAllPoints(region.children[index]);
  end
  region.children[index].texture:SetColorTexture(1, 1, 1);
  region.children[index]:ClearAllPoints();
  if(data.grow == "RIGHT" or data.grow == "LEFT" or data.grow == "HORIZONTAL") then
    region.children[index]:SetWidth(size);
    region.children[index]:SetHeight(1);
    if(data.align == "LEFT") then
      region.children[index]:SetPoint("CENTER", region, "TOP");
    elseif(data.align == "RIGHT") then
      region.children[index]:SetPoint("CENTER", region, "BOTTOM");
    else
      region.children[index]:SetPoint("CENTER", region, "CENTER");
    end
  elseif(data.grow == "UP" or data.grow == "DOWN" or data.grow == "VERTICAL") then
    region.children[index]:SetWidth(1);
    region.children[index]:SetHeight(size);
    if(data.align == "LEFT") then
      region.children[index]:SetPoint("CENTER", region, "LEFT");
    elseif(data.align == "RIGHT") then
      region.children[index]:SetPoint("CENTER", region, "RIGHT");
    else
      region.children[index]:SetPoint("CENTER", region, "CENTER");
    end
  elseif(data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") then
    region.children[index]:SetWidth(1);
    region.children[index]:SetHeight(1);
    region.children[index]:SetPoint("CENTER", region, "CENTER");
  end
end

local function createIcon()
  local thumbnail = createThumbnail(UIParent);
  local t1 = thumbnail:CreateTexture(nil, "ARTWORK");
  t1:SetWidth(24);
  t1:SetHeight(6);
  t1:SetColorTexture(0.8, 0, 0);
  t1:SetPoint("TOP", thumbnail, "TOP", 0, -6);
  local t2 = thumbnail:CreateTexture(nil, "ARTWORK");
  t2:SetWidth(12);
  t2:SetHeight(12);
  t2:SetColorTexture(0.2, 0.8, 0.2);
  t2:SetPoint("TOP", t1, "BOTTOM", 0, -2);
  local t3 = thumbnail:CreateTexture(nil, "ARTWORK");
  t3:SetWidth(30);
  t3:SetHeight(4);
  t3:SetColorTexture(0.1, 0.25, 1);
  t3:SetPoint("TOP", t2, "BOTTOM", 0, -2);
  local t4 = thumbnail:CreateTexture(nil, "OVERLAY");
  t4:SetWidth(1);
  t4:SetHeight(36);
  t4:SetColorTexture(1, 1, 1);
  t4:SetPoint("CENTER", thumbnail, "CENTER");

  thumbnail.elapsed = 0;
  thumbnail:SetScript("OnUpdate", function(self, elapsed)
    self.elapsed = self.elapsed + elapsed;
    if(self.elapsed < 0.5) then
      t2:SetPoint("TOP", t1, "BOTTOM", 0, -2 + (28 * self.elapsed));
      t2:SetAlpha(1 - (2 * self.elapsed));
    elseif(self.elapsed < 1.5) then
      -- do nothing
    elseif(self.elapsed < 2) then
      t2:SetPoint("TOP", t1, "BOTTOM", 0, -2 + (28 * (2 - self.elapsed)));
      t2:SetAlpha((2 * self.elapsed) - 3);
    elseif(self.elapsed < 3) then
      -- do nothing
    else
      self.elapsed = self.elapsed - 3;
    end
  end);
  return thumbnail;
end

WeakAuras.RegisterRegionOptions("dynamicgroup", createOptions, createIcon, L["Dynamic Group"], createThumbnail, modifyThumbnail, L["A group that dynamically controls the positioning of its children"]);

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

-- GLOBALS: WeakAuras UIParent AceGUIWidgetLSMlists

-- Create region options table

local function createOptions(id, data)
    local options = {
        model_path = {
            type = "input",
            width = "double",
            name = L["Model"],
            order = 0
        },
        space2 = {
            type = "execute",
            name = "",
            order = 1,
            image = function() return "", 0, 0 end,
            hidden = function() return data.modelIsUnit end
        },
        chooseModel = {
            type = "execute",
            name = L["Choose"],
            order = 2,
            func = function()
                WeakAuras.OpenModelPicker(data, "model_path");
            end,
            hidden = function() return data.modelIsUnit end
        },
        modelIsUnit = {
            type = "toggle",
            name = L["Show model of unit "],
            order = 3
        },
        portraitZoom = {
            type = "toggle",
            name = L["Portrait Zoom"],
            order = 4,
        },
        advance = {
            type = "toggle",
            name = L["Animate"],
            order = 5,
        },
        sequence = {
            type = "range",
            name = L["Animation Sequence"],
            min = 0,
            max = 150,
            step = 1,
            bigStep = 1,
            order = 6,
            disabled = function() return not data.advance end
        },
        api = {
            type = "toggle",
            name = L["Use SetTransform api"],
            order = 7,

        },
        -- Old settings
        model_z = {
            type = "range",
            name = L["Z Offset"],
            softMin = -20,
            softMax = 20,
            step = .001,
            bigStep = 0.05,
            order = 20,
            hidden = function() return data.api end
        },
        model_x = {
            type = "range",
            name = L["X Offset"],
            softMin = -20,
            softMax = 20,
            step = .001,
            bigStep = 0.05,
            order = 30,
            hidden = function() return data.api end
        },
        model_y = {
            type = "range",
            name = L["Y Offset"],
            softMin = -20,
            softMax = 20,
            step = .001,
            bigStep = 0.05,
            order = 40,
            hidden = function() return data.api end
        },
        rotation = {
            type = "range",
            name = L["Rotation"],
            min = 0,
            max = 360,
            step = 1,
            bigStep = 3,
            order = 45,
            hidden = function() return data.api end
        },
        -- New Settings
        model_st_tx = {
            type = "range",
            name = L["X Offset"],
            softMin = -1000,
            softMax = 1000,
            step = 1,
            bigStep = 5,
            order = 20,
            hidden = function() return not data.api end
        },
        model_st_ty = {
            type = "range",
            name = L["Y Offset"],
            softMin = -1000,
            softMax = 1000,
            step = 1,
            bigStep = 5,
            order = 21,
            hidden = function() return not data.api end
        },
        model_st_tz = {
            type = "range",
            name = L["Z Offset"],
            softMin = -1000,
            softMax = 1000,
            step = 1,
            bigStep = 5,
            order = 22,
            hidden = function() return not data.api end
        },
        model_st_rx = {
            type = "range",
            name = L["X Rotation"],
            min = 0,
            max = 360,
            step = 1,
            bigStep = 3,
            order = 23,
            hidden = function() return not data.api end
        },
        model_st_ry = {
            type = "range",
            name = L["Y Rotation"],
            min = 0,
            max = 360,
            step = 1,
            bigStep = 3,
            order = 24,
            hidden = function() return not data.api end
        },
        model_st_rz = {
            type = "range",
            name = L["Z Rotation"],
            min = 0,
            max = 360,
            step = 1,
            bigStep = 3,
            order = 25,
            hidden = function() return not data.api end
        },
        model_st_us = {
            type = "range",
            name = L["Scale"],
            min = 5,
            max = 1000,
            step = 0.1,
            bigStep = 5,
            order = 26,
            hidden = function() return not data.api end
        },
		border_header = {
			type = "header",
			name = L["Border Settings"],
			order = 46
		},
        spacer = {
            type = "header",
            name = "",
            order = 50
        }
    };

	--
    options = WeakAuras.AddPositionOptions(options, id, data);

	--
	options = WeakAuras.AddBorderOptions(options, id, data);

	--
    return options;
end

local function createThumbnail(parent, fullCreate)
    local borderframe = CreateFrame("FRAME", nil, parent);
    borderframe:SetWidth(32);
    borderframe:SetHeight(32);

    local border = borderframe:CreateTexture(nil, "Overlay");
    border:SetAllPoints(borderframe);
    border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
    border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

    local model = CreateFrame("PlayerModel", nil, WeakAuras.OptionsFrame() or UIParent);
    borderframe.model = model;
    model:SetFrameStrata("FULLSCREEN");

    return borderframe;
end

local function modifyThumbnail(parent, region, data, fullModify, size)
    local model = region.model
    model:SetParent(region);
    model:SetAllPoints(region);
    model:SetFrameStrata(region:GetParent():GetFrameStrata());
    model:SetWidth(region:GetWidth() - 2);
    model:SetHeight(region:GetHeight() - 2);
    model:SetPoint("center", region, "center");
	if tonumber(data.model_path) then
		model:SetDisplayInfo(tonumber(data.model_path))
	else
		if (data.modelIsUnit) then
			model:SetUnit(data.model_path)
		else
			pcall(function() model:SetModel(data.model_path) end);
		end
	end
    model:SetScript("OnShow", function()
		if tonumber(data.model_path) then
			model:SetDisplayInfo(tonumber(data.model_path))
		else
			if (data.modelIsUnit) then
				model:SetUnit(data.model_path)
			else
				pcall(function() model:SetModel(data.model_path) end);
			end
      model:SetPortraitZoom(data.portraitZoom and 1 or 0);
		end

    if (data.api) then
      model:SetTransform(data.model_st_tx / 1000, data.model_st_ty / 1000, data.model_st_tz / 1000,
                         rad(data.model_st_rx), rad(data.model_st_ry), rad(data.model_st_rz),
                         data.model_st_us / 1000);
    else
      model:ClearTransform();
      model:SetPosition(data.model_z, data.model_x, data.model_y);
      model:SetFacing(rad(data.rotation));
    end
    end);

    if (data.api) then
      model:SetTransform(data.model_st_tx / 1000, data.model_st_ty / 1000, data.model_st_tz / 1000,
                         rad(data.model_st_rx), rad(data.model_st_ry), rad(data.model_st_rz),
                         data.model_st_us / 1000);
    else
      model:SetPosition(data.model_z, data.model_x, data.model_y);
      model:SetFacing(rad(data.rotation));
    end
end

local function createIcon()
    local data = {
        model_path = "Creature/Arthaslichking/arthaslichking.m2",
        modelIsUnit = false,
        model_x = 0,
        model_y = 0,
        model_z = 0.35,
        sequence = 1,
        advance = false,
        rotation = 0,
        scale = 1,
        height = 40,
        width = 40
    };

    local thumbnail = createThumbnail(UIParent);
    modifyThumbnail(UIParent, thumbnail, data, nil, 50);

    return thumbnail;
end

local templates = {
  {
    title = L["Default"],
    data = {
    };
  },
  {
    title = L["Fire Orb"],
    description = L[""],
    data = {
      width = 100,
      height = 100,
      model_path = "spells/6fx_smallfire.m2",
      model_x = 0,
      model_y = -0.5,
      model_z = -1.5
    },
  },
  {
    title = L["Blue Sparkle Orb"],
    description = L[""],
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_path = "spells/7fx_druid_halfmoon_missile.m2",
      model_x = 0,
      model_y = 0.7,
      model_z = 1.5
    },
  },
  {
    title = L["Arcane Orb"],
    description = L[""],
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_path = "spells/proc_arcane_impact_low.m2",
      model_x = 0,
      model_y = 0.8,
      model_z = 2
    },
  },
  {
    title = L["Orange Rune"],
    description = L[""],
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_path = "spells/7fx_godking_orangerune_state.m2",
    },
  },
  {
    title = L["Blue Rune"],
    description = L[""],
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_path = "spells/7fx_godking_bluerune_state.m2",
    }
  },
  {
    title = L["Yellow Rune"],
    description = L[""],
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_path = "spells/7fx_godking_yellowrune_state.m2",
    }
  },
  {
    title = L["Purple Rune"],
    description = L[""],
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_path = "spells/7fx_godking_purplerune_state.m2",
    }
  },
  {
    title = L["Green Rune"],
    description = L[""],
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_path = "spells/7fx_godking_greenrune_state.m2",
    }
  },
}

WeakAuras.RegisterRegionOptions("model", createOptions, createIcon, L["Model"], createThumbnail, modifyThumbnail, L["Shows a 3D model from the game files"], templates);

local L = WeakAuras.L;

-- GLOBALS: WeakAuras UIParent AceGUIWidgetLSMlists

local function createOptions(id, data)
    local options = {
        foregroundTexture = {
            type = "input",
            name = L["Foreground Texture"],
            order = 0
        },
        backgroundTexture = {
            type = "input",
            name = L["Background Texture"],
            order = 5,
            disabled = function() return data.sameTexture; end,
            get = function() return data.sameTexture and data.foregroundTexture or data.backgroundTexture; end
        },
        mirror = {
            type = "toggle",
            width = "half",
            name = L["Mirror"],
            order = 10,
            disabled = function() return data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE"; end
        },
        chooseForegroundTexture = {
            type = "execute",
            name = L["Choose"],
            width = "half",
            order = 12,
            func = function()
                WeakAuras.OpenTexturePicker(data, "foregroundTexture", WeakAuras.texture_types);
            end
        },
        sameTexture = {
            type = "toggle",
            name = L["Same"],
            width = "half",
            order = 15
        },
        chooseBackgroundTexture = {
            type = "execute",
            name = L["Choose"],
            width = "half",
            order = 17,
            func = function()
                WeakAuras.OpenTexturePicker(data, "backgroundTexture", WeakAuras.texture_types);
            end,
            disabled = function() return data.sameTexture; end
        },
		desaturateForeground = {
            type = "toggle",
            name = L["Desaturate"],
            order = 17.5,
        },
		desaturateBackground = {
            type = "toggle",
            name = L["Desaturate"],
            order = 17.6,
        },
        blendMode = {
            type = "select",
            name = L["Blend Mode"],
            order = 20,
            values = WeakAuras.blend_types
        },
        backgroundOffset = {
            type = "range",
            name = L["Background Offset"],
            min = 0,
            softMax = 25,
            bigStep = 1,
            order = 25
        },
        orientation = {
            type = "select",
            name = L["Orientation"],
            order = 35,
            values = WeakAuras.orientation_with_circle_types
        },
        compress = {
            type = "toggle",
            width = "half",
            name = L["Compress"],
            order = 40,
            disabled = function() return data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE"; end
        },
        inverse = {
            type = "toggle",
            width = "half",
            name = L["Inverse"],
            order = 41
        },
        foregroundColor = {
            type = "color",
            name = L["Foreground Color"],
            hasAlpha = true,
            order = 30
        },
        backgroundColor = {
            type = "color",
            name = L["Background Color"],
            hasAlpha = true,
            order = 37
        },
        user_x = {
            type = "range",
            order = 42,
            name = L["Re-center X"],
            min = -0.5,
            max = 0.5,
            bigStep = 0.01,
            hidden = function() return data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE"; end
        },
        user_y = {
            type = "range",
            order = 44,
            name = L["Re-center Y"],
            min = -0.5,
            max = 0.5,
            bigStep = 0.01,
            hidden = function() return data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE"; end
        },
        startAngle = {
            type = "range",
            order = 42,
            name = function() if (data.inverse) then return L["End Angle"] else return L["Start Angle"] end end,
            min = 0,
            max = 360,
            step = 90,
            hidden = function() return data.orientation ~= "CLOCKWISE" and data.orientation ~= "ANTICLOCKWISE"; end
        },
        endAngle = {
            type = "range",
            order = 44,
            name = function() if (data.inverse) then return L["Start Angle"] else return L["End Angle"] end end,
            min = 0,
            max = 360,
            bigStep = 1,
            hidden = function() return data.orientation ~= "CLOCKWISE" and data.orientation ~= "ANTICLOCKWISE"; end
        },
        crop_x = {
            type = "range",
            name = L["Crop X"],
            order = 46,
            min = 0,
            softMax = 2,
            bigStep = 0.01,
            isPercent = true,
            set = function(info, v)
                data.width = data.width * ((1 + data.crop_x) / (1 + v));
                data.crop_x = v;
                WeakAuras.Add(data);
                WeakAuras.SetThumbnail(data);
                WeakAuras.SetIconNames(data);
                if(data.parent) then
                    local parentData = WeakAuras.GetData(data.parent);
                    if(parentData) then
                        WeakAuras.Add(parentData);
                        WeakAuras.SetThumbnail(parentData);
                    end
                end
                WeakAuras.ResetMoverSizer();
            end,
            hidden = function() return data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE"; end
        },
        crop_y = {
            type = "range",
            name = L["Crop Y"],
            order = 47,
            min = 0,
            softMax = 2,
            bigStep = 0.01,
            isPercent = true,
            set = function(info, v)
                data.height = data.height * ((1 + data.crop_y) / (1 + v));
                data.crop_y = v;
                WeakAuras.Add(data);
                WeakAuras.SetThumbnail(data);
                WeakAuras.SetIconNames(data);
                if(data.parent) then
                    local parentData = WeakAuras.GetData(data.parent);
                    if(parentData) then
                        WeakAuras.Add(parentData);
                        WeakAuras.SetThumbnail(parentData);
                    end
                end
                WeakAuras.ResetMoverSizer();
            end,
            hidden = function() return data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE"; end
        },
        crop = {
            type = "range",
            name = L["Crop"],
            order = 47,
            min = 0,
            softMax = 2,
            bigStep = 0.01,
            isPercent = true,
            set = function(info, v)
                data.height = data.height * ((1 + data.crop or 0) / (1 + v));
                data.width = data.width * ((1 + data.crop or 0) / (1 + v));
                data.crop = v;
                WeakAuras.Add(data);
                WeakAuras.SetThumbnail(data);
                WeakAuras.SetIconNames(data);
                if(data.parent) then
                    local parentData = WeakAuras.GetData(data.parent);
                    if(parentData) then
                        WeakAuras.Add(parentData);
                        WeakAuras.SetThumbnail(parentData);
                    end
                end
                WeakAuras.ResetMoverSizer();
            end,
            hidden = function() return data.orientation ~= "CLOCKWISE" and data.orientation ~= "ANTICLOCKWISE"; end
        },
        rotation = {
            type = "range",
            name = L["Rotation"],
            order = 52,
            min = 0,
            max = 360,
            bigStep = 1
        },
        alpha = {
            type = "range",
            name = L["Alpha"],
            order = 48,
            min = 0,
            max = 1,
            bigStep = 0.01,
            isPercent = true
        },
        stickyDuration = {
            type = "toggle",
            name = L["Sticky Duration"],
            desc = L["Prevents duration information from decreasing when an aura refreshes. May cause problems if used with multiple auras with different durations."],
            order = 55
        },
        spacer = {
            type = "header",
            name = "",
            order = 60
        }
    };
    options = WeakAuras.AddPositionOptions(options, id, data);

    return options;
end

-- Credit to CommanderSirow for taking the time to properly craft the ApplyTransform function
-- to the enhance the abilities of Progress Textures.

-- NOTES:
--  Most SetValue() changes are quite equal (among compress/non-compress)
--  (There is no GUI button for mirror_v, but mirror_h)
--  New/Used variables
--   region.user_x (0) - User defined center x-shift [-1, 1]
--   region.user_y (0) - User defined center y-shift [-1, 1]
--   region.mirror_v (false) - Mirroring along x-axis [bool]
--   region.mirror_h (false) - Mirroring along y-axis [bool]
--   region.cos_rotation (1) - cos(ANGLE), precalculated cos-function for given ANGLE [-1, 1]
--   region.sin_rotation (0) - sin(ANGLE), precalculated cos-function for given ANGLE [-1, 1]
--   region.scale (1.0) - user defined scaling [1, INF]
--   region.full_rotation (false) - Allow full rotation [bool]


local function ApplyTransform(x, y, region)
  -- 1) Translate texture-coords to user-defined center
  x = x - 0.5
  y = y - 0.5

  -- 2) Shrink texture by 1/sqrt(2)
  x = x * 1.4142
  y = y * 1.4142

  -- 3) Scale texture by user-defined amount
  x = x / region.scale_x
  y = y / region.scale_y

  -- 4) Apply mirroring if defined
  if region.mirror_h then
	x = -x
  end
  if region.mirror_v then
	y = -y
  end

  -- 5) Rotate texture by user-defined value
  --[[local x_tmp = region.cos_rotation * x - region.sin_rotation * y
  local y_tmp = region.sin_rotation * x + region.cos_rotation * y
  x = x_tmp
  y = y_tmp]]
  x, y = region.cos_rotation * x - region.sin_rotation * y, region.sin_rotation * x + region.cos_rotation * y

  -- 6) Translate texture-coords back to (0,0)
  x = x + 0.5 + region.user_x
  y = y + 0.5 + region.user_y

  -- Return results
  return x, y
end

local function Transform(tx, x, y, angle, aspect) -- Translates texture to x, y and rotates about its center
    local c, s = cos(angle), sin(angle)
    local y, oy = y / aspect, 0.5 / aspect
    local ULx, ULy = 0.5 + (x - 0.5) * c - (y - oy) * s, (oy + (y - oy) * c + (x - 0.5) * s) * aspect
    local LLx, LLy = 0.5 + (x - 0.5) * c - (y + oy) * s, (oy + (y + oy) * c + (x - 0.5) * s) * aspect
    local URx, URy = 0.5 + (x + 0.5) * c - (y - oy) * s, (oy + (y - oy) * c + (x + 0.5) * s) * aspect
    local LRx, LRy = 0.5 + (x + 0.5) * c - (y + oy) * s, (oy + (y + oy) * c + (x + 0.5) * s) * aspect
    tx:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy)
end

local function createThumbnail(parent, fullCreate)
    local borderframe = CreateFrame("FRAME", nil, parent);
    borderframe:SetWidth(32);
    borderframe:SetHeight(32);

    local border = borderframe:CreateTexture(nil, "OVERLAY");
    border:SetAllPoints(borderframe);
    border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
    border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

    local region = CreateFrame("FRAME", nil, borderframe);
    borderframe.region = region;
    region:SetWidth(32);
    region:SetHeight(32);

    local background = region:CreateTexture(nil, "BACKGROUND");
    borderframe.background = background;

    local foreground = region:CreateTexture(nil, "ART");
    borderframe.foreground = foreground;

    borderframe.foregroundSpinner = WeakAuras.createSpinner(borderframe, "ARTWORK", parent:GetFrameLevel() + 2);
    borderframe.backgroundSpinner = WeakAuras.createSpinner(borderframe, "BACKGROUND", parent:GetFrameLevel() + 1);

    return borderframe;
end

local function modifyThumbnail(parent, borderframe, data, fullModify, size)
    local region, background, foreground = borderframe.region, borderframe.background, borderframe.foreground;
    local foregroundSpinner, backgroundSpinner = borderframe.foregroundSpinner, borderframe.backgroundSpinner;

    size = size or 30;
    local scale;
    if(data.height > data.width) then
        scale = size/data.height;
        region:SetWidth(scale * data.width);
        region:SetHeight(size);
        foreground:SetWidth(scale * data.width);
        foreground:SetHeight(size);
        foregroundSpinner:SetWidth(scale * data.width);
        foregroundSpinner:SetHeight(size);
        backgroundSpinner:SetWidth(scale * data.width)
        backgroundSpinner:SetHeight(size);
    else
        scale = size/data.width;
        region:SetWidth(size);
        region:SetHeight(scale * data.height);
        foreground:SetWidth(size);
        foreground:SetHeight(scale * data.height);
        foregroundSpinner:SetWidth(size);
        foregroundSpinner:SetHeight(scale * data.height);
        backgroundSpinner:SetWidth(size)
        backgroundSpinner:SetHeight(scale * data.height);
    end

    region:ClearAllPoints();
    region:SetPoint("CENTER", borderframe, "CENTER");
    region:SetAlpha(data.alpha);

    background:SetTexture(data.sameTexture and data.foregroundTexture or data.backgroundTexture);
    background:SetDesaturated(data.desaturateBackground)
    background:SetVertexColor(data.backgroundColor[1], data.backgroundColor[2], data.backgroundColor[3], data.backgroundColor[4]);
    background:SetBlendMode(data.blendMode);

    backgroundSpinner:SetTexture(data.sameTexture and data.foregroundTexture or data.backgroundTexture);
    backgroundSpinner:SetDesaturated(data.desaturateBackground)
    backgroundSpinner:Color(data.backgroundColor[1], data.backgroundColor[2], data.backgroundColor[3], data.backgroundColor[4]);
    backgroundSpinner:SetBlendMode(data.blendMode);

    foreground:SetTexture(data.foregroundTexture);
    foreground:SetVertexColor(data.foregroundColor[1], data.foregroundColor[2], data.foregroundColor[3], data.foregroundColor[4]);
    foreground:SetBlendMode(data.blendMode);

    foregroundSpinner:SetTexture(data.foregroundTexture);
    foregroundSpinner:SetDesaturated(data.desaturateForeground);
    foregroundSpinner:SetBlendMode(data.blendMode);
    foregroundSpinner:Color(data.foregroundColor[1], data.foregroundColor[2], data.foregroundColor[3], data.foregroundColor[4])

    background:ClearAllPoints();
    foreground:ClearAllPoints();
    background:SetPoint("BOTTOMLEFT", region, "BOTTOMLEFT");
    background:SetPoint("TOPRIGHT", region, "TOPRIGHT");
    backgroundSpinner:SetBackgroundOffset(region, 0);

    region.mirror_h = data.mirror;
    region.scale_x = 1 + (data.crop_x or 0.41);
    region.scale_y = 1 + (data.crop_y or 0.41);
    region.rotation = data.rotation or 0;
    region.cos_rotation = cos(region.rotation);
    region.sin_rotation = sin(region.rotation);
    region.user_x = -1 * (data.user_x or 0);
    region.user_y = data.user_y or 0;
    region.aspect = 1;

    local function orientHorizontal()
        foreground:ClearAllPoints();
        foreground:SetPoint("LEFT", region, "LEFT");
        region.orientation = "HORIZONTAL_INVERSE";
        if(data.compress) then
            function region:SetValue(progress)
                region.progress = progress;

				local ULx, ULy = ApplyTransform(0, 0, region)
				local LLx, LLy = ApplyTransform(0, 1, region)
				local URx, URy = ApplyTransform(1, 0, region)
				local LRx, LRy = ApplyTransform(1, 1, region)

				foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
				foreground:SetWidth(region:GetWidth() * progress);
				background:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
            end
        else
            function region:SetValue(progress)
                region.progress = progress;

				local ULx , ULy  = ApplyTransform(0, 0, region)
				local LLx , LLy  = ApplyTransform(0, 1, region)
				local URx , URy  = ApplyTransform(progress, 0, region)
				local URx_, URy_ = ApplyTransform(1, 0, region)
				local LRx , LRy  = ApplyTransform(progress, 1, region)
				local LRx_, LRy_ = ApplyTransform(1, 1, region)

				foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx , URy , LRx , LRy );
				foreground:SetWidth(region:GetWidth() * progress);
				background:SetTexCoord(ULx, ULy, LLx, LLy, URx_, URy_, LRx_, LRy_);
            end
        end
    end
    local function orientHorizontalInverse()
        foreground:ClearAllPoints();
        foreground:SetPoint("RIGHT", region, "RIGHT");
        region.orientation = "HORIZONTAL";
        if(data.compress) then
            function region:SetValue(progress)
                region.progress = progress;

				local ULx, ULy = ApplyTransform(0, 0, region)
				local LLx, LLy = ApplyTransform(0, 1, region)
				local URx, URy = ApplyTransform(1, 0, region)
				local LRx, LRy = ApplyTransform(1, 1, region)

				foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
				foreground:SetWidth(region:GetWidth() * progress);
				background:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
            end
        else
            function region:SetValue(progress)
                region.progress = progress;

				local ULx , ULy  = ApplyTransform(1-progress, 0, region)
				local ULx_, ULy_ = ApplyTransform(0, 0, region)
				local LLx , LLy  = ApplyTransform(1-progress, 1, region)
				local LLx_, LLy_ = ApplyTransform(0, 1, region)
				local URx , URy  = ApplyTransform(1, 0, region)
				local LRx , LRy  = ApplyTransform(1, 1, region)

				foreground:SetTexCoord(ULx , ULy , LLx , LLy , URx, URy, LRx, LRy);
				foreground:SetWidth(region:GetWidth() * progress);
				background:SetTexCoord(ULx_, ULy_, LLx_, LLy_, URx, URy, LRx, LRy);
            end
        end
    end
    local function orientVertical()
        foreground:ClearAllPoints();
        foreground:SetPoint("BOTTOM", region, "BOTTOM");
        region.orientation = "VERTICAL_INVERSE";
        if(data.compress) then
            function region:SetValue(progress)
                region.progress = progress;


				local ULx, ULy = ApplyTransform(0, 0, region)
				local LLx, LLy = ApplyTransform(0, 1, region)
				local URx, URy = ApplyTransform(1, 0, region)
				local LRx, LRy = ApplyTransform(1, 1, region)

				foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
				foreground:SetHeight(region:GetHeight() * progress);
				background:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
            end
        else
            function region:SetValue(progress)
                region.progress = progress;

				local ULx , ULy  = ApplyTransform(0, 1-progress, region)
				local ULx_, ULy_ = ApplyTransform(0, 0, region)
				local LLx , LLy  = ApplyTransform(0, 1, region)
				local URx , URy  = ApplyTransform(1, 1-progress, region)
				local URx_, URy_ = ApplyTransform(1, 0, region)
				local LRx , LRy  = ApplyTransform(1, 1, region)

				foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
				foreground:SetHeight(region:GetHeight() * progress);
				background:SetTexCoord(ULx_, ULy_, LLx, LLy, URx_, URy_, LRx, LRy);
            end
        end
    end
    local function orientVerticalInverse()
        foreground:ClearAllPoints();
        foreground:SetPoint("TOP", region, "TOP");
        region.orientation = "VERTICAL";
        if(data.compress) then
            function region:SetValue(progress)
                region.progress = progress;


				local ULx, ULy = ApplyTransform(0, 0, region)
				local LLx, LLy = ApplyTransform(0, 1, region)
				local URx, URy = ApplyTransform(1, 0, region)
				local LRx, LRy = ApplyTransform(1, 1, region)

				foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
				foreground:SetHeight(region:GetHeight() * progress);
				background:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
            end
        else
            function region:SetValue(progress)
                region.progress = progress;

				local ULx , ULy  = ApplyTransform(0, 0, region)
				local LLx , LLy  = ApplyTransform(0, progress, region)
				local LLx_, LLy_ = ApplyTransform(0, 1, region)
				local URx , URy  = ApplyTransform(1, 0, region)
				local LRx , LRy  = ApplyTransform(1, progress, region)
				local LRx_, LRy_ = ApplyTransform(1, 1, region)

				foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
				foreground:SetHeight(region:GetHeight() * progress);
				background:SetTexCoord(ULx, ULy, LLx_, LLy_, URx, URy, LRx_, LRy_);
            end
        end
    end

    local function orientCircular(clockwise)
      local startAngle = data.startAngle % 360;
      local endAngle = data.endAngle % 360;

      if (data.inverse) then
        startAngle, endAngle = endAngle, startAngle
        startAngle = 360 - startAngle;
        endAngle = 360 - endAngle;
        clockwise = not clockwise;
      end
      if (endAngle <= startAngle) then
        endAngle = endAngle + 360;
      end

      backgroundSpinner:SetProgress(region, startAngle, endAngle, 0, clockwise);

      function region:SetValue(progress)
        progress = progress or 0;
        region.progress = progress;

        foregroundSpinner:SetProgress(region, startAngle, endAngle, progress, clockwise);
      end
    end

    local function showCircularProgress()
      foreground:Hide();
      background:Hide();
      foregroundSpinner:Show();
      backgroundSpinner:Show();
    end

    local function hideCircularProgress()
      foreground:Show();
      background:Show();
      foregroundSpinner:Hide();
      backgroundSpinner:Hide();
    end

    if(data.orientation == "HORIZONTAL_INVERSE") then
        hideCircularProgress();
        orientHorizontalInverse();
    elseif(data.orientation == "HORIZONTAL") then
        hideCircularProgress();
        orientHorizontal();
    elseif(data.orientation == "VERTICAL_INVERSE") then
        hideCircularProgress();
        orientVerticalInverse();
    elseif(data.orientation == "VERTICAL") then
        hideCircularProgress();
        orientVertical();
    elseif(data.orientation == "CLOCKWISE") then
        showCircularProgress();
        orientCircular(true);
    elseif(data.orientation == "ANTICLOCKWISE") then
        showCircularProgress();
        orientCircular(false);
    end

    if (region.SetValue) then
      region:SetValue(3/5);
    end
end

local function createIcon()
    local data = {
        foregroundTexture = "Textures\\SpellActivationOverlays\\Eclipse_Sun",
        sameTexture = true,
        backgroundOffset = 2,
        blendMode = "BLEND",
        width = 200,
        height = 200,
        orientation = "VERTICAL",
        alpha = 1.0,
        foregroundColor = {1, 1, 1, 1},
        backgroundColor = {0.5, 0.5, 0.5, 0.5}
    };

    local thumbnail = createThumbnail(UIParent);
    modifyThumbnail(UIParent, thumbnail, data, nil, 32);

    thumbnail.elapsed = 0;
    thumbnail:SetScript("OnUpdate", function(self, elapsed)
        thumbnail.elapsed = thumbnail.elapsed + elapsed;
        if(thumbnail.elapsed > 4) then
            thumbnail.elapsed = thumbnail.elapsed - 4;
        end
        thumbnail.region:SetValue((4 - thumbnail.elapsed) / 4);
    end);

    return thumbnail;
end

local templates = {
  {
    title = L["Default"],
    data = {
    };
  },
  {
    title = L["Top HUD position"],
    description = L["At the same position as Blizzard's spell alert"],
    data = {
      width = 200,
      height = 100,
      xOffset = 0,
      yOffset = 150,
      mirror = true,
      foregroundTexture = "Textures\\SpellActivationOverlays\\Backlash",
      orientation = "HORIZONTAL",
    },
  },
  {
    title = L["Left HUD position"],
    description = L["At the same position as Blizzard's spell alert"],
    data = {
      width = 100,
      height = 200,
      xOffset = -150,
      yOffset = 0,
    },
  },
  {
    title = L["Left 2 HUD position"],
    description = L["At a position a bit left of Left HUD position."],
    data = {
      width = 100,
      height = 200,
      xOffset = -200,
      yOffset = 0,
    },
  },
  {
    title = L["Right HUD position"],
    description = L["At the same position as Blizzard's spell alert"],
    data = {
      width = 100,
      height = 200,
      xOffset = 150,
      yOffset = 0,
      mirror = true,
    },
  },
  {
    title = L["Right 2 HUD position"],
    description = L["At a position a bit left of Right HUD position"],
    data = {
      width = 100,
      height = 200,
      xOffset = 200,
      yOffset = 0,
      mirror = true,
    },
  },
}

WeakAuras.RegisterRegionOptions("progresstexture", createOptions, createIcon, L["Progress Texture"], createThumbnail, modifyThumbnail, L["Shows a texture that changes based on duration"], templates);

-- Lua APIs
local select, pairs, next, type, assert, error, coroutine = select, pairs, next, type, assert, error, coroutine

-- WoW APIs
local GetSpellInfo, IsSpellKnown = GetSpellInfo, IsSpellKnown

-- GLOBALS: WeakAuras

local WeakAuras = WeakAuras

local spellCache = {}
WeakAuras.spellCache = spellCache

local cache
local bestIcon = {}
local dynFrame = WeakAuras.dynFrame

-- Builds a cache of name/icon pairs from existing spell data
-- This is a rather slow operation, so it's only done once, and the result is subsequently saved
function spellCache.Build(callback)
  if cache then
    local co = coroutine.create(function()
      local id = 0
      local misses = 0

      while misses < 400 do
        id = id + 1
        local name, _, icon = GetSpellInfo(id)

        if(icon == 136243) then -- 136243 is the a gear icon, we can ignore those spells
          misses = 0;
        elseif name and name ~= "" then
          cache[name] = cache[name] or {}
          cache[name][id] = icon
          misses = 0
        else
          misses = misses + 1
        end

        coroutine.yield()
      end

      if callback then
        callback()
      end
    end)
    dynFrame:AddAction(callback, co)
  else
    error("spellCache has not been loaded. Call WeakAuras.spellCache.Load(...) first.")
  end
end

function spellCache.GetIcon(name)
  if (name == nil) then
    return nil;
  end
  if cache then
    if (bestIcon[name]) then
      return bestIcon[name]
    end

    local icons = cache[name]
    local bestMatch = nil
    if (icons) then
      for spellId, icon in pairs(icons) do
        if (not bestMatch) then
          bestMatch = spellId
        elseif(IsSpellKnown(spellId)) then
          bestMatch = spellId
        end
      end
    end

    bestIcon[name] = bestMatch and icons[bestMatch];
    return bestIcon[name];
  else
    error("spellCache has not been loaded. Call WeakAuras.spellCache.Load(...) first.")
  end
end

function spellCache.AddIcon(name, id, icon)
  if cache then
    if name then
      cache[name] = cache[name] or {}
      if id and icon then
        cache[name][id] = icon
      end
    end
  else
    error("spellCache has not been loaded. Call WeakAuras.spellCache.Load(...) first.")
  end
end

function spellCache.Get()
  if cache then
    return cache
  else
    error("spellCache has not been loaded. Call WeakAuras.spellCache.Load(...) first.")
  end
end

function spellCache.Load(data)
  cache = cache or data
end

-- This function computes the Levenshtein distance between two strings
-- It is used in this program to match spell icon textures with "good" spell names; i.e.,
-- spell names that are very similar to the name of the texture
local function Lev(str1, str2)
  local matrix = {};
  for i=0, str1:len() do
    matrix[i] = {[0] = i};
  end
  for j=0, str2:len() do
    matrix[0][j] = j;
  end
  for j=1, str2:len() do
    for i =1, str1:len() do
      if(str1:sub(i, i) == str2:sub(j, j)) then
        matrix[i][j] = matrix[i-1][j-1];
      else
        matrix[i][j] = math.min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1;
      end
    end
  end

  return matrix[str1:len()][str2:len()];
end

function spellCache.BestKeyMatch(nearkey)
  for key, value in pairs(cache) do
    if(nearkey == key) then
      return key;
    end
  end
  for key, value in pairs(cache) do
    if(nearkey:lower() == key:lower()) then
      return key;
    end
  end
  local bestKey = "";
  local bestDistance = math.huge;
  local partialMatches = {};
  for key, value in pairs(cache) do
    if(key:lower():find(nearkey:lower(), 1, true)) then
      partialMatches[key] = value;
    end
  end
  for key, value in pairs(partialMatches) do
    local distance = Lev(nearkey, key);
    if(distance < bestDistance) then
      bestKey = key;
      bestDistance = distance;
    end
  end

  return bestKey;
end

function spellCache.CorrectAuraName(input)
  if (not cache) then
    error("spellCache has not been loaded. Call WeakAuras.spellCache.Load(...) first.")
  end

  local spellId = tonumber(input);
  if(spellId) then
    local name, _, icon = GetSpellInfo(spellId);
    if(name) then
      spellCache.AddIcon(name, spellId, icon)
      return name, spellId;
    else
      return "Invalid Spell ID";
    end
  else
    local ret = spellCache.BestKeyMatch(input);
    if(ret == "") then
      return "No Match Found", nil;
    else
      return ret, nil;
    end
  end
end

-- Lua APIs
local tinsert, tconcat, tremove, wipe = table.insert, table.concat, table.remove, wipe
local fmt, tostring, string_char, strtrim, strsub = string.format, tostring, string.char, strtrim, strsub
local select, pairs, next, type, unpack = select, pairs, next, type, unpack
local loadstring, assert, error = loadstring, assert, error
local setmetatable, getmetatable, rawset, rawget = setmetatable, getmetatable, rawset, rawget
local bit_band, bit_lshift, bit_rshift = bit.band, bit.lshift, bit.rshift
local coroutine, rad, sqrt, atan2, floor, cos, sin = coroutine, rad, sqrt, atan2, floor, cos, sin
local _G = _G

-- WoW APIs
local InCombatLockdown, IsShiftKeyDown, IsMouseButtonDown, SetCursor, GetMouseFocus, MouseIsOver, ResetCursor
  = InCombatLockdown, IsShiftKeyDown, IsMouseButtonDown, SetCursor, GetMouseFocus, MouseIsOver, ResetCursor
local GetSpellInfo, GetItemInfo, IsSpellKnown, GetItemIcon, UnitName
  = GetSpellInfo, GetItemInfo, IsSpellKnown, GetItemIcon, UnitName
local GetScreenWidth, GetScreenHeight, GetBuildInfo, GetLocale, GetTime, PlaySoundFile, PlaySoundKitID, CreateFrame, GetAddOnInfo, PlaySound, IsAddOnLoaded, LoadAddOn
  = GetScreenWidth, GetScreenHeight, GetBuildInfo, GetLocale, GetTime, PlaySoundFile, PlaySoundKitID, CreateFrame, GetAddOnInfo, PlaySound, IsAddOnLoaded, LoadAddOn

local AceGUI = LibStub("AceGUI-3.0")
local AceConfigDialog = LibStub("AceConfigDialog-3.0")

local WeakAuras = WeakAuras
local L = WeakAuras.L
local ADDON_NAME = "WeakAurasOptions";

-- GLOBALS: WeakAuras WeakAurasSaved WeakAurasOptionsSaved WeakAuras_DropDownMenu WeakAuras_DropIndicator AceGUIWidgetLSMlists
-- GLOBALS: GameTooltip GameTooltip_Hide UIParent FONT_COLOR_CODE_CLOSE RED_FONT_COLOR_CODE
-- GLOBALS: STATICPOPUP_NUMDIALOGS StaticPopupDialogs StaticPopup_Show GetAddOnEnableState

local font_close,yellow_font,red_font = FONT_COLOR_CODE_CLOSE,YELLOW_FONT_COLOR_CODE,RED_FONT_COLOR_CODE
local ValidateNumeric = function(info,val)
  if not tonumber(val) then
    return print(fmt("|cff9900FF"..ADDON_NAME..font_close..":"..yellow_font.." %s"..red_font.." is not a number!",tostring(val)))
  end
  return true
end

local dynFrame = WeakAuras.dynFrame;
WeakAuras.transmitCache = {};

local regionOptions = WeakAuras.regionOptions;
local displayButtons = {};
WeakAuras.displayButtons = displayButtons;
local optionReloads = {};
local optionTriggerChoices = {};
WeakAuras.optionTriggerChoices = optionTriggerChoices;
WeakAuras.thumbnails = {};
local thumbnails = WeakAuras.thumbnails;
local displayOptions = {};
WeakAuras.displayOptions = displayOptions;
local loaded = WeakAuras.loaded;
local spellCache = WeakAuras.spellCache;
local savedVars = {};
WeakAuras.savedVars = savedVars;

local tempGroup = {
  id = {"tempGroup"},
  regionType = "group",
  controlledChildren = {},
  load = {},
  trigger = {},
  anchorPoint = "CENTER",
  anchorFrameType = "SCREEN",
  xOffset = 0,
  yOffset = 0
};
WeakAuras.tempGroup = tempGroup;
function WeakAuras.MultipleDisplayTooltipDesc()
  local desc = {{L["Multiple Displays"], L["Temporary Group"]}};
  for index, id in pairs(tempGroup.controlledChildren) do
    desc[index + 1] = {" ", id};
  end
  desc[2][1] = L["Children:"]
  tinsert(desc, " ");
  tinsert(desc, {" ", "|cFF00FFFF"..L["Right-click for more options"]});
  return desc;
end
function WeakAuras.MultipleDisplayTooltipMenu()
  local menu = {
    {
      text = L["Add to new Group"],
      notCheckable = 1,
      func = function()
        local new_id = tempGroup.controlledChildren[1].." Group";
        local num = 2;
        while(WeakAuras.GetData(new_id)) do
          new_id = "New "..num;
          num = num + 1;
        end

        local data = {
          id = new_id,
          regionType = "group",
          trigger = {},
          load = {}
        };
        WeakAuras.Add(data);
        WeakAuras.NewDisplayButton(data);

        for index, childId in pairs(tempGroup.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          tinsert(data.controlledChildren, childId);
          childData.parent = data.id;
          WeakAuras.Add(data);
          WeakAuras.Add(childData);
        end

        for index, id in pairs(data.controlledChildren) do
          local childButton = WeakAuras.GetDisplayButton(id);
          childButton:SetGroup(data.id, data.regionType == "dynamicgroup");
          childButton:SetGroupOrder(index, #data.controlledChildren);
        end

        local button = WeakAuras.GetDisplayButton(data.id);
        button.callbacks.UpdateExpandButton();
        WeakAuras.UpdateDisplayButton(data);
        WeakAuras.ReloadGroupRegionOptions(data);
        WeakAuras.SortDisplayButtons();
        button:Expand();
      end
    },
    {
      text = L["Add to new Dynamic Group"],
      notCheckable = 1,
      func = function()
        local new_id = tempGroup.controlledChildren[1].." Group";
        local num = 2;
        while(WeakAuras.GetData(new_id)) do
          new_id = "New "..num;
          num = num + 1;
        end

        local data = {
          id = new_id,
          regionType = "dynamicgroup",
          trigger = {},
          load = {}
        };
        WeakAuras.Add(data);
        WeakAuras.NewDisplayButton(data);

        for index, childId in pairs(tempGroup.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          tinsert(data.controlledChildren, childId);
          childData.parent = data.id;
          WeakAuras.Add(data);
          WeakAuras.Add(childData);
        end

        for index, id in pairs(data.controlledChildren) do
          local childButton = WeakAuras.GetDisplayButton(id);
          childButton:SetGroup(data.id, data.regionType == "dynamicgroup");
          childButton:SetGroupOrder(index, #data.controlledChildren);
        end

        local button = WeakAuras.GetDisplayButton(data.id);
        button.callbacks.UpdateExpandButton();
        WeakAuras.UpdateDisplayButton(data);
        WeakAuras.ReloadGroupRegionOptions(data);
        WeakAuras.SortDisplayButtons();
        button:Expand();
        WeakAuras.PickDisplay(new_id);
      end
    },
    {
      text = " ",
      notCheckable = 1,
      notClickable = 1
    },
    {
      text = L["Delete all"],
      notCheckable = 1,
      func = function()
        for index, id in pairs(tempGroup.controlledChildren) do
          local toDelete = {};
          local parents = {};
          for index, id in pairs(tempGroup.controlledChildren) do
            local childData = WeakAuras.GetData(id);
            toDelete[index] = childData;
            if(childData.parent) then
              parents[childData.parent] = true;
            end
          end
          for index, childData in pairs(toDelete) do
            WeakAuras.DeleteOption(childData);
          end
          for id, _ in pairs(parents) do
            local parentData = WeakAuras.GetData(id);
            local parentButton = WeakAuras.GetDisplayButton(id);
            WeakAuras.UpdateGroupOrders(parentData);
            if(#parentData.controlledChildren == 0) then
              parentButton:DisableExpand();
            else
              parentButton:EnableExpand();
            end
            parentButton:SetNormalTooltip();
          end
        end
        WeakAuras.SortDisplayButtons();
      end
    },
    {
      text = " ",
      notClickable = 1,
      notCheckable = 1,
    },
    {
      text = L["Close"],
      notCheckable = 1,
      func = function() WeakAuras_DropDownMenu:Hide() end
    }
  };
  local anyGrouped = false;
  for index, id in pairs(tempGroup.controlledChildren) do
    local childData = WeakAuras.GetData(id);
    if(childData and childData.parent) then
      anyGrouped = true;
      break;
    end
  end
  if(anyGrouped) then
    menu[1].notClickable = 1;
    menu[1].text = "|cFF777777"..menu[1].text;
    menu[2].notClickable = 1;
    menu[2].text = "|cFF777777"..menu[2].text;
  end
  return menu;
end

local trigger_types = WeakAuras.trigger_types;
local debuff_types = WeakAuras.debuff_types;
local unit_types = WeakAuras.unit_types;
local actual_unit_types = WeakAuras.actual_unit_types;
local actual_unit_types_with_specific = WeakAuras.actual_unit_types_with_specific;
local threat_unit_types = WeakAuras.threat_unit_types;
local unit_threat_situations = WeakAuras.unit_threat_situations;
local no_unit_threat_situations = WeakAuras.no_unit_threat_situations;
local class_for_stance_types = WeakAuras.class_for_stance_types;
local class_types = WeakAuras.class_types;
local deathknight_form_types = WeakAuras.deathknight_form_types;
local druid_form_types = WeakAuras.druid_form_types;
local paladin_form_types = WeakAuras.paladin_form_types;
local priest_form_types = WeakAuras.priest_form_types;
local rogue_form_types = WeakAuras.rogue_form_types;
local shaman_form_types = WeakAuras.shaman_form_types;
local warrior_form_types = WeakAuras.warrior_form_types;
local monk_form_types = WeakAuras.monk_form_types;
local single_form_types = WeakAuras.single_form_types;
local blend_types = WeakAuras.blend_types;
local point_types = WeakAuras.point_types;
local event_types = WeakAuras.event_types;
local status_types = WeakAuras.status_types;
local subevent_prefix_types = WeakAuras.subevent_prefix_types;
local subevent_actual_prefix_types = WeakAuras.subevent_actual_prefix_types;
local subevent_suffix_types = WeakAuras.subevent_suffix_types;
local power_types = WeakAuras.power_types;
local miss_types = WeakAuras.miss_types;
local environmental_types = WeakAuras.environmental_types;
local aura_types = WeakAuras.aura_types;
local orientation_types = WeakAuras.orientation_types;
local spec_types = WeakAuras.spec_types;
local totem_types = WeakAuras.totem_types;
local operator_types = WeakAuras.operator_types;
local string_operator_types = WeakAuras.string_operator_types;
local weapon_types = WeakAuras.weapon_types;
local rune_specific_types = WeakAuras.rune_specific_types;
local check_types = WeakAuras.check_types;
local custom_trigger_types = WeakAuras.custom_trigger_types;
local eventend_types = WeakAuras.eventend_types;
local autoeventend_types = WeakAuras.autoeventend_types;
local justify_types = WeakAuras.justify_types;
local grow_types = WeakAuras.grow_types;
local align_types = WeakAuras.align_types;
local rotated_align_types = WeakAuras.rotated_align_types;
local anim_types = WeakAuras.anim_types;
local anim_translate_types = WeakAuras.anim_translate_types;
local anim_scale_types = WeakAuras.anim_scale_types;
local anim_alpha_types = WeakAuras.anim_alpha_types;
local anim_rotate_types = WeakAuras.anim_rotate_types;
local anim_color_types = WeakAuras.anim_color_types;
local group_types = WeakAuras.group_types;
local difficulty_types = WeakAuras.difficulty_types;
local anim_start_preset_types = WeakAuras.anim_start_preset_types;
local anim_main_preset_types = WeakAuras.anim_main_preset_types;
local anim_finish_preset_types = WeakAuras.anim_finish_preset_types;
local chat_message_types = WeakAuras.chat_message_types;
local send_chat_message_types = WeakAuras.send_chat_message_types;
local sound_types = WeakAuras.sound_types;
local duration_types = WeakAuras.duration_types;
local duration_types_no_choice = WeakAuras.duration_types_no_choice;
local group_aura_name_info_types = WeakAuras.group_aura_name_info_types;
local group_aura_stack_info_types = WeakAuras.group_aura_stack_info_types;

local function union(table1, table2)
  local meta = {};
  for i,v in pairs(table1) do
    meta[i] = v;
  end
  for i,v in pairs(table2) do
    meta[i] = v;
  end
  return meta;
end

AceGUI:RegisterLayout("AbsoluteList", function(content, children)
  local yOffset = 0;
  for i = 1, #children do
    local child = children[i]

    local frame = child.frame;
    frame:ClearAllPoints();
    frame:Show();

    frame:SetPoint("LEFT", content);
    frame:SetPoint("RIGHT", content);
    frame:SetPoint("TOP", content, "TOP", 0, yOffset)

    if child.DoLayout then
      child:DoLayout()
    end

    yOffset = yOffset - ((frame.height or frame:GetHeight() or 0) + 2);
  end
  if(content.obj.LayoutFinished) then
    content.obj:LayoutFinished(nil, yOffset * -1);
  end
end);

AceGUI:RegisterLayout("ButtonsScrollLayout", function(content, children)
  local yOffset = 0;
  local scrollTop, scrollBottom = content.obj:GetScrollPos();
  for i = 1, #children do
    local child = children[i]
    local frame = child.frame;

    if not child.dragging then
      local frameHeight = (frame.height or frame:GetHeight() or 0);
      frame:ClearAllPoints();
      if (-yOffset + frameHeight > scrollTop and -yOffset - frameHeight < scrollBottom) then
        frame:Show();
        frame:SetPoint("LEFT", content);
        frame:SetPoint("RIGHT", content);
        frame:SetPoint("TOP", content, "TOP", 0, yOffset)
      else
        frame:Hide();
        frame.yOffset = yOffset
      end
      yOffset = yOffset - (frameHeight + 2);
    end

    if child.DoLayout then
      child:DoLayout()
    end

  end
  if(content.obj.LayoutFinished) then
    content.obj:LayoutFinished(nil, yOffset * -1);
  end
end);

function WeakAuras.ConstructOptions(prototype, data, startorder, subPrefix, subSuffix, triggernum, triggertype, unevent)
  local trigger, untrigger;
  if(data.controlledChildren) then
    trigger, untrigger = {}, {};
  elseif(triggertype == "load") then
    trigger = data.load;
  else
    if(triggernum == 0) then
      data.untrigger = data.untrigger or {};
      if(triggertype == "untrigger") then
        trigger = data.untrigger;
      else
        trigger = data.trigger;
        untrigger = data.untrigger;
      end
    elseif(triggernum >= 1) then
      data.additional_triggers[triggernum].untrigger = data.additional_triggers[triggernum].untrigger or {};
      if(triggertype == "untrigger") then
        trigger = data.additional_triggers[triggernum].untrigger;
      else
        trigger = data.additional_triggers[triggernum].trigger;
        untrigger = data.additional_triggers[triggernum].untrigger;
      end
    else
      error("Improper argument to WeakAuras.ConstructOptions - trigger number not in range");
    end
  end
  unevent = unevent or trigger.unevent;
  local options = {};
  local order = startorder or 10;
  for index, arg in pairs(prototype.args) do
    local hidden = nil;
    if(type(arg.enable) == "function") then
      hidden = function() return not arg.enable(trigger) end;
    end
    local name = arg.name;
    if(name and not arg.hidden) then
      local realname = name;
      if(triggertype == "untrigger") then
        name = "untrigger_"..name;
      end
      if (arg.type == "multiselect") then
        -- Ensure new line for non-toggle options
        options["spacer_"..name] = {
          type = "description",
          name = "",
          order = order,
          hidden = hidden,
        }
        order = order + 1;
      end
      if(arg.type == "tristate") then
        options["use_"..name] = {
          type = "toggle",
          name = function(input)
            local value = trigger["use_"..realname];
            if(value == nil) then return arg.display;
            elseif(value == false) then return "|cFFFF0000 "..L["Negator"].." "..arg.display;
            else return "|cFF00FF00"..arg.display; end
          end,
          get = function()
            local value = trigger["use_"..realname];
            if(value == nil) then return false;
            elseif(value == false) then return "false";
            else return "true"; end
          end,
          set = function(info, v)
            if(v) then
              trigger["use_"..realname] = true;
            else
              local value = trigger["use_"..realname];
              if(value == false) then trigger["use_"..realname] = nil;
              else trigger["use_"..realname] = false end
            end
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end,
          hidden = hidden,
          order = order
        };
      elseif(arg.type == "multiselect") then
        options["use_"..name] = {
          type = "toggle",
          name = arg.display,
          desc = function()
            local v = trigger["use_"..realname];
            if(v == true) then
              return L["Multiselect single tooltip"];
            elseif(v == false) then
              return L["Multiselect multiple tooltip"];
            else
              return L["Multiselect ignored tooltip"];
            end
          end,
          get = function()
            local value = trigger["use_"..realname];
            if(value == nil) then return false;
            elseif(value == false) then return "false";
            else return "true"; end
          end,
          set = function(info, v)
            if(v) then
              trigger["use_"..realname] = true;
            else
              local value = trigger["use_"..realname];
              if(value == false) then trigger["use_"..realname] = nil;
              else
                trigger["use_"..realname] = false
                if(trigger[realname].single) then
                  trigger[realname].multi[trigger[realname].single] = true;
                end
              end
            end
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end,
          hidden = hidden,
          order = order
        };
      else
        options["use_"..name] = {
          type = "toggle",
          name = arg.display,
          order = order,
          hidden = hidden,
          desc = arg.desc,
          get = function() return trigger["use_"..realname]; end,
          set = function(info, v)
            trigger["use_"..realname] = v;
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        };
      end
      if(arg.type == "toggle" or arg.type == "tristate") then
        options["use_"..name].width = arg.width or "double";
      end
      if(arg.required) then
        trigger["use_"..realname] = true;
        if not(triggertype) then
          options["use_"..name].disabled = true;
        else
          options["use_"..name] = nil;
          order = order - 1;
        end
      end
      order = order + 1;
      if(arg.type == "number") then
        options[name.."_operator"] = {
          type = "select",
          name = L["Operator"],
          width = "half",
          order = order,
          hidden = hidden,
          values = operator_types,
          disabled = function() return not trigger["use_"..realname]; end,
          get = function() return trigger["use_"..realname] and trigger[realname.."_operator"] or nil; end,
          set = function(info, v)
            trigger[realname.."_operator"] = v;
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        };
        if(arg.required and not triggertype) then
          options[name.."_operator"].set = function(info, v) trigger[realname.."_operator"] = v; untrigger[realname.."_operator"] = v; WeakAuras.Add(data); WeakAuras.ScanForLoads(); WeakAuras.SortDisplayButtons(); end
        elseif(arg.required and triggertype == "untrigger") then
          options[name.."_operator"] = nil;
          order = order - 1;
        end
        order = order + 1;
        options[name] = {
          type = "input",
          validate = ValidateNumeric,
          name = arg.display,
          width = "half",
          order = order,
          hidden = hidden,
          disabled = function() return not trigger["use_"..realname]; end,
          get = function() return trigger["use_"..realname] and trigger[realname] or nil; end,
          set = function(info, v)
            trigger[realname] = v;
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        };
        if(arg.required and not triggertype) then
          options[name].set = function(info, v) trigger[realname] = v; untrigger[realname] = v; WeakAuras.Add(data); WeakAuras.ScanForLoads(); WeakAuras.SortDisplayButtons(); end
        elseif(arg.required and triggertype == "untrigger") then
          options[name] = nil;
          order = order - 1;
        end
        order = order + 1;
      elseif(arg.type == "string") then
        options[name] = {
          type = "input",
          name = arg.display,
          order = order,
          hidden = hidden,
          disabled = function() return not trigger["use_"..realname]; end,
          get = function() return trigger["use_"..realname] and trigger[realname] or nil; end,
          set = function(info, v)
            trigger[realname] = v;
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        };
        if(arg.required and not triggertype) then
          options[name].set = function(info, v) trigger[realname] = v; untrigger[realname] = v; WeakAuras.Add(data); WeakAuras.ScanForLoads(); WeakAuras.SortDisplayButtons(); end
        elseif(arg.required and triggertype == "untrigger") then
          options[name] = nil;
          order = order - 1;
        end
        order = order + 1;
      elseif(arg.type == "longstring") then
        options[name.."_operator"] = {
          type = "select",
          name = L["Operator"],
          order = order,
          hidden = hidden,
          values = string_operator_types,
          disabled = function() return not trigger["use_"..realname]; end,
          get = function() return trigger["use_"..realname] and trigger[realname.."_operator"] or nil; end,
          set = function(info, v)
            trigger[realname.."_operator"] = v;
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        };
        if(arg.required and not triggertype) then
          options[name.."_operator"].set = function(info, v) trigger[realname.."_operator"] = v; untrigger[realname.."_operator"] = v; WeakAuras.Add(data); WeakAuras.ScanForLoads(); WeakAuras.SortDisplayButtons(); end
        elseif(arg.required and triggertype == "untrigger") then
          options[name.."_operator"] = nil;
          order = order - 1;
        end
        order = order + 1;
        options[name] = {
          type = "input",
          name = arg.display,
          width = "double",
          order = order,
          hidden = hidden,
          disabled = function() return not trigger["use_"..realname]; end,
          get = function() return trigger["use_"..realname] and trigger[realname] or nil; end,
          set = function(info, v)
            trigger[realname] = v;
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        };
        if(arg.required and not triggertype) then
          options[name].set = function(info, v) trigger[realname] = v; untrigger[realname] = v; WeakAuras.Add(data); WeakAuras.ScanForLoads(); WeakAuras.SortDisplayButtons(); end
        elseif(arg.required and triggertype == "untrigger") then
          options[name] = nil;
          order = order - 1;
        end
        order = order + 1;
      elseif(arg.type == "spell" or arg.type == "aura" or arg.type == "item") then
        options["icon"..name] = {
          type = "execute",
          name = "",
          order = order,
          hidden = hidden,
          width = "normal",
          image = function()
            if(trigger["use_"..realname] and trigger[realname]) then
              if(arg.type == "aura") then
                local icon = spellCache.GetIcon(trigger[realname]);
                return icon and tostring(icon) or "", 18, 18;
              elseif(arg.type == "spell") then
                local _, _, icon = GetSpellInfo(trigger[realname]);
                return icon and tostring(icon) or "", 18, 18;
              elseif(arg.type == "item") then
                local _, _, _, _, _, _, _, _, _, icon = GetItemInfo(trigger[realname]);
                return icon and tostring(icon) or "", 18, 18;
              end
            else
              return "", 18, 18;
            end
          end,
          disabled = function() return not ((arg.type == "aura" and trigger[realname] and spellCache.GetIcon(trigger[realname])) or (arg.type == "spell" and trigger[realname] and GetSpellInfo(trigger[realname])) or (arg.type == "item" and trigger[realname] and GetItemIcon(trigger[realname]))) end
        };
        order = order + 1;
        options[name] = {
          type = "input",
          name = arg.display,
          order = order,
          hidden = hidden,
          width = "double",
          disabled = function() return not trigger["use_"..realname]; end,
          get = function()
            if(arg.type == "item") then
              if(trigger["use_"..realname] and trigger[realname] and trigger[realname] ~= "") then
                local name = GetItemInfo(trigger[realname]);
                if(name) then
                  return name;
                else
                  return "Invalid Item Name/ID/Link";
                end
              else
                return nil;
              end
            elseif(arg.type == "spell") then
              if(trigger["use_"..realname] and trigger[realname] and trigger[realname] ~= "") then
                local name = GetSpellInfo(trigger[realname]);
                if(name) then
                  return name;
                else
                  return "Invalid Spell Name/ID/Link";
                end
              else
                return nil;
              end
            else
              return trigger["use_"..realname] and trigger[realname] or nil;
            end
          end,
          set = function(info, v)
            local fixedInput = v;
            if(arg.type == "aura") then
              fixedInput = WeakAuras.spellCache.CorrectAuraName(v);
            elseif(arg.type == "spell") then
              fixedInput = WeakAuras.CorrectSpellName(v);
            elseif(arg.type == "item") then
              fixedInput = WeakAuras.CorrectItemName(v);
            end
            trigger[realname] = fixedInput;
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        };
        if(arg.required and not triggertype) then
          options[name].set = function(info, v)
            local fixedInput = v;
            if(arg.type == "aura") then
              fixedInput = WeakAuras.spellCache.CorrectAuraName(v);
            elseif(arg.type == "spell") then
              fixedInput = WeakAuras.CorrectSpellName(v);
            elseif(arg.type == "item") then
              fixedInput = WeakAuras.CorrectItemName(v);
            end
            trigger[realname] = fixedInput;
            untrigger[realname] = fixedInput;
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        elseif(arg.required and triggertype == "untrigger") then
          options["icon"..name] = nil;
          options[name] = nil;
          order = order - 2;
        end
        order = order + 1;
      elseif(arg.type == "select" or arg.type == "unit") then
        local values;
        if(type(arg.values) == "function") then
          values = arg.values(trigger);
        else
          values = WeakAuras[arg.values];
        end
        options[name] = {
          type = "select",
          name = arg.display,
          order = order,
          hidden = hidden,
          values = values,
          disabled = function() return not trigger["use_"..realname]; end,
          get = function()
            if(arg.type == "unit" and trigger["use_specific_"..realname]) then
              return "member";
            end
            return trigger["use_"..realname] and trigger[realname] or nil;
          end,
          set = function(info, v)
            trigger[realname] = v;
            if(arg.type == "unit" and v == "member") then
              trigger["use_specific_"..realname] = true;
              trigger[realname] = UnitName("player");
            else
              trigger["use_specific_"..realname] = nil;
            end
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        };
        if(arg.required and not triggertype) then
          options[name].set = function(info, v)
            trigger[realname] = v;
            if(arg.type == "unit" and v == "member") then
              trigger["use_specific_"..realname] = true;
            else
              trigger["use_specific_"..realname] = nil;
            end
            untrigger[realname] = v;
            if(arg.type == "unit" and v == "member") then
              untrigger["use_specific_"..realname] = true;
            else
              untrigger["use_specific_"..realname] = nil;
            end
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        elseif(arg.required and triggertype == "untrigger") then
          options[name] = nil;
          order = order - 1;
        end
        if (arg.control) then
          options[name].control = arg.control;
        end
        order = order + 1;
        if(arg.type == "unit" and not (arg.required and triggertype == "untrigger")) then
          options["use_specific_"..name] = {
            type = "toggle",
            name = L["Specific Unit"],
            order = order,
            hidden = function() return (not trigger["use_specific_"..realname]) or (type(hidden) == "function" and hidden(trigger)) or (type(hidden) ~= "function" and hidden) end,
            get = function() return true end,
            set = function(info, v)
              trigger["use_specific_"..realname] = nil;
              options[name].set(info, "player");
            end
          }
          order = order + 1;
          options["specific_"..name] = {
            type = "input",
            name = L["Specific Unit"],
            desc = L["Can be a name or a UID (e.g., party1). Only works on friendly players in your group."],
            order = order,
            hidden = function() return (not trigger["use_specific_"..realname]) or (type(hidden) == "function" and hidden(trigger)) or (type(hidden) ~= "function" and hidden) end,
            get = function() return trigger[realname] end,
            set = function(info, v)
              trigger[realname] = v;
              if(arg.required and not triggertype) then
                untrigger[realname] = v;
              end
              WeakAuras.Add(data);
            end
          };
          order = order + 1;
        end
      elseif(arg.type == "multiselect") then
        local values;
        if(type(arg.values) == "function") then
          values = arg.values(trigger);
        else
          values = WeakAuras[arg.values];
        end
        options[name] = {
          type = "select",
          name = arg.display,
          order = order,
          values = values,
          hidden = function() return hidden or trigger["use_"..realname] == false; end,
          disabled = function() return not trigger["use_"..realname]; end,
          get = function() return trigger["use_"..realname] and trigger[realname] and trigger[realname].single or nil; end,
          set = function(info, v)
            trigger[realname].single = v;
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        };
        if(arg.required and not triggertype) then
          options[name].set = function(info, v)
            trigger[realname].single = v;
            untrigger[realname].single = v;
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        end

        options["multiselect_"..name] = {
          type = "multiselect",
          name = arg.display,
          order = order,
          hidden = function() return hidden or trigger["use_"..realname] ~= false; end,
          values = values,
          -- width = "half",
          get = function(info, v)
            if(trigger["use_"..realname] == false and trigger[realname] and trigger[realname].multi) then
              return trigger[realname].multi[v];
            end
          end,
          set = function(info, v, calledFromSetAll)
            if (calledFromSetAll) then
              trigger[realname].multi[v] = calledFromSetAll;
            elseif(trigger[realname].multi[v]) then
              trigger[realname].multi[v] = nil;
            else
              trigger[realname].multi[v] = true;
            end
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        };
        options["multiselectspace_"..name] = {
          type = "execute",
          name = "",
          order = (order - 0.5),
          hidden = function() return hidden or trigger["use_"..realname] ~= false; end,
          disabled = true,
          image = function() return "", 52, 52 end
        };
        if(arg.required and not triggertype) then
          options[name].set = function(info, v)
            if(trigger[realname].multi[v]) then
              trigger[realname].multi[v] = nil;
            else
              trigger[realname].multi[v] = true;
            end
            if(untrigger[realname].multi[v]) then
              untrigger[realname].multi[v] = nil;
            else
              untrigger[realname].multi[v] = true;
            end
            WeakAuras.Add(data);
            WeakAuras.ScanForLoads();
            WeakAuras.SetThumbnail(data);
            WeakAuras.SetIconNames(data);
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.SortDisplayButtons();
          end
        end

        if(arg.required and triggertype == "untrigger") then
          options[name] = nil;
          options["multiselect_"..name] = nil;
        else
          order = order + 1;
        end
      end
    end
  end

  if not(triggertype or prototype.automaticrequired) then
    options.unevent = {
      type = "select",
      name = L["Hide"],
      width = "double",
      order = order
    };
    order = order + 1;
    if(unevent == "timed") then
      options.unevent.width = "normal";
      options.duration = {
        type = "input",
        name = L["Duration (s)"],
        order = order
      }
      order = order + 1;
    else
      options.unevent.width = "double";
    end
    if(unevent == "custom") then
      local unevent_options = WeakAuras.ConstructOptions(prototype, data, order, subPrefix, subSuffix, triggernum, "untrigger");
      options = union(options, unevent_options);
    end
    if(prototype.automatic) then
      options.unevent.values = autoeventend_types;
    else
      options.unevent.values = eventend_types;
    end
  end

  WeakAuras.option = options;
  return options;
end

local frame;

local db;
local odb;
local options;
local newOptions;
local loadedOptions;
local unloadedOptions;
local pickonupdate;
local reopenAfterCombat = false;
local loadedFrame = CreateFrame("FRAME");
loadedFrame:RegisterEvent("ADDON_LOADED");
loadedFrame:RegisterEvent("PLAYER_REGEN_ENABLED");
loadedFrame:RegisterEvent("PLAYER_REGEN_DISABLED");
loadedFrame:SetScript("OnEvent", function(self, event, addon)
  if (event == "ADDON_LOADED") then
    if(addon == ADDON_NAME) then
      db = WeakAurasSaved;
      WeakAurasOptionsSaved = WeakAurasOptionsSaved or {};

      odb = WeakAurasOptionsSaved;

      -- Remove icon and id cache (replaced with spellCache)
      if (odb.iconCache) then
        odb.iconCache = nil;
      end
      if (odb.idCache) then
        odb.idCache = nil;
      end
      odb.spellCache = odb.spellCache or {};
      spellCache.Load(odb.spellCache);

      local _, build = GetBuildInfo();
      local locale = GetLocale();
      local version = WeakAuras.versionString

      local num = 0;

      for i,v in pairs(odb.spellCache) do
        num = num + 1;
      end

      if(num < 39000 or odb.locale ~= locale or odb.build ~= build or odb.version ~= version) then
        spellCache.Build();

        odb.build = build;
        odb.locale = locale;
        odb.version = version;
      end

      -- Updates the icon cache with whatever icons WeakAuras core has actually used.
      -- This helps keep name<->icon matches relevant.
      for name, icons in pairs(db.dynamicIconCache) do
        if db.dynamicIconCache[name] then
          for spellId, icon in pairs(db.dynamicIconCache[name]) do
            spellCache.AddIcon(name, spellId, icon)
          end
        end
      end
      savedVars.db = db;
      savedVars.odb = odb;
    end
  elseif (event == "PLAYER_REGEN_DISABLED") then
    if(frame and frame:IsVisible()) then
      reopenAfterCombat = true;
      WeakAuras.HideOptions();
    end
  elseif (event == "PLAYER_REGEN_ENABLED") then
    if (reopenAfterCombat) then
      reopenAfterCombat = nil;
      WeakAuras.ShowOptions()
    end
  end
end);

function WeakAuras.DeleteOption(data)
  local id = data.id;
  local parentData;
  if(data.parent) then
    parentData = db.displays[data.parent];
  end

  if(data.controlledChildren) then
    for index, childId in pairs(data.controlledChildren) do
      local childButton = displayButtons[childId];
      if(childButton) then
        childButton:SetGroup();
      end
      local childData = db.displays[childId];
      if(childData) then
        childData.parent = nil;
      end
    end
  end

  WeakAuras.CollapseAllClones(id);

  WeakAuras.Delete(data);
  frame:ClearPicks();
  frame.buttonsScroll:DeleteChild(displayButtons[id]);
  thumbnails[id].region:Hide();
  thumbnails[id] = nil;
  displayButtons[id] = nil;

  if(parentData and parentData.controlledChildren) then
    for index, childId in pairs(parentData.controlledChildren) do
      local childButton = displayButtons[childId];
      if(childButton) then
        childButton:SetGroupOrder(index, #parentData.controlledChildren);
      end
    end
    WeakAuras.Add(parentData);
    WeakAuras.ReloadGroupRegionOptions(parentData);
    WeakAuras.UpdateDisplayButton(parentData);
  end
end

function WeakAuras.OptionsFrame()
  if(frame) then
    return frame;
  else
    return nil;
  end
end

function WeakAuras.ToggleOptions(msg)
  if(frame and frame:IsVisible()) then
    WeakAuras.HideOptions();
  elseif (InCombatLockdown()) then
    print("|cff9900FF".."WeakAuras Options"..FONT_COLOR_CODE_CLOSE.." will open after combat.")
    reopenAfterCombat = true;
  else
    WeakAuras.ShowOptions(msg);
  end
end

function WeakAuras.UpdateCloneConfig(data)
  if(WeakAuras.CanHaveClones(data)) then
    local cloneRegion = WeakAuras.EnsureClone(data.id, 1);
    cloneRegion:Expand();

    cloneRegion = WeakAuras.EnsureClone(data.id, 2);
    cloneRegion:Expand();

    --if(data.parent and WeakAuras.regions[data.parent]) then
    if(data.parent and WeakAuras.regions[data.parent] and
      WeakAuras.regions[data.parent].region and
      WeakAuras.regions[data.parent].region.ControlChildren) then
      WeakAuras.regions[data.parent].region:ControlChildren();
    end

    WeakAuras.SetIconNames(data);
  end
end

function WeakAuras.ShowOptions(msg)
  local firstLoad = not(frame);
  WeakAuras.Pause();

  if (firstLoad) then
    frame = WeakAuras.CreateFrame();
    frame.buttonsScroll.frame:Show();
    WeakAuras.AddOption(tempGroup.id, tempGroup);
    WeakAuras.LayoutDisplayButtons(msg);
  end
  frame.buttonsScroll.frame:Show();
  WeakAuras.LockUpdateInfo();

  if (frame.needsSort) then
    WeakAuras.SortDisplayButtons();
    frame.needsSort = nil;
  end

  frame:Show();
  frame:PickOption("New");
  if not(firstLoad) then
    for id, button in pairs(displayButtons) do
      if(loaded[id] ~= nil) then
        button:PriorityShow(1);
      end
    end
  end

  if (frame.window == "codereview") then
    frame.codereview:Close();
  end

  if (WeakAuras.mouseFrame) then
    WeakAuras.mouseFrame:OptionsOpened();
  end
  if (WeakAuras.personalRessourceDisplayFrame) then
    WeakAuras.personalRessourceDisplayFrame:OptionsOpened();
  end
end

function WeakAuras.HideOptions()
  -- dynFrame:SetScript("OnUpdate", nil);
  WeakAuras.UnlockUpdateInfo();
  WeakAuras.SetDragging()

  if(frame) then
    frame:Hide();
  end

  local tutFrame = WeakAuras.TutorialsFrame and WeakAuras.TutorialsFrame();
  if(tutFrame and tutFrame:IsVisible()) then
    tutFrame:Hide();
  end

  WeakAuras.PauseAllDynamicGroups();

  for id, data in pairs(WeakAuras.regions) do
    data.region:Collapse();
  end

  WeakAuras.ResumeAllDynamicGroups();

  WeakAuras.ReloadAll();
  WeakAuras.Resume();

  if (WeakAuras.mouseFrame) then
    WeakAuras.mouseFrame:OptionsClosed();
  end
  if (WeakAuras.personalRessourceDisplayFrame) then
    WeakAuras.personalRessourceDisplayFrame:OptionsClosed();
  end
end

function WeakAuras.IsOptionsOpen()
  if(frame and frame:IsVisible()) then
    return true;
  else
    return false;
  end
end

function WeakAuras.DoConfigUpdate()
  local function GiveDynamicInfo(id, region, data, cloneNum)
    if(WeakAuras.CanHaveDuration(data) == "timed") then
      local rem = GetTime() + 8 - (frame.count + frame.elapsed);
      if(cloneNum) then
        rem = rem + (cloneNum == 1 and (frame.count >= 1 and 1 or -3) or (frame.count >= 2 and 2 or -2));
      end
      if(region.SetDurationInfo) then
        if not(frame.count ~= 0 and region.cooldown and region.cooldown:IsVisible()) then
          region:SetDurationInfo(12, rem);
        end
      end
    elseif(type(WeakAuras.CanHaveDuration(data)) == "table") then
      local demoValues = WeakAuras.CanHaveDuration(data);
      local current, maximum = demoValues.current or 10, demoValues.maximum or 100;
      if(region.SetDurationInfo) then
        region:SetDurationInfo(current, maximum, true);
      end
    else
      if(region.SetDurationInfo) then
        region:SetDurationInfo(0, math.huge);
      end
    end
  end

  for id, region in pairs(WeakAuras.regions) do
    local data = db.displays[id];
    if(data) then
      GiveDynamicInfo(id, region.region, data);

      if(WeakAuras.clones[id]) then
        for cloneNum, cloneRegion in pairs(WeakAuras.clones[id]) do
          GiveDynamicInfo(id, cloneRegion, data, cloneNum);
        end
      end
    end
  end
end

function WeakAuras.LockUpdateInfo()
  frame.elapsed = 12;
  frame.count = 0;
  frame:SetScript("OnUpdate", function(self, elapsed)
    frame.elapsed = frame.elapsed + elapsed;
    if(frame.elapsed > 1) then
      frame.elapsed = frame.elapsed - 1;
      frame.count = (frame.count + 1) % 4;
      WeakAuras.DoConfigUpdate();
    end
  end);
end

function WeakAuras.UnlockUpdateInfo()
  frame:SetScript("OnUpdate", nil);
end

function WeakAuras.SetIconNames(data)
  if (not thumbnails[data.id]) then return end;
  WeakAuras.SetIconName(data, WeakAuras.regions[data.id].region);
  WeakAuras.SetIconName(data, thumbnails[data.id].region);
  if(WeakAuras.clones[data.id]) then
    for index, cloneRegion in pairs(WeakAuras.clones[data.id]) do
      WeakAuras.SetIconName(data, cloneRegion);
    end
  end
end

function WeakAuras.SetIconName(data, region)
  local name, icon = WeakAuras.GetNameAndIcon(data);
  WeakAuras.transmitCache[data.id] = icon;

  if(region.SetIcon) then
    region:SetIcon(icon);
  end
  if(region.SetName) then
    region:SetName(name);
  end
end

function WeakAuras.GetSortedOptionsLists()
  local loadedSorted, unloadedSorted = {}, {};
  local to_sort = {};
  for id, data in pairs(db.displays) do
    if(data.parent) then
    -- Do nothing; children will be added later
    elseif(loaded[id]) then
      tinsert(to_sort, id);
    end
  end
  table.sort(to_sort, function(a, b) return a < b end);
  for _, id in ipairs(to_sort) do
    tinsert(loadedSorted, id);
    local data = WeakAuras.GetData(id);
    local controlledChildren = data.controlledChildren;
    if(controlledChildren) then
      for _, childId in pairs(controlledChildren) do
        tinsert(loadedSorted, childId);
      end
    end
  end

  wipe(to_sort);
  for id, data in pairs(db.displays) do
    if(data.parent) then
    -- Do nothing; children will be added later
    elseif not(loaded[id]) then
      tinsert(to_sort, id);
    end
  end
  table.sort(to_sort, function(a, b) return a < b end);
  for _, id in ipairs(to_sort) do
    tinsert(unloadedSorted, id);
    local data = WeakAuras.GetData(id);
    local controlledChildren = data.controlledChildren;
    if(controlledChildren) then
      for _, childId in pairs(controlledChildren) do
        tinsert(unloadedSorted, childId);
      end
    end
  end

  return loadedSorted, unloadedSorted;
end

function WeakAuras.BuildOptions(list, callback)
  frame.loadProgress:Show();
  frame.filterInput:Hide();
  frame.filterInputClear:Hide();

  local total = 0;
  for _,_ in pairs(list) do
    total = total + 1;
  end

  local func = function()
    local num = 0;
    for id, data in pairs(list) do
      if(data) then
        if not(data.regionType == "group" or data.regionType == "dynamicgroup") then
          WeakAuras.AddOption(id, data);
          num = num + 1;
        end
      end
      frame.loadProgress:SetText(L["Creating options: "]..num.."/"..total);

      coroutine.yield();
    end

    callback();
    frame.loadProgress:Hide();
    frame.filterInput:Show();
    frame.filterInputClear:Show();
  end

  local co = coroutine.create(func);
  dynFrame:AddAction("BuildOptions", co);
end

function WeakAuras.LayoutDisplayButtons(msg)
  local total = 0;
  for _,_ in pairs(db.displays) do
    total = total + 1;
  end

  local loadedSorted, unloadedSorted = WeakAuras.GetSortedOptionsLists();

  frame.loadProgress:Show();
  frame.buttonsScroll:AddChild(frame.newButton);
  if(frame.addonsButton) then
    frame.buttonsScroll:AddChild(frame.addonsButton);
  end
  frame.buttonsScroll:AddChild(frame.loadedButton);
  frame.buttonsScroll:AddChild(frame.unloadedButton);

  local func2 = function()
    local num = frame.loadProgressNum or 0;
    for index, id in pairs(unloadedSorted) do
      local data = WeakAuras.GetData(id);
      if(data) then
        WeakAuras.EnsureDisplayButton(data);
        WeakAuras.UpdateDisplayButton(data);

        frame.buttonsScroll:AddChild(displayButtons[data.id]);
        WeakAuras.SetIconNames(data);
        if(WeakAuras.regions[data.id].region.SetStacks) then
          WeakAuras.regions[data.id].region:SetStacks(1);
        end

        if (num % 50 == 0) then
          frame.buttonsScroll:ResumeLayout()
          frame.buttonsScroll:PerformLayout()
          frame.buttonsScroll:PauseLayout()
        end

        num = num + 1;
      end
      frame.loadProgress:SetText(L["Creating buttons: "]..num.."/"..total);
      frame.loadProgressNum = num;
      coroutine.yield();
    end

    frame.buttonsScroll:ResumeLayout()
    frame.buttonsScroll:PerformLayout()
    WeakAuras.SortDisplayButtons(msg);

    if (WeakAuras.IsOptionsOpen()) then
      for id, button in pairs(displayButtons) do
        if(loaded[id] ~= nil) then
          button:PriorityShow(1);
        end
      end
    end

    frame.loadProgress:Hide();
    frame.filterInput:Show();
    frame.filterInputClear:Show();
  end

  local func1 = function()
    local num = frame.loadProgressNum or 0;
    frame.buttonsScroll:PauseLayout()
    for index, id in pairs(loadedSorted) do
      local data = WeakAuras.GetData(id);
      if(data) then
        WeakAuras.EnsureDisplayButton(data);
        WeakAuras.UpdateDisplayButton(data);

        local button = displayButtons[data.id]
        frame.buttonsScroll:AddChild(button);
        WeakAuras.SetIconNames(data);
        if(WeakAuras.regions[data.id].region.SetStacks) then
          WeakAuras.regions[data.id].region:SetStacks(1);
        end

        num = num + 1;
      end

      if (num % 50 == 0) then
        frame.buttonsScroll:ResumeLayout()
        frame.buttonsScroll:PerformLayout()
        frame.buttonsScroll:PauseLayout()
      end

      frame.loadProgress:SetText(L["Creating buttons: "]..num.."/"..total);
      frame.loadProgressNum = num;
      coroutine.yield();
    end

    local co2 = coroutine.create(func2);
    dynFrame:AddAction("LayoutDisplayButtons2", co2);
  end

  local co1 = coroutine.create(func1);
  dynFrame:AddAction("LayoutDisplayButtons1", co1);
end

local function filterAnimPresetTypes(intable, id)
  local ret = {};
  local region = WeakAuras.regions[id] and WeakAuras.regions[id].region;
  local regionType = WeakAuras.regions[id] and WeakAuras.regions[id].regionType;
  local data = db.displays[id];
  if(region and regionType and data) then
    for key, value in pairs(intable) do
      local preset = WeakAuras.anim_presets[key];
      if(preset) then
        if(regionType == "group" or regionType == "dynamicgroup") then
          local valid = true;
          for index, childId in pairs(data.controlledChildren) do
            local childRegion = WeakAuras.regions[childId] and WeakAuras.regions[childId].region
            if(childRegion and ((preset.use_scale and not childRegion.Scale) or (preset.use_rotate and not childRegion.Rotate))) then
              valid = false;
            end
          end
          if(valid) then
            ret[key] = value;
          end
        else
          if not((preset.use_scale and not region.Scale) or (preset.use_rotate and not region.Rotate)) then
            ret[key] = value;
          end
        end
      end
    end
  end
  return ret;
end

local function removeFuncs(intable)
  for i,v in pairs(intable) do
    if(i == "get" or i == "set" or i == "hidden" or i == "disabled") then
      intable[i] = nil;
    elseif(type(v) == "table" and i ~= "values") then
      removeFuncs(v);
    end
  end
end

local function getAll(data, info, ...)
  local combinedValues = {};
  local first = true;
  local debug = false;
  for index, childId in ipairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    if(childData) then
      WeakAuras.EnsureOptions(childId);
      local childOptions = displayOptions[childId];
      local childOption = childOptions;
      local childOptionTable = {[0] = childOption};
      for i=1,#info do
        childOption = childOption.args[info[i]];
        childOptionTable[i] = childOption;
      end
      for i=#childOptionTable,0,-1 do
        if(childOptionTable[i].get) then
          local values = {childOptionTable[i].get(info, ...)};
          if(first) then
            combinedValues = values;
            first = false;
          else
            local same = true;
            if(#combinedValues == #values) then
              for j=1,#combinedValues do
                if(type(combinedValues[j]) == "number" and type(values[j]) == "number") then
                  if((math.floor(combinedValues[j] * 100) / 100) ~= (math.floor(values[j] * 100) / 100)) then
                    same = false;
                    break;
                  end
                else
                  if(combinedValues[j] ~= values[j]) then
                    same = false;
                    break;
                  end
                end
              end
            else
              same = false;
            end
            if not(same) then
              return nil;
            end
          end
          break;
        end
      end
    end
  end
  return unpack(combinedValues);
end

local function setAll(data, info, ...)
  WeakAuras.pauseOptionsProcessing(true);
  local before = getAll(data, info, ...)
  for index, childId in ipairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    if(childData) then
      WeakAuras.EnsureOptions(childId);
      local childOptions = displayOptions[childId];
      local childOption = childOptions;
      local childOptionTable = {[0] = childOption};
      for i=1,#info do
        childOption = childOption.args[info[i]];
        childOptionTable[i] = childOption;
      end
      for i=#childOptionTable,0,-1 do
        if(childOptionTable[i].set) then
          if (childOptionTable[i].type == "multiselect") then
            childOptionTable[i].set(info, ..., not before);
          else
            childOptionTable[i].set(info, ...);
          end
          break;
        end
      end
    end
  end
  WeakAuras.pauseOptionsProcessing(false);
  WeakAuras.ScanForLoads();
  WeakAuras.SortDisplayButtons();
end

local function hiddenAll(data, info)
  if(#data.controlledChildren == 0 and info[1] ~= "group") then
    return true;
  end
  for index, childId in ipairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    if(childData) then
      WeakAuras.EnsureOptions(childId);
      local childOptions = displayOptions[childId];
      local childOption = childOptions;
      local childOptionTable = {[0] = childOption};
      for i=1,#info do
        childOption = childOption.args[info[i]];
        childOptionTable[i] = childOption;
      end
      for i=#childOptionTable,0,-1 do
        if(childOptionTable[i].hidden ~= nil) then
          if(type(childOptionTable[i].hidden) == "boolean") then
            if(childOptionTable[i].hidden) then
              return true;
            else
              return false;
            end
          elseif(type(childOptionTable[i].hidden) == "function") then
            if(childOptionTable[i].hidden(info)) then
              return true;
            end
          end
        end
      end
    end
  end

  return false;
end

local function disabledAll(data, info)
  for index, childId in ipairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    if(childData) then
      WeakAuras.EnsureOptions(childId);
      local childOptions = displayOptions[childId];
      local childOption = childOptions;
      local childOptionTable = {[0] = childOption};
      for i=1,#info do
        childOption = childOption.args[info[i]];
        childOptionTable[i] = childOption;
      end
      for i=#childOptionTable,0,-1 do
        if(childOptionTable[i].disabled ~= nil) then
          if(type(childOptionTable[i].disabled) == "boolean") then
            if(childOptionTable[i].disabled) then
              return true;
            else
              return false;
            end
          elseif(type(childOptionTable[i].disabled) == "function") then
            if(childOptionTable[i].disabled(info)) then
              return true;
            end
          end
        end
      end
    end
  end

  return false;
end

local function replaceNameDescFuncs(intable, data)

  local function compareTables(tableA, tableB)
    if(#tableA == #tableB) then
      for j=1,#tableA do
        if(type(tableA[j]) == "number" and type(tableB[j]) == "number") then
          if((math.floor(tableA[j] * 100) / 100) ~= (math.floor(tableB[j] * 100) / 100)) then
            return false;
          end
        else
          if(tableA[j] ~= tableB[j]) then
            return false;
          end
        end
      end
    else
      return false;
    end
    return true;
  end

  local function combineKeys(info)
    local combinedKeys = nil;
    for index, childId in ipairs(data.controlledChildren) do
      local childData = WeakAuras.GetData(childId);
      if(childData) then
        WeakAuras.EnsureOptions(childId);
        local childOptions = displayOptions[childId];
        local childOption = childOptions;
        local childOptionTable = {[0] = childOption};
        for i=1,#info do
          childOption = childOption.args[info[i]];
          childOptionTable[i] = childOption;
        end
        for i=#childOptionTable,0,-1 do
          if(childOptionTable[i].values) then
            local values;
            if (type(childOptionTable[i].values) == "function") then
              values = childOptionTable[i].values(info);
            elseif (type(childOptionTable[i].values) == "table") then
              values = childOptionTable[i].values;
            end
            if (values) then
              combinedKeys = combinedKeys or {};
              for k, v in pairs(values) do
                combinedKeys[k] = v;
              end
            end
          end
        end
      end
    end
    return combinedKeys;
  end

  local function sameAll(info)
    local combinedValues = {};
    local first = true;
    local combinedKeys = combineKeys(info);

    for index, childId in ipairs(data.controlledChildren) do
      local childData = WeakAuras.GetData(childId);
      if(childData) then
        WeakAuras.EnsureOptions(childId);
        local childOptions = displayOptions[childId];
        local childOption = childOptions;
        local childOptionTable = {[0] = childOption};
        for i=1,#info do
          childOption = childOption.args[info[i]];
          childOptionTable[i] = childOption;
        end
        for i=#childOptionTable,0,-1 do
          if(childOptionTable[i].get) then
            if (combinedKeys) then
              for key, _ in pairs(combinedKeys) do
                local values = {childOptionTable[i].get(info, key)};
                if (combinedValues[key] == nil) then
                  combinedValues[key] = values;
                else
                  if (not compareTables(combinedValues[key], values)) then
                    return nil;
                  end
                end
              end
            else
              local values = {childOptionTable[i].get(info)};
              if(first) then
                combinedValues = values;
                first = false;
              else
                if (not compareTables(combinedValues, values)) then
                  return nil;
                end
              end
            end
            break; -- Found get function
          end
        end
      end
    end

    return true;
  end

  local function nameAll(info)
    local combinedName;
    local first = true;
    for index, childId in ipairs(data.controlledChildren) do
      local childData = WeakAuras.GetData(childId);
      if(childData) then
        WeakAuras.EnsureOptions(childId);
        local childOption = displayOptions[childId];
        if not(childOption) then
          return "error 1";
        end
        for i=1,#info do
          childOption = childOption.args[info[i]];
          if not(childOption) then
            return "error 2 - "..childId.." - "..table.concat(info, ", ").." - "..i;
          end
        end
        local name;
        if(type(childOption.name) == "function") then
          name = childOption.name(info);
        else
          name = childOption.name;
        end
        if(first) then
          combinedName = name;
          first = false;
        elseif not(combinedName == name) then
          return childOption.name("default");
        end
      end
    end

    return combinedName;
  end

  local function descAll(info)
    local combinedDesc;
    local first = true;
    for index, childId in ipairs(data.controlledChildren) do
      local childData = WeakAuras.GetData(childId);
      if(childData) then
        WeakAuras.EnsureOptions(childId);
        local childOption = displayOptions[childId];
        if not(childOption) then
          return "error"
        end
        for i=1,#info do
          childOption = childOption.args[info[i]];
          if not(childOption) then
            return "error"
          end
        end
        local desc;
        if(type(childOption.desc) == "function") then
          desc = childOption.desc(info);
        else
          desc = childOption.desc;
        end
        if(first) then
          combinedDesc = desc;
          first = false;
        elseif not(combinedDesc == desc) then
          return L["Not all children have the same value for this option"];
        end
      end
    end

    return combinedDesc;
  end

  local function recurse(intable)
    for i,v in pairs(intable) do
      if(i == "name" and type(v) ~= "table") then
        intable.name = function(info)
          local name = nameAll(info);
          if(sameAll(info)) then
            return name;
          else
            if(name == "") then
              return name;
            else
              return "|cFF4080FF"..(name or "error");
            end
          end
        end
        intable.desc = function(info)
          if(sameAll(info)) then
            return descAll(info);
          else
            local combinedKeys = nil;
            if (intable.type == "multiselect") then
              combinedKeys = combineKeys(info)
            end

            local values = {};
            for index, childId in ipairs(data.controlledChildren) do
              local childData = WeakAuras.GetData(childId);
              if(childData) then
                WeakAuras.EnsureOptions(childId);
                local childOptions = displayOptions[childId];
                local childOption = childOptions;
                local childOptionTable = {[0] = childOption};
                for i=1,#info do
                  childOption = childOption.args[info[i]];
                  childOptionTable[i] = childOption;
                end
                for i=#childOptionTable,0,-1 do
                  if(childOptionTable[i].get) then
                    if(intable.type == "toggle") then
                      local name, tri;
                      if(type(childOption.name) == "function") then
                        name = childOption.name(info);
                        tri = true;
                      else
                        name = childOption.name;
                      end
                      if(tri and childOptionTable[i].get(info)) then
                        tinsert(values, "|cFFE0E000"..childId..": |r"..name);
                      elseif(tri) then
                        tinsert(values, "|cFFE0E000"..childId..": |r"..L["Ignored"]);
                      elseif(childOptionTable[i].get(info)) then
                        tinsert(values, "|cFFE0E000"..childId..": |r|cFF00FF00"..L["Enabled"]);
                      else
                        tinsert(values, "|cFFE0E000"..childId..": |r|cFFFF0000"..L["Disabled"]);
                      end
                    elseif(intable.type == "color") then
                      local r, g, b = childOptionTable[i].get(info);
                      r, g, b = r or 1, g or 1, b or 1;
                      tinsert(values, ("|cFF%2x%2x%2x%s"):format(r * 220 + 35, g * 220 + 35, b * 220 + 35, childId));
                    elseif(intable.type == "select") then
                      local selectValues = type(intable.values) == "table" and intable.values or intable.values(info);
                      local key = childOptionTable[i].get(info);
                      local display = key and selectValues[key] or L["None"];
                      tinsert(values, "|cFFE0E000"..childId..": |r"..display);
                    elseif(intable.type == "multiselect") then
                      local selectedValues = "";
                      for k, v in pairs(combinedKeys) do
                        if (childOptionTable[i].get(info, k)) then
                          if (not selectedValues) then
                            selectedValues = tostring(v);
                          else
                            selectedValues = selectedValues .. ", " .. tostring(v);
                          end
                        end
                      end
                      tinsert(values, "|cFFE0E000"..childId..": |r"..selectedValues);
                    else
                      local display = childOptionTable[i].get(info) or L["None"];
                      if(type(display) == "number") then
                        display = math.floor(display * 100) / 100;
                      end
                      tinsert(values, "|cFFE0E000"..childId..": |r"..display);
                    end
                    break;
                  end
                end
              end
            end
            return table.concat(values, "\n");
          end
        end
      elseif(type(v) == "table" and i ~= "values") then
        recurse(v);
      end
    end
  end
  recurse(intable);
end

local function replaceImageFuncs(intable, data)
  local function imageAll(info)
    local combinedImage = {};
    local first = true;
    for index, childId in ipairs(data.controlledChildren) do
      local childData = WeakAuras.GetData(childId);
      if(childData) then
        WeakAuras.EnsureOptions(childId);
        local childOption = displayOptions[childId];
        if not(childOption) then
          return "error"
        end
        for i=1,#info do
          childOption = childOption.args[info[i]];
          if not(childOption) then
            return "error"
          end
        end
        local image;
        if not(childOption.image) then
          return "", 0, 0;
        else
          image = {childOption.image(info)};
        end
        if(first) then
          combinedImage = image;
          first = false;
        else
          if not(combinedImage[1] == image[1]) then
            return "", 0, 0;
          end
        end
      end
    end

    return unpack(combinedImage);
  end

  local function recurse(intable)
    for i,v in pairs(intable) do
      if(i == "image" and type(v) == "function") then
        intable[i] = imageAll;
      elseif(type(v) == "table" and i ~= "values") then
        recurse(v);
      end
    end
  end
  recurse(intable);
end

local function replaceValuesFuncs(intable, data)
  local function valuesAll(info)
    local combinedValues = {};
    local handledValues = {};
    local first = true;
    for index, childId in ipairs(data.controlledChildren) do
      local childData = WeakAuras.GetData(childId);
      if(childData) then
        WeakAuras.EnsureOptions(childId);
        local childOption = displayOptions[childId];
        if not(childOption) then
          return "error"
        end
        for i=1,#info do
          childOption = childOption.args[info[i]];
          if not(childOption) then
            return "error"
          end
        end
        local values;
        if not(childOption.values) then
          return {};
        else
          values = childOption.values(info);
        end
        if(first) then
          for k, v in pairs(values) do
            handledValues[k] = handledValues[k] or {};
            handledValues[k][v] = true;
            combinedValues[k] = v;
          end
          first = false;
        else
          for k, v in pairs(values) do
            if (handledValues[k] and handledValues[k][v]) then
            -- Already known key/value pair
            else
              if (combinedValues[k]) then
                combinedValues[k] = combinedValues[k] .. "/" .. v;
              else
                combinedValues[k] = v;
              end
              handledValues[k] = handledValues[k] or {};
              handledValues[k][v] = true;
            end
          end
        end
      end
    end

    return combinedValues;
  end

  local function recurse(intable)
    for i,v in pairs(intable) do
      if(i == "values" and type(v) == "function") then
        intable[i] = valuesAll;
      elseif(type(v) == "table" and i ~= "values") then
        recurse(v);
      end
    end
  end
  recurse(intable);
end


function WeakAuras.AddOption(id, data)
  local regionOption;
  if(regionOptions[data.regionType]) then
    regionOption = regionOptions[data.regionType].create(id, data);
  else
    regionOption = {
      unsupported = {
        type = "description",
        name = L["This region of type \"%s\" is not supported."]:format(data.regionType)
      }
    };
  end

  displayOptions[id] = {
    type = "group",
    childGroups = "tab",
    args = {
      region = {
        type = "group",
        name = L["Display"],
        order = 10,
        get = function(info)
          if(info.type == "color") then
            data[info[#info]] = data[info[#info]] or {};
            local c = data[info[#info]];
            return c[1], c[2], c[3], c[4];
          else
            return data[info[#info]];
          end
        end,
        set = function(info, v, g, b, a)
          if(info.type == "color") then
            data[info[#info]] = data[info[#info]] or {};
            local c = data[info[#info]];
            c[1], c[2], c[3], c[4] = v, g, b, a;
          elseif(info.type == "toggle") then
            data[info[#info]] = v;
          else
            data[info[#info]] = (v ~= "" and v) or nil;
          end
          WeakAuras.Add(data);
          WeakAuras.SetThumbnail(data);
          WeakAuras.SetIconNames(data);
          if(data.parent) then
            local parentData = WeakAuras.GetData(data.parent);
            if(parentData) then
              WeakAuras.Add(parentData);
              WeakAuras.SetThumbnail(parentData);
            end
          end
          WeakAuras.ResetMoverSizer();
        end,
        args = regionOption
      },
      trigger = {
        type = "group",
        name = L["Trigger"],
        order = 20,
        args = {}
      },
      load = {
        type = "group",
        name = L["Load"],
        order = 30,
        get = function(info) return data.load[info[#info]] end,
        set = function(info, v)
          data.load[info[#info]] = (v ~= "" and v) or nil;
          WeakAuras.Add(data);
          WeakAuras.SetThumbnail(data);
          WeakAuras.ScanForLoads();
          WeakAuras.SortDisplayButtons();
        end,
        args = {}
      },
      action = {
        type = "group",
        name = L["Actions"],
        order = 50,
        get = function(info)
          local split = info[#info]:find("_");
          if(split) then
            local field, value = info[#info]:sub(1, split-1), info[#info]:sub(split+1);
            if(data.actions and data.actions[field]) then
              return data.actions[field][value];
            else
              return nil;
            end
          end
        end,
        set = function(info, v)
          local split = info[#info]:find("_");
          local field, value = info[#info]:sub(1, split-1), info[#info]:sub(split+1);
          data.actions = data.actions or {};
          data.actions[field] = data.actions[field] or {};
          data.actions[field][value] = v;
          if(value == "sound" or value == "sound_path") then
            PlaySoundFile(v, data.actions.start.sound_channel or "Master");
          elseif(value == "sound_kit_id") then
            PlaySoundKitID(v, data.actions.start.sound_channel or "Master");
          end
          WeakAuras.Add(data);
        end,
        args = {
          init_header = {
            type = "header",
            name = L["On Init"],
            order = 0.005
          },
          init_do_custom = {
            type = "toggle",
            name = L["Custom"],
            order = 0.011,
            width = "double"
          },
          init_custom = {
            type = "input",
            width = "normal",
            name = L["Custom Code"],
            order = 0.013,
            multiline = true,
            hidden = function() return not data.actions.init.do_custom end
          },
          init_expand = {
            type = "execute",
            order = 0.014,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"actions", "init", "custom"}, true)
            end,
            hidden = function() return not data.actions.init.do_custom end
          },
          init_customError = {
            type = "description",
            name = function()
              if not(data.actions.init.custom) then
                return "";
              end
              local _, errorString = loadstring("return function() "..data.actions.init.custom.."\n end");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 0.015,
            hidden = function()
              if not(data.actions.init.do_custom and data.actions.init.custom) then
                return true;
              else
                local loadedFunction, errorString = loadstring("return function() "..data.actions.init.custom.."\n end");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          start_header = {
            type = "header",
            name = L["On Show"],
            order = 0.5
          },
          start_do_message = {
            type = "toggle",
            name = L["Chat Message"],
            order = 1
          },
          start_message_type = {
            type = "select",
            name = L["Message Type"],
            order = 2,
            values = send_chat_message_types,
            disabled = function() return not data.actions.start.do_message end,
            control = "WeakAurasSortedDropdown"
          },
          start_message_space = {
            type = "execute",
            name = "",
            order = 3,
            image = function() return "", 0, 0 end,
            hidden = function() return not(data.actions.start.message_type == "WHISPER" or data.actions.start.message_type == "CHANNEL" or data.actions.start.message_type == "COMBAT" or data.actions.start.message_type == "PRINT") end
          },
          start_message_color = {
            type = "color",
            name = L["Color"],
            order = 3,
            hasAlpha = false,
            hidden = function() return not(data.actions.start.message_type == "COMBAT" or data.actions.start.message_type == "PRINT") end,
            get = function() return data.actions.start.r or 1, data.actions.start.g or 1, data.actions.start.b or 1 end,
            set = function(info, r, g, b)
              data.actions.start.r = r;
              data.actions.start.g = g;
              data.actions.start.b = b;
              WeakAuras.Add(data);
            end
          },
          start_message_dest = {
            type = "input",
            name = L["Send To"],
            order = 4,
            disabled = function() return not data.actions.start.do_message end,
            hidden = function() return data.actions.start.message_type ~= "WHISPER" end
          },
          start_message_channel = {
            type = "input",
            name = L["Channel Number"],
            order = 4,
            disabled = function() return not data.actions.start.do_message end,
            hidden = function() return data.actions.start.message_type ~= "CHANNEL" end
          },
          start_message = {
            type = "input",
            name = L["Message"],
            width = "double",
            order = 5,
            disabled = function() return not data.actions.start.do_message end,
            desc = function()
              local ret = L["Dynamic text tooltip"];
              ret = ret .. WeakAuras.GetAdditionalProperties(data);
              return ret
            end,
          },
          start_do_sound = {
            type = "toggle",
            width = "double",
            name = L["Play Sound"],
            order = 7
          },
          start_sound = {
            type = "select",
            name = L["Sound"],
            order = 8,
            values = sound_types,
            disabled = function() return not data.actions.start.do_sound end,
            control = "WeakAurasSortedDropdown"
          },
          start_sound_channel = {
            type = "select",
            name = L["Sound Channel"],
            order = 8.5,
            values = WeakAuras.sound_channel_types,
            disabled = function() return not data.actions.start.do_sound end,
            get = function() return data.actions.start.sound_channel or "Master" end
          },
          start_sound_path = {
            type = "input",
            name = L["Sound File Path"],
            order = 9,
            width = "double",
            hidden = function() return data.actions.start.sound ~= " custom" end,
            disabled = function() return not data.actions.start.do_sound end
          },
          start_sound_kit_id = {
            type = "input",
            name = L["Sound Kit ID"],
            order = 9,
            width = "double",
            hidden = function() return data.actions.start.sound ~= " KitID" end,
            disabled = function() return not data.actions.start.do_sound end
          },
          start_do_glow = {
            type = "toggle",
            name = L["Button Glow"],
            order = 10.1
          },
          start_glow_action = {
            type = "select",
            name = L["Glow Action"],
            order = 10.2,
            values = WeakAuras.glow_action_types,
            disabled = function() return not data.actions.start.do_glow end
          },
          start_glow_frame = {
            type = "input",
            name = L["Frame"],
            order = 10.3,
            hidden = function() return not data.actions.start.do_glow end
          },
          start_choose_glow_frame = {
            type = "execute",
            name = L["Choose"],
            order = 10.4,
            hidden = function() return not data.actions.start.do_glow end,
            func = function()
              if(data.controlledChildren and data.controlledChildren[1]) then
                WeakAuras.PickDisplay(data.controlledChildren[1]);
                WeakAuras.StartFrameChooser(WeakAuras.GetData(data.controlledChildren[1]), {"actions", "start", "glow_frame"});
              else
                WeakAuras.StartFrameChooser(data, {"actions", "start", "glow_frame"});
              end
            end
          },
          start_do_custom = {
            type = "toggle",
            name = L["Custom"],
            order = 11,
            width = "double"
          },
          start_custom = {
            type = "input",
            width = "normal",
            name = L["Custom Code"],
            order = 13,
            multiline = true,
            hidden = function() return not data.actions.start.do_custom end
          },
          start_expand = {
            type = "execute",
            order = 14,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"actions", "start", "custom"}, true)
            end,
            hidden = function() return not data.actions.start.do_custom end
          },
          start_customError = {
            type = "description",
            name = function()
              if not(data.actions.start.custom) then
                return "";
              end
              local _, errorString = loadstring("return function() "..data.actions.start.custom.."\n end");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 15,
            hidden = function()
              if not(data.actions.start.do_custom and data.actions.start.custom) then
                return true;
              else
                local loadedFunction, errorString = loadstring("return function() "..data.actions.start.custom.."\n end");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          finish_header = {
            type = "header",
            name = L["On Hide"],
            order = 20.5
          },
          finish_do_message = {
            type = "toggle",
            name = L["Chat Message"],
            order = 21
          },
          finish_message_type = {
            type = "select",
            name = L["Message Type"],
            order = 22,
            values = send_chat_message_types,
            disabled = function() return not data.actions.finish.do_message end,
            control = "WeakAurasSortedDropdown"
          },
          finish_message_space = {
            type = "execute",
            name = "",
            order = 23,
            image = function() return "", 0, 0 end,
            hidden = function() return not(data.actions.finish.message_type == "WHISPER" or data.actions.finish.message_type == "CHANNEL") end
          },
          finish_message_color = {
            type = "color",
            name = L["Color"],
            order = 23,
            hasAlpha = false,
            hidden = function() return not(data.actions.finish.message_type == "COMBAT" or data.actions.finish.message_type == "PRINT") end,
            get = function() return data.actions.finish.r or 1, data.actions.finish.g or 1, data.actions.finish.b or 1 end,
            set = function(info, r, g, b)
              data.actions.finish.r = r;
              data.actions.finish.g = g;
              data.actions.finish.b = b;
              WeakAuras.Add(data);
            end
          },
          finish_message_dest = {
            type = "input",
            name = L["Send To"],
            order = 24,
            disabled = function() return not data.actions.finish.do_message end,
            hidden = function() return data.actions.finish.message_type ~= "WHISPER" end
          },
          finish_message_channel = {
            type = "input",
            name = L["Channel Number"],
            order = 24,
            disabled = function() return not data.actions.finish.do_message end,
            hidden = function() return data.actions.finish.message_type ~= "CHANNEL" end
          },
          finish_message = {
            type = "input",
            name = L["Message"],
            width = "double",
            order = 25,
            disabled = function() return not data.actions.finish.do_message end,
            desc = function()
              local ret = L["Dynamic text tooltip"];
              ret = ret .. WeakAuras.GetAdditionalProperties(data);
              return ret
            end,
          },
          finish_do_sound = {
            type = "toggle",
            width = "double",
            name = L["Play Sound"],
            order = 27
          },
          finish_sound = {
            type = "select",
            name = L["Sound"],
            order = 28,
            values = sound_types,
            disabled = function() return not data.actions.finish.do_sound end,
            control = "WeakAurasSortedDropdown"
          },
          finish_sound_channel = {
            type = "select",
            name = L["Sound Channel"],
            order = 28.5,
            values = WeakAuras.sound_channel_types,
            disabled = function() return not data.actions.finish.do_sound end,
            get = function() return data.actions.finish.sound_channel or "Master" end
          },
          finish_sound_path = {
            type = "input",
            name = L["Sound File Path"],
            order = 29,
            width = "double",
            hidden = function() return data.actions.finish.sound ~= " custom" end,
            disabled = function() return not data.actions.finish.do_sound end
          },
          finish_sound_kit_id = {
            type = "input",
            name = L["Sound Kit ID"],
            order = 29,
            width = "double",
            hidden = function() return data.actions.finish.sound ~= " KitID" end,
            disabled = function() return not data.actions.finish.do_sound end
          },
          finish_do_glow = {
            type = "toggle",
            name = L["Button Glow"],
            order = 30.1
          },
          finish_glow_action = {
            type = "select",
            name = L["Glow Action"],
            order = 30.2,
            values = WeakAuras.glow_action_types,
            disabled = function() return not data.actions.finish.do_glow end
          },
          finish_glow_frame = {
            type = "input",
            name = L["Frame"],
            order = 30.3,
            hidden = function() return not data.actions.finish.do_glow end
          },
          finish_choose_glow_frame = {
            type = "execute",
            name = L["Choose"],
            order = 30.4,
            hidden = function() return not data.actions.finish.do_glow end,
            func = function()
              if(data.controlledChildren and data.controlledChildren[1]) then
                WeakAuras.PickDisplay(data.controlledChildren[1]);
                WeakAuras.StartFrameChooser(WeakAuras.GetData(data.controlledChildren[1]), {"actions", "finish", "glow_frame"});
              else
                WeakAuras.StartFrameChooser(data, {"actions", "finish", "glow_frame"});
              end
            end
          },
          finish_do_custom = {
            type = "toggle",
            name = L["Custom"],
            order = 31,
            width = "double"
          },
          finish_custom = {
            type = "input",
            width = "half",
            name = L["Custom Code"],
            order = 33,
            multiline = true,
            width = "normal",
            hidden = function() return not data.actions.finish.do_custom end
          },
          finish_expand = {
            type = "execute",
            order = 34,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"actions", "finish", "custom"}, true)
            end,
            hidden = function() return not data.actions.finish.do_custom end
          },
          finish_customError = {
            type = "description",
            name = function()
              if not(data.actions.finish.custom) then
                return "";
              end
              local _, errorString = loadstring("return function() "..data.actions.finish.custom.."\n end");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 35,
            hidden = function()
              if not(data.actions.finish.do_custom and data.actions.finish.custom) then
                return true;
              else
                local loadedFunction, errorString = loadstring("return function() "..data.actions.finish.custom.."\n end");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          }
        }
      },
      animation = {
        type = "group",
        name = L["Animations"],
        order = 60,
        get = function(info)
          local split = info[#info]:find("_");
          if(split) then
            local field, value = info[#info]:sub(1, split-1), info[#info]:sub(split+1);

            if(data.animation and data.animation[field]) then
              return data.animation[field][value];
            else
              if(value == "scalex" or value == "scaley") then
                return 1;
              else
                return nil;
              end
            end
          end
        end,
        set = function(info, v)
          local split = info[#info]:find("_");
          local field, value = info[#info]:sub(1, split-1), info[#info]:sub(split+1);
          data.animation = data.animation or {};
          data.animation[field] = data.animation[field] or {};
          data.animation[field][value] = v;
          if(field == "main" and not WeakAuras.IsAnimating("display", id)) then
            WeakAuras.Animate("display", id, "main", data.animation.main, WeakAuras.regions[id].region, false, nil, true);
            if(WeakAuras.clones[id]) then
              for cloneId, cloneRegion in pairs(WeakAuras.clones[id]) do
                WeakAuras.Animate("display", id, "main", data.animation.main, cloneRegion, false, nil, true, cloneId);
              end
            end
          end
          WeakAuras.Add(data);
        end,
        disabled = function(info, v)
          local split = info[#info]:find("_");
          local valueToType = {
            alphaType = "use_alpha",
            alpha = "use_alpha",
            translateType = "use_translate",
            x = "use_translate",
            y = "use_translate",
            scaleType = "use_scale",
            scalex = "use_scale",
            scaley = "use_scale",
            rotateType = "use_rotate",
            rotate = "use_rotate",
            colorType = "use_color",
            color = "use_color"
          }
          if(split) then
            local field, value = info[#info]:sub(1, split-1), info[#info]:sub(split+1);
            if(data.animation and data.animation[field]) then
              if(valueToType[value]) then
                return not data.animation[field][valueToType[value]];
              else
                return false;
              end
            else
              return true;
            end
          else
            return false;
          end
        end,
        args = {
          start_header = {
            type = "header",
            name = L["Start"],
            order = 30
          },
          start_type = {
            type = "select",
            name = L["Type"],
            order = 32,
            values = anim_types,
            disabled = false
          },
          start_preset = {
            type = "select",
            name = L["Preset"],
            order = 33,
            values = function() return filterAnimPresetTypes(anim_start_preset_types, id) end,
            hidden = function() return data.animation.start.type ~= "preset" end
          },
          start_duration_type_no_choice = {
            type = "select",
            name = L["Time in"],
            order = 33,
            width = "half",
            values = duration_types_no_choice,
            disabled = true,
            hidden = function() return data.animation.start.type ~= "custom" or WeakAuras.CanHaveDuration(data) end,
            get = function() return "seconds" end
          },
          start_duration_type = {
            type = "select",
            name = L["Time in"],
            order = 33,
            width = "half",
            values = duration_types,
            hidden = function() return data.animation.start.type ~= "custom" or not WeakAuras.CanHaveDuration(data) end
          },
          start_duration = {
            type = "input",
            name = function()
              if(data.animation.start.duration_type == "relative") then
                return L["% of Progress"];
              else
                return L["Duration (s)"];
              end
            end,
            desc = function()
              if(data.animation.start.duration_type == "relative") then
                return L["Animation relative duration description"];
              else
                return L["The duration of the animation in seconds."];
              end
            end,
            order = 33.5,
            width = "half",
            hidden = function() return data.animation.start.type ~= "custom" end
          },
          start_use_alpha = {
            type = "toggle",
            name = L["Fade In"],
            order = 34,
            hidden = function() return data.animation.start.type ~= "custom" end
          },
          start_alphaType = {
            type = "select",
            name = L["Type"],
            order = 35,
            values = anim_alpha_types,
            hidden = function() return data.animation.start.type ~= "custom" end
          },
          start_alphaFunc = {
            type = "input",
            width = "normal",
            multiline = true,
            name = L["Custom Function"],
            order = 35.3,
            hidden = function() return data.animation.start.type ~= "custom" or data.animation.start.alphaType ~= "custom" or not data.animation.start.use_alpha end,
            get = function() return data.animation.start.alphaFunc and data.animation.start.alphaFunc:sub(8); end,
            set = function(info, v) data.animation.start.alphaFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          start_alphaFunc_expand = {
            type = "execute",
            order = 35.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "start", "alphaFunc"}, nil, true)
            end,
            hidden = function() return data.animation.start.type ~= "custom" or data.animation.start.alphaType ~= "custom" or not data.animation.start.use_alpha end
          },
          start_alphaFuncError = {
            type = "description",
            name = function()
              if not(data.animation.start.alphaFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.start.alphaFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 35.6,
            hidden = function()
              if(data.animation.start.type ~= "custom" or data.animation.start.alphaType ~= "custom" or not data.animation.start.use_alpha) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.start.alphaFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          start_alpha = {
            type = "range",
            name = L["Alpha"],
            width = "double",
            order = 36,
            min = 0,
            max = 1,
            bigStep = 0.01,
            isPercent = true,
            hidden = function() return data.animation.start.type ~= "custom" end
          },
          start_use_translate = {
            type = "toggle",
            name = L["Slide In"],
            order = 38,
            hidden = function() return data.animation.start.type ~= "custom" end
          },
          start_translateType = {
            type = "select",
            name = L["Type"],
            order = 39,
            values = anim_translate_types,
            hidden = function() return data.animation.start.type ~= "custom" end
          },
          start_translateFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 39.3,
            hidden = function() return data.animation.start.type ~= "custom" or data.animation.start.translateType ~= "custom" or not data.animation.start.use_translate end,
            get = function() return data.animation.start.translateFunc and data.animation.start.translateFunc:sub(8); end,
            set = function(info, v) data.animation.start.translateFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          start_translateFunc_expand = {
            type = "execute",
            order = 39.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "start", "translateFunc"}, nil, true)
            end,
            hidden = function() return data.animation.start.type ~= "custom" or data.animation.start.translateType ~= "custom" or not data.animation.start.use_translate end,
          },
          start_translateFuncError = {
            type = "description",
            name = function()
              if not(data.animation.start.translateFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.start.translateFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 39.6,
            hidden = function()
              if(data.animation.start.type ~= "custom" or data.animation.start.translateType ~= "custom" or not data.animation.start.use_translate) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.start.translateFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          start_x = {
            type = "range",
            name = L["X Offset"],
            order = 40,
            softMin = -200,
            softMax = 200,
            step = 1,
            bigStep = 5,
            hidden = function() return data.animation.start.type ~= "custom" end
          },
          start_y = {
            type = "range",
            name = L["Y Offset"],
            order = 41,
            softMin = -200,
            softMax = 200,
            step = 1,
            bigStep = 5,
            hidden = function() return data.animation.start.type ~= "custom" end
          },
          start_use_scale = {
            type = "toggle",
            name = L["Zoom In"],
            order = 42,
            hidden = function()
              return (
                data.animation.start.type ~= "custom"
                or not WeakAuras.regions[id].region.Scale
                ) end
          },
          start_scaleType = {
            type = "select",
            name = L["Type"],
            order = 43,
            values = anim_scale_types,
            hidden = function() return (data.animation.start.type ~= "custom" or not WeakAuras.regions[id].region.Scale) end
          },
          start_scaleFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 43.3,
            hidden = function() return data.animation.start.type ~= "custom" or data.animation.start.scaleType ~= "custom" or not (data.animation.start.use_scale and WeakAuras.regions[id].region.Scale) end,
            get = function() return data.animation.start.scaleFunc and data.animation.start.scaleFunc:sub(8); end,
            set = function(info, v) data.animation.start.scaleFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          start_scaleFunc_expand = {
            type = "execute",
            order = 43.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "start", "scaleFunc"}, nil, true)
            end,
            hidden = function() return data.animation.start.type ~= "custom" or data.animation.start.scaleType ~= "custom" or not (data.animation.start.use_scale and WeakAuras.regions[id].region.Scale) end,
          },
          start_scaleFuncError = {
            type = "description",
            name = function()
              if not(data.animation.start.scaleFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.start.scaleFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 43.6,
            hidden = function()
              if(data.animation.start.type ~= "custom" or data.animation.start.scaleType ~= "custom" or not (data.animation.start.use_scale and WeakAuras.regions[id].region.Scale)) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.start.scaleFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          start_scalex = {
            type = "range",
            name = L["X Scale"],
            order = 44,
            softMin = 0,
            softMax = 5,
            step = 0.01,
            bigStep = 0.1,
            hidden = function() return (data.animation.start.type ~= "custom" or not WeakAuras.regions[id].region.Scale) end
          },
          start_scaley = {
            type = "range",
            name = L["Y Scale"],
            order = 45,
            softMin = 0,
            softMax = 5,
            step = 0.01,
            bigStep = 0.1,
            hidden = function() return (data.animation.start.type ~= "custom" or not WeakAuras.regions[id].region.Scale) end
          },
          start_use_rotate = {
            type = "toggle",
            name = L["Rotate In"],
            order = 46,
            hidden = function() return (data.animation.start.type ~= "custom" or not WeakAuras.regions[id].region.Rotate) end
          },
          start_rotateType = {
            type = "select",
            name = L["Type"],
            order = 47,
            values = anim_rotate_types,
            hidden = function() return (data.animation.start.type ~= "custom" or not WeakAuras.regions[id].region.Rotate) end
          },
          start_rotateFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 47.3,
            hidden = function() return data.animation.start.type ~= "custom" or data.animation.start.rotateType ~= "custom" or not (data.animation.start.use_rotate and WeakAuras.regions[id].region.Rotate) end,
            get = function() return data.animation.start.rotateFunc and data.animation.start.rotateFunc:sub(8); end,
            set = function(info, v) data.animation.start.rotateFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          start_rotateFunc_expand = {
            type = "execute",
            order = 47.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "start", "rotateFunc"}, nil, true)
            end,
            hidden = function() return data.animation.start.type ~= "custom" or data.animation.start.rotateType ~= "custom" or not (data.animation.start.use_rotate and WeakAuras.regions[id].region.Rotate) end,
          },
          start_rotateFuncError = {
            type = "description",
            name = function()
              if not(data.animation.start.rotateFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.start.rotateFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 47.6,
            hidden = function()
              if(data.animation.start.type ~= "custom" or data.animation.start.rotateType ~= "custom" or not (data.animation.start.use_rotate and WeakAuras.regions[id].region.Rotate)) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.start.rotateFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          start_rotate = {
            type = "range",
            name = L["Angle"],
            width = "double",
            order = 48,
            softMin = 0,
            softMax = 360,
            bigStep = 3,
            hidden = function() return (data.animation.start.type ~= "custom" or not WeakAuras.regions[id].region.Rotate) end
          },
          start_use_color = {
            type = "toggle",
            name = L["Color"],
            order = 48.2,
            hidden = function() return (data.animation.start.type ~= "custom" or not WeakAuras.regions[id].region.Color) end
          },
          start_colorType = {
            type = "select",
            name = L["Type"],
            order = 48.5,
            values = anim_color_types,
            hidden = function() return (data.animation.start.type ~= "custom" or not WeakAuras.regions[id].region.Color) end
          },
          start_colorFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 48.7,
            hidden = function() return data.animation.start.type ~= "custom" or data.animation.start.colorType ~= "custom" or not (data.animation.start.use_color and WeakAuras.regions[id].region.Color) end,
            get = function() return data.animation.start.colorFunc and data.animation.start.colorFunc:sub(8); end,
            set = function(info, v) data.animation.start.colorFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          start_colorFunc_expand = {
            type = "execute",
            order = 48.8,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "start", "colorFunc"}, nil, true)
            end,
            hidden = function() return data.animation.start.type ~= "custom" or data.animation.start.colorType ~= "custom" or not (data.animation.start.use_color and WeakAuras.regions[id].region.Color) end,
          },
          start_colorFuncError = {
            type = "description",
            name = function()
              if not(data.animation.start.colorFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.start.colorFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 49,
            hidden = function()
              if(data.animation.start.type ~= "custom" or data.animation.start.colorType ~= "custom" or not (data.animation.start.use_color and WeakAuras.regions[id].region.Color)) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.start.colorFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          start_color = {
            type = "color",
            name = L["Color"],
            width = "double",
            order = 49.5,
            hidden = function() return (data.animation.start.type ~= "custom" or not WeakAuras.regions[id].region.Color) end,
            get = function()
              return data.animation.start.colorR,
                data.animation.start.colorG,
                data.animation.start.colorB,
                data.animation.start.colorA;
            end,
            set = function(info, r, g, b, a)
              data.animation.start.colorR = r;
              data.animation.start.colorG = g;
              data.animation.start.colorB = b;
              data.animation.start.colorA = a;
            end
          },
          main_header = {
            type = "header",
            name = L["Main"],
            order = 50
          },
          main_type = {
            type = "select",
            name = L["Type"],
            order = 52,
            values = anim_types,
            disabled = false
          },
          main_preset = {
            type = "select",
            name = L["Preset"],
            order = 53,
            values = function() return filterAnimPresetTypes(anim_main_preset_types, id) end,
            hidden = function() return data.animation.main.type ~= "preset" end
          },
          main_duration_type_no_choice = {
            type = "select",
            name = L["Time in"],
            order = 53,
            width = "half",
            values = duration_types_no_choice,
            disabled = true,
            hidden = function() return data.animation.main.type ~= "custom" or WeakAuras.CanHaveDuration(data) end,
            get = function() return "seconds" end
          },
          main_duration_type = {
            type = "select",
            name = L["Time in"],
            order = 53,
            width = "half",
            values = duration_types,
            hidden = function() return data.animation.main.type ~= "custom" or not WeakAuras.CanHaveDuration(data) end
          },
          main_duration = {
            type = "input",
            name = function()
              if(data.animation.main.duration_type == "relative") then
                return L["% of Progress"];
              else
                return L["Duration (s)"];
              end
            end,
            desc = function()
              if(data.animation.main.duration_type == "relative") then
                return L["Animation relative duration description"];
              else
                local ret = "";
                ret = ret..L["The duration of the animation in seconds."].."\n";
                ret = ret..L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."]
                return ret;
              end
            end,
            order = 53.5,
            width = "half",
            hidden = function() return data.animation.main.type ~= "custom" end
          },
          main_use_alpha = {
            type = "toggle",
            name = L["Fade"],
            order = 54,
            hidden = function() return data.animation.main.type ~= "custom" end
          },
          main_alphaType = {
            type = "select",
            name = L["Type"],
            order = 55,
            values = anim_alpha_types,
            hidden = function() return data.animation.main.type ~= "custom" end
          },
          main_alphaFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 55.3,
            hidden = function() return data.animation.main.type ~= "custom" or data.animation.main.alphaType ~= "custom" or not data.animation.main.use_alpha end,
            get = function() return data.animation.main.alphaFunc and data.animation.main.alphaFunc:sub(8); end,
            set = function(info, v) data.animation.main.alphaFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          main_alphaFunc_expand = {
            type = "execute",
            order = 55.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "main", "alphaFunc"}, nil, true)
            end,
            hidden = function() return data.animation.main.type ~= "custom" or data.animation.main.alphaType ~= "custom" or not data.animation.main.use_alpha end,
          },
          main_alphaFuncError = {
            type = "description",
            name = function()
              if not(data.animation.main.alphaFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.main.alphaFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 55.6,
            hidden = function()
              if(data.animation.main.type ~= "custom" or data.animation.main.alphaType ~= "custom" or not data.animation.main.use_alpha) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.main.alphaFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          main_alpha = {
            type = "range",
            name = L["Alpha"],
            width = "double",
            order = 56,
            min = 0,
            max = 1,
            bigStep = 0.01,
            isPercent = true,
            hidden = function() return data.animation.main.type ~= "custom" end
          },
          main_use_translate = {
            type = "toggle",
            name = L["Slide"],
            order = 58,
            hidden = function() return data.animation.main.type ~= "custom" end
          },
          main_translateType = {
            type = "select",
            name = L["Type"],
            order = 59,
            values = anim_translate_types,
            hidden = function() return data.animation.main.type ~= "custom" end
          },
          main_translateFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 59.3,
            hidden = function() return data.animation.main.type ~= "custom" or data.animation.main.translateType ~= "custom" or not data.animation.main.use_translate end,
            get = function() return data.animation.main.translateFunc and data.animation.main.translateFunc:sub(8); end,
            set = function(info, v) data.animation.main.translateFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          main_translateFunc_expand = {
            type = "execute",
            order = 59.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "main", "translateFunc"}, nil, true)
            end,
            hidden = function() return data.animation.main.type ~= "custom" or data.animation.main.translateType ~= "custom" or not data.animation.main.use_translate end,
          },
          main_translateFuncError = {
            type = "description",
            name = function()
              if not(data.animation.main.translateFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.main.translateFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 59.6,
            hidden = function()
              if(data.animation.main.type ~= "custom" or data.animation.main.translateType ~= "custom" or not data.animation.main.use_translate) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.main.translateFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          main_x = {
            type = "range",
            name = L["X Offset"],
            order = 60,
            softMin = -200,
            softMax = 200,
            step = 1,
            bigStep = 5,
            hidden = function() return data.animation.main.type ~= "custom" end
          },
          main_y = {
            type = "range",
            name = L["Y Offset"],
            order = 61,
            softMin = -200,
            softMax = 200,
            step = 1,
            bigStep = 5,
            hidden = function() return data.animation.main.type ~= "custom" end
          },
          main_use_scale = {
            type = "toggle",
            name = L["Zoom"],
            order = 62,
            hidden = function() return (data.animation.main.type ~= "custom" or not WeakAuras.regions[id].region.Scale) end
          },
          main_scaleType = {
            type = "select",
            name = L["Type"],
            order = 63,
            values = anim_scale_types,
            hidden = function() return (data.animation.main.type ~= "custom" or not WeakAuras.regions[id].region.Scale) end
          },
          main_scaleFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 63.3,
            hidden = function() return data.animation.main.type ~= "custom" or data.animation.main.scaleType ~= "custom" or not (data.animation.main.use_scale and WeakAuras.regions[id].region.Scale) end,
            get = function() return data.animation.main.scaleFunc and data.animation.main.scaleFunc:sub(8); end,
            set = function(info, v) data.animation.main.scaleFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          main_scaleFunc_expand = {
            type = "execute",
            order = 63.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "main", "scaleFunc"}, nil, true)
            end,
            hidden = function() return data.animation.main.type ~= "custom" or data.animation.main.scaleType ~= "custom" or not (data.animation.main.use_scale and WeakAuras.regions[id].region.Scale) end,
          },
          main_scaleFuncError = {
            type = "description",
            name = function()
              if not(data.animation.main.scaleFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.main.scaleFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 63.6,
            hidden = function()
              if(data.animation.main.type ~= "custom" or data.animation.main.scaleType ~= "custom" or not (data.animation.main.use_scale and WeakAuras.regions[id].region.Scale)) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.main.scaleFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          main_scalex = {
            type = "range",
            name = L["X Scale"],
            order = 64,
            softMin = 0,
            softMax = 5,
            step = 0.01,
            bigStep = 0.1,
            hidden = function() return (data.animation.main.type ~= "custom" or not WeakAuras.regions[id].region.Scale) end
          },
          main_scaley = {
            type = "range",
            name = L["Y Scale"],
            order = 65,
            softMin = 0,
            softMax = 5,
            step = 0.01,
            bigStep = 0.1,
            hidden = function() return (data.animation.main.type ~= "custom" or not WeakAuras.regions[id].region.Scale) end
          },
          main_use_rotate = {
            type = "toggle",
            name = L["Rotate"],
            order = 66,
            hidden = function() return (data.animation.main.type ~= "custom" or not WeakAuras.regions[id].region.Rotate) end
          },
          main_rotateType = {
            type = "select",
            name = L["Type"],
            order = 67,
            values = anim_rotate_types,
            hidden = function() return (data.animation.main.type ~= "custom" or not WeakAuras.regions[id].region.Rotate) end
          },
          main_rotateFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 67.3,
            hidden = function() return data.animation.main.type ~= "custom" or data.animation.main.rotateType ~= "custom" or not (data.animation.main.use_rotate and WeakAuras.regions[id].region.Rotate) end,
            get = function() return data.animation.main.rotateFunc and data.animation.main.rotateFunc:sub(8); end,
            set = function(info, v) data.animation.main.rotateFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          main_rotateFunc_expand = {
            type = "execute",
            order = 67.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "main", "rotateFunc"}, nil, true)
            end,
            hidden = function() return data.animation.main.type ~= "custom" or data.animation.main.rotateType ~= "custom" or not (data.animation.main.use_rotate and WeakAuras.regions[id].region.Rotate) end,
          },
          main_rotateFuncError = {
            type = "description",
            name = function()
              if not(data.animation.main.rotateFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.main.rotateFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 67.6,
            hidden = function()
              if(data.animation.main.type ~= "custom" or data.animation.main.rotateType ~= "custom" or not (data.animation.main.use_rotate and WeakAuras.regions[id].region.Rotate)) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.main.rotateFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          main_rotate = {
            type = "range",
            name = L["Angle"],
            width = "double",
            order = 68,
            softMin = 0,
            softMax = 360,
            bigStep = 3,
            hidden = function() return (data.animation.main.type ~= "custom" or not WeakAuras.regions[id].region.Rotate) end
          },
          main_use_color = {
            type = "toggle",
            name = L["Color"],
            order = 68.2,
            hidden = function() return (data.animation.main.type ~= "custom" or not WeakAuras.regions[id].region.Color) end
          },
          main_colorType = {
            type = "select",
            name = L["Type"],
            order = 68.5,
            values = anim_color_types,
            hidden = function() return (data.animation.main.type ~= "custom" or not WeakAuras.regions[id].region.Color) end
          },
          main_colorFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 68.7,
            hidden = function() return data.animation.main.type ~= "custom" or data.animation.main.colorType ~= "custom" or not (data.animation.main.use_color and WeakAuras.regions[id].region.Color) end,
            get = function() return data.animation.main.colorFunc and data.animation.main.colorFunc:sub(8); end,
            set = function(info, v) data.animation.main.colorFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          main_colorFunc_expand = {
            type = "execute",
            order = 68.8,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "main", "colorFunc"}, nil, true)
            end,
            hidden = function() return data.animation.main.type ~= "custom" or data.animation.main.colorType ~= "custom" or not (data.animation.main.use_color and WeakAuras.regions[id].region.Color) end,
          },
          main_colorFuncError = {
            type = "description",
            name = function()
              if not(data.animation.main.colorFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.main.colorFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 69,
            hidden = function()
              if(data.animation.main.type ~= "custom" or data.animation.main.colorType ~= "custom" or not (data.animation.main.use_color and WeakAuras.regions[id].region.Color)) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.main.colorFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          main_color = {
            type = "color",
            name = L["Color"],
            width = "double",
            order = 69.5,
            hidden = function() return (data.animation.main.type ~= "custom" or not WeakAuras.regions[id].region.Color) end,
            get = function()
              return data.animation.main.colorR,
                data.animation.main.colorG,
                data.animation.main.colorB,
                data.animation.main.colorA;
            end,
            set = function(info, r, g, b, a)
              data.animation.main.colorR = r;
              data.animation.main.colorG = g;
              data.animation.main.colorB = b;
              data.animation.main.colorA = a;
            end
          },
          finish_header = {
            type = "header",
            name = L["Finish"],
            order = 70
          },
          finish_type = {
            type = "select",
            name = L["Type"],
            order = 72,
            values = anim_types,
            disabled = false
          },
          finish_preset = {
            type = "select",
            name = L["Preset"],
            order = 73,
            values = function() return filterAnimPresetTypes(anim_finish_preset_types, id) end,
            hidden = function() return data.animation.finish.type ~= "preset" end
          },
          finish_duration_type_no_choice = {
            type = "select",
            name = L["Time in"],
            order = 73,
            width = "half",
            values = duration_types_no_choice,
            disabled = true,
            hidden = function() return data.animation.finish.type ~= "custom" end,
            get = function() return "seconds" end
          },
          finish_duration = {
            type = "input",
            name = L["Duration (s)"],
            desc = "The duration of the animation in seconds.\n\nThe finish animation does not start playing until after the display would normally be hidden.",
            order = 73.5,
            width = "half",
            hidden = function() return data.animation.finish.type ~= "custom" end
          },
          finish_use_alpha = {
            type = "toggle",
            name = L["Fade Out"],
            order = 74,
            hidden = function() return data.animation.finish.type ~= "custom" end
          },
          finish_alphaType = {
            type = "select",
            name = L["Type"],
            order = 75,
            values = anim_alpha_types,
            hidden = function() return data.animation.finish.type ~= "custom" end
          },
          finish_alphaFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 75.3,
            hidden = function() return data.animation.finish.type ~= "custom" or data.animation.finish.alphaType ~= "custom" or not data.animation.finish.use_alpha end,
            get = function() return data.animation.finish.alphaFunc and data.animation.finish.alphaFunc:sub(8); end,
            set = function(info, v) data.animation.finish.alphaFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          finish_alphaFunc_expand = {
            type = "execute",
            order = 75.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "finish", "alphaFunc"}, nil, true)
            end,
            hidden = function() return data.animation.finish.type ~= "custom" or data.animation.finish.alphaType ~= "custom" or not data.animation.finish.use_alpha end,
          },
          finish_alphaFuncError = {
            type = "description",
            name = function()
              if not(data.animation.finish.alphaFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.finish.alphaFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 75.6,
            hidden = function()
              if(data.animation.finish.type ~= "custom" or data.animation.finish.alphaType ~= "custom" or not data.animation.finish.use_alpha) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.finish.alphaFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          finish_alpha = {
            type = "range",
            name = L["Alpha"],
            width = "double",
            order = 76,
            min = 0,
            max = 1,
            bigStep = 0.01,
            isPercent = true,
            hidden = function() return data.animation.finish.type ~= "custom" end
          },
          finish_use_translate = {
            type = "toggle",
            name = L["Slide Out"],
            order = 78,
            hidden = function() return data.animation.finish.type ~= "custom" end
          },
          finish_translateType = {
            type = "select",
            name = L["Type"],
            order = 79,
            values = anim_translate_types,
            hidden = function() return data.animation.finish.type ~= "custom" end
          },
          finish_translateFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 79.3,
            hidden = function() return data.animation.finish.type ~= "custom" or data.animation.finish.translateType ~= "custom" or not data.animation.finish.use_translate end,
            get = function() return data.animation.finish.translateFunc and data.animation.finish.translateFunc:sub(8); end,
            set = function(info, v) data.animation.finish.translateFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          finish_translateFunc_expand = {
            type = "execute",
            order = 79.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "finish", "translateFunc"}, nil, true)
            end,
            hidden = function() return data.animation.finish.type ~= "custom" or data.animation.finish.translateType ~= "custom" or not data.animation.finish.use_translate end,
          },
          finish_translateFuncError = {
            type = "description",
            name = function()
              if not(data.animation.finish.translateFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.finish.translateFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 79.6,
            hidden = function()
              if(data.animation.finish.type ~= "custom" or data.animation.finish.translateType ~= "custom" or not data.animation.finish.use_translate) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.finish.translateFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          finish_x = {
            type = "range",
            name = L["X Offset"],
            order = 80,
            softMin = -200,
            softMax = 200,
            step = 1,
            bigStep = 5,
            hidden = function() return data.animation.finish.type ~= "custom" end
          },
          finish_y = {
            type = "range",
            name = L["Y Offset"],
            order = 81,
            softMin = -200,
            softMax = 200,
            step = 1,
            bigStep = 5,
            hidden = function() return data.animation.finish.type ~= "custom" end
          },
          finish_use_scale = {
            type = "toggle",
            name = L["Zoom Out"],
            order = 82,
            hidden = function() return (data.animation.finish.type ~= "custom" or not WeakAuras.regions[id].region.Scale) end
          },
          finish_scaleType = {
            type = "select",
            name = L["Type"],
            order = 83,
            values = anim_scale_types,
            hidden = function() return (data.animation.finish.type ~= "custom" or not WeakAuras.regions[id].region.Scale) end
          },
          finish_scaleFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 83.3,
            hidden = function() return data.animation.finish.type ~= "custom" or data.animation.finish.scaleType ~= "custom" or not (data.animation.finish.use_scale and WeakAuras.regions[id].region.Scale) end,
            get = function() return data.animation.finish.scaleFunc and data.animation.finish.scaleFunc:sub(8); end,
            set = function(info, v) data.animation.finish.scaleFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          finish_scaleFunc_expand = {
            type = "execute",
            order = 83.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "finish", "scaleFunc"}, nil, true)
            end,
            hidden = function() return data.animation.finish.type ~= "custom" or data.animation.finish.scaleType ~= "custom" or not (data.animation.finish.use_scale and WeakAuras.regions[id].region.Scale) end,
          },
          finish_scaleFuncError = {
            type = "description",
            name = function()
              if not(data.animation.finish.scaleFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.finish.scaleFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 83.6,
            hidden = function()
              if(data.animation.finish.type ~= "custom" or data.animation.finish.scaleType ~= "custom" or not (data.animation.finish.use_scale and WeakAuras.regions[id].region.Scale)) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.finish.scaleFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          finish_scalex = {
            type = "range",
            name = L["X Scale"],
            order = 84,
            softMin = 0,
            softMax = 5,
            step = 0.01,
            bigStep = 0.1,
            hidden = function() return (data.animation.finish.type ~= "custom" or not WeakAuras.regions[id].region.Scale) end
          },
          finish_scaley = {
            type = "range",
            name = L["Y Scale"],
            order = 85,
            softMin = 0,
            softMax = 5,
            step = 0.01,
            bigStep = 0.1,
            hidden = function() return (data.animation.finish.type ~= "custom" or not WeakAuras.regions[id].region.Scale) end
          },
          finish_use_rotate = {
            type = "toggle",
            name = L["Rotate Out"],
            order = 86,
            hidden = function() return (data.animation.finish.type ~= "custom" or not WeakAuras.regions[id].region.Rotate) end
          },
          finish_rotateType = {
            type = "select",
            name = L["Type"],
            order = 87,
            values = anim_rotate_types,
            hidden = function() return (data.animation.finish.type ~= "custom" or not WeakAuras.regions[id].region.Rotate) end
          },
          finish_rotateFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 87.3,
            hidden = function() return data.animation.finish.type ~= "custom" or data.animation.finish.rotateType ~= "custom" or not (data.animation.finish.use_rotate and WeakAuras.regions[id].region.Rotate) end,
            get = function() return data.animation.finish.rotateFunc and data.animation.finish.rotateFunc:sub(8); end,
            set = function(info, v) data.animation.finish.rotateFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          finish_rotateFunc_expand = {
            type = "execute",
            order = 87.4,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "finish", "rotateFunc"}, nil, true)
            end,
            hidden = function() return data.animation.finish.type ~= "custom" or data.animation.finish.rotateType ~= "custom" or not (data.animation.finish.use_rotate and WeakAuras.regions[id].region.Rotate) end,
          },
          finish_rotateFuncError = {
            type = "description",
            name = function()
              if not(data.animation.finish.rotateFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.finish.rotateFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 87.6,
            hidden = function()
              if(data.animation.finish.type ~= "custom" or data.animation.finish.rotateType ~= "custom" or not (data.animation.finish.use_rotate and WeakAuras.regions[id].region.Rotate)) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.finish.rotateFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          finish_rotate = {
            type = "range",
            name = L["Angle"],
            width = "double",
            order = 88,
            softMin = 0,
            softMax = 360,
            bigStep = 3,
            hidden = function() return (data.animation.finish.type ~= "custom" or not WeakAuras.regions[id].region.Rotate) end
          },
          finish_use_color = {
            type = "toggle",
            name = L["Color"],
            order = 88.2,
            hidden = function() return (data.animation.finish.type ~= "custom" or not WeakAuras.regions[id].region.Color) end
          },
          finish_colorType = {
            type = "select",
            name = L["Type"],
            order = 88.5,
            values = anim_color_types,
            hidden = function() return (data.animation.finish.type ~= "custom" or not WeakAuras.regions[id].region.Color) end
          },
          finish_colorFunc = {
            type = "input",
            multiline = true,
            name = L["Custom Function"],
            width = "normal",
            order = 88.7,
            hidden = function() return data.animation.finish.type ~= "custom" or data.animation.finish.colorType ~= "custom" or not (data.animation.finish.use_color and WeakAuras.regions[id].region.Color) end,
            get = function() return data.animation.finish.colorFunc and data.animation.finish.colorFunc:sub(8); end,
            set = function(info, v) data.animation.finish.colorFunc = "return "..(v or ""); WeakAuras.Add(data); end
          },
          finish_colorFunc_expand = {
            type = "execute",
            order = 88.8,
            name = L["Expand Text Editor"],
            func = function()
              WeakAuras.OpenTextEditor(data, {"animation", "finish", "colorFunc"}, nil, true)
            end,
            hidden = function() return data.animation.finish.type ~= "custom" or data.animation.finish.colorType ~= "custom" or not (data.animation.finish.use_color and WeakAuras.regions[id].region.Color) end,
          },
          finish_colorFuncError = {
            type = "description",
            name = function()
              if not(data.animation.finish.colorFunc) then
                return "";
              end
              local _, errorString = loadstring(data.animation.finish.colorFunc or "");
              return errorString and "|cFFFF0000"..errorString or "";
            end,
            width = "double",
            order = 89,
            hidden = function()
              if(data.animation.finish.type ~= "custom" or data.animation.finish.colorType ~= "custom" or not (data.animation.finish.use_color and WeakAuras.regions[id].region.Color)) then
                return true;
              else
                local loadedFunction, errorString = loadstring(data.animation.finish.colorFunc or "");
                if(errorString and not loadedFunction) then
                  return false;
                else
                  return true;
                end
              end
            end
          },
          finish_color = {
            type = "color",
            name = L["Color"],
            width = "double",
            order = 89.5,
            hidden = function() return (data.animation.finish.type ~= "custom" or not WeakAuras.regions[id].region.Color) end,
            get = function()
              return data.animation.finish.colorR,
                data.animation.finish.colorG,
                data.animation.finish.colorB,
                data.animation.finish.colorA;
            end,
            set = function(info, r, g, b, a)
              data.animation.finish.colorR = r;
              data.animation.finish.colorG = g;
              data.animation.finish.colorB = b;
              data.animation.finish.colorA = a;
            end
          }
        }
      }
    }
  };

  WeakAuras.ReloadTriggerOptions(data);
end

function WeakAuras.EnsureOptions(id)
  if not(displayOptions[id]) then
    WeakAuras.AddOption(id, WeakAuras.GetData(id));
  end
end

function WeakAuras.GetSpellTooltipText(id)
  local tooltip = WeakAuras.GetHiddenTooltip();
  tooltip:SetSpellByID(id);
  local lines = { tooltip:GetRegions() };
  local i = 1;
  local tooltipText = "";
  while(lines[i]) do
    if(lines[i]:GetObjectType() == "FontString") then
      if(lines[i]:GetText()) then
        if(tooltipText == "") then
          tooltipText = lines[i]:GetText();
        else
          tooltipText = tooltipText.." - "..lines[i]:GetText();
        end
      end
    end
    i = i + 1;
  end
  tooltipText = tooltipText or L["No tooltip text"];
  return tooltipText;
end

function WeakAuras.ReloadTriggerOptions(data)
  local id = data.id;
  local iconCache = spellCache.Get();
  WeakAuras.EnsureOptions(id);

  local trigger, untrigger, appendToTriggerPath, appendToUntriggerPath;
  if(data.controlledChildren) then
    optionTriggerChoices[id] = nil;
    for index, childId in pairs(data.controlledChildren) do
      if not(optionTriggerChoices[id]) then
        optionTriggerChoices[id] = optionTriggerChoices[childId];
        trigger = WeakAuras.GetData(childId).trigger;
        untrigger = WeakAuras.GetData(childId).untrigger;
      else
        if(optionTriggerChoices[id] ~= optionTriggerChoices[childId]) then
          trigger, untrigger = {}, {};
          optionTriggerChoices[id] = -1;
          break;
        end
      end
    end

    optionTriggerChoices[id] = optionTriggerChoices[id] or 0;

    if(optionTriggerChoices[id] >= 0) then
      for index, childId in pairs(data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        if(childData) then
          optionTriggerChoices[childId] = optionTriggerChoices[id];
          WeakAuras.ReloadTriggerOptions(childData);
        end
      end
    end
  else
    optionTriggerChoices[id] = optionTriggerChoices[id] or 0;
    if(optionTriggerChoices[id] == 0) then
      trigger = data.trigger;
      untrigger = data.untrigger;
    else
      trigger = data.additional_triggers and data.additional_triggers[optionTriggerChoices[id]].trigger or data.trigger;
      untrigger = data.additional_triggers and data.additional_triggers[optionTriggerChoices[id]].untrigger or data.untrigger;
    end
  end

  if(optionTriggerChoices[id] == 0) then
    function appendToTriggerPath(...)
      local ret = {...};
      tinsert(ret, 1, "trigger");
      return ret;
    end

    function appendToUntriggerPath(...)
      local ret = {...};
      tinsert(ret, 1, "untrigger");
      return ret;
    end
  elseif (optionTriggerChoices[id] > 0) then
    function appendToTriggerPath(...)
      local ret = {...};
      tinsert(ret, 1, "trigger");
      tinsert(ret, 1, optionTriggerChoices[id]);
      tinsert(ret, 1, "additional_triggers");
      return ret;
    end

    function appendToUntriggerPath(...)
      local ret = {...};
      tinsert(ret, 1, "untrigger");
      tinsert(ret, 1, optionTriggerChoices[id]);
      tinsert(ret, 1, "additional_triggers");
      return ret;
    end
  else
    function appendToTriggerPath(...) end
    function appendToUntriggerPath(...) end
  end

  local function getAuraMatchesLabel(name)
    local ids = iconCache[name]
    if(ids) then
      local descText = "";
      local numMatches = 0;
      for id, _ in pairs(ids) do
        numMatches = numMatches + 1;
      end
      if(numMatches == 1) then
        return L["1 Match"];
      else
        return L["%i Matches"]:format(numMatches);
      end
    else
      return "";
    end
  end

  -- the spell id table is sparse, so tremove doesn't work
  local function spellId_tremove(tbl, pos)
    for i = pos, 9, 1 do
      tbl[i] = tbl[i + 1]
    end
  end

  local function getAuraMatchesList(name)
    local ids = iconCache[name]
    if(ids) then
      local descText = "";
      for id, _ in pairs(ids) do
        local name, _, icon = GetSpellInfo(id);
        if(icon) then
          if(descText == "") then
            descText = "|T"..icon..":0|t: "..id;
          else
            descText = descText.."\n|T"..icon..":0|t: "..id;
          end
        end
      end
      return descText;
    else
      return "";
    end
  end

  local aura_options = {
    fullscan = {
      type = "toggle",
      name = L["Use Full Scan (High CPU)"],
      width = "double",
      order = 9,
    },
    autoclone = {
      type = "toggle",
      name = L["Show all matches (Auto-clone)"],
      width = "double",
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan); end,
      set = function(info, v)
        trigger.autoclone = v;
        if(v == true) then
          WeakAuras.ShowCloneDialog(data);
          WeakAuras.UpdateCloneConfig(data);
        else
          WeakAuras.CollapseAllClones(data.id);
        end
        WeakAuras.Add(data);
      end,
      order = 9.5
    },
    useName = {
      type = "toggle",
      name = L["Aura(s)"],
      width = "half",
      order = 10,
      hidden = function() return not (trigger.type == "aura" and not trigger.fullscan and trigger.unit ~= "multi"); end,
      disabled = true,
      get = function() return true end
    },
    use_name = {
      type = "toggle",
      name = L["Aura Name"],
      order = 10,
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan); end
    },
    name_operator = {
      type = "select",
      name = L["Operator"],
      order = 11,
      disabled = function() return not trigger.use_name end,
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan); end,
      values = WeakAuras.string_operator_types
    },
    name = {
      type = "input",
      name = L["Aura Name"],
      width = "double",
      order = 12,
      disabled = function() return not trigger.use_name end,
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan); end,
      set = function(info, v)
        if (tonumber(v)) then
          trigger.spellId = tonumber(v);
          trigger.name = nil;
        else
          trigger.spellId = nil;
          trigger.name = v;
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
    },
    use_tooltip = {
      type = "toggle",
      name = L["Tooltip"],
      order = 13,
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan and trigger.unit ~= "multi"); end
    },
    tooltip_operator = {
      type = "select",
      name = L["Operator"],
      order = 14,
      disabled = function() return not trigger.use_tooltip end,
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan and trigger.unit ~= "multi"); end,
      values = WeakAuras.string_operator_types
    },
    tooltip = {
      type = "input",
      name = L["Tooltip"],
      width = "double",
      order = 15,
      disabled = function() return not trigger.use_tooltip end,
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan and trigger.unit ~= "multi"); end
    },
    use_stealable = {
      type = "toggle",
      name = function(input)
        local value = trigger.use_stealable;
        if(value == nil) then return L["Stealable"];
        elseif(value == false) then return "|cFFFF0000 "..L["Negator"].." "..L["Stealable"];
        else return "|cFF00FF00"..L["Stealable"]; end
      end,
      width = "double",
      order = 16,
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function()
        local value = trigger.use_stealable;
        if(value == nil) then return false;
        elseif(value == false) then return "false";
        else return "true"; end
      end,
      set = function(info, v)
        if(v) then
          trigger.use_stealable = true;
        else
          local value = trigger.use_stealable;
          if(value == false) then trigger.use_stealable = nil;
          else trigger.use_stealable = false end
        end
        WeakAuras.Add(data);
        WeakAuras.SetIconNames(data);
      end
    },
    use_spellId = {
      type = "toggle",
      name = L["Spell ID"],
      order = 17,
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan and trigger.unit ~= "multi"); end
    },
    spellId = {
      type = "input",
      name = L["Spell ID"],
      order = 18,
      disabled = function() return not trigger.use_spellId end,
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan and trigger.unit ~= "multi"); end
    },
    use_debuffClass = {
      type = "toggle",
      name = L["Debuff Type"],
      order = 19,
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan); end
    },
    debuffClass = {
      type = "select",
      name = L["Debuff Type"],
      order = 20,
      disabled = function() return not trigger.use_debuffClass end,
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan); end,
      values = WeakAuras.debuff_class_types
    },
    multiuse_name = {
      type = "toggle",
      name = L["Aura Name"],
      width = "half",
      order = 10,
      hidden = function() return not (trigger.type == "aura" and not trigger.fullscan and trigger.unit == "multi"); end,
      disabled = true,
      get = function() return true end
    },
    multiicon = {
      type = "execute",
      name = "",
      width = "half",
      image = function()
        if (not trigger.name) then return "" end;
        local icon =  spellCache.GetIcon(trigger.name);
        return icon and tostring(icon) or "", 18, 18 end,
      order = 11,
      disabled = function() return not trigger.name and spellCache.GetIcon(trigger.name) end,
      hidden = function() return not (trigger.type == "aura" and not trigger.fullscan and trigger.unit == "multi"); end
    },
    multiname = {
      type = "input",
      name = L["Aura Name"],
      desc = L["Enter an aura name, partial aura name, or spell id"],
      order = 12,
      hidden = function() return not (trigger.type == "aura" and not trigger.fullscan and trigger.unit == "multi"); end,
      get = function(info) return trigger.spellId and tostring(trigger.spellId) or trigger.name end,
      set = function(info, v)
        if(v == "") then
          trigger.name = nil;
          trigger.spellId = nil;
        else
          trigger.name, trigger.spellId = WeakAuras.spellCache.CorrectAuraName(v);
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
    },
    name1icon = {
      type = "execute",
      name = function() return getAuraMatchesLabel(trigger.names[1]) end,
      desc = function() return getAuraMatchesList(trigger.names[1]) end,
      width = "half",
      image = function()
        local icon = spellCache.GetIcon(trigger.names[1]);
        return icon and tostring(icon) or "", 18, 18
      end,
      order = 11,
      disabled = function() return not spellCache.GetIcon(trigger.names[1]) end,
      hidden = function() return not (trigger.type == "aura" and not trigger.fullscan and trigger.unit ~= "multi"); end
    },
    name1 = {
      type = "input",
      name = L["Aura Name"],
      desc = L["Enter an aura name, partial aura name, or spell id"],
      order = 12,
      hidden = function() return not (trigger.type == "aura" and not trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function(info) return trigger.spellIds[1] and tostring(trigger.spellIds[1]) or trigger.names[1] end,
      set = function(info, v)
        if(v == "") then
          if(trigger.names[1]) then
            tremove(trigger.names, 1);
            spellId_tremove(trigger.spellIds, 1);
          end
        else
          if(tonumber(v)) then
            WeakAuras.ShowSpellIDDialog(trigger, v);
          end
          trigger.names[1], trigger.spellIds[1] = WeakAuras.spellCache.CorrectAuraName(v);
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
    },
    name2space = {
      type = "execute",
      name = L["or"],
      width = "half",
      image = function() return "", 0, 0 end,
      order = 13,
      hidden = function() return not (trigger.type == "aura" and trigger.names[1] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name2icon = {
      type = "execute",
      name = function() return getAuraMatchesLabel(trigger.names[2]) end,
      desc = function() return getAuraMatchesList(trigger.names[2]) end,
      width = "half",
      image = function()
        local icon = spellCache.GetIcon(trigger.names[2]);
        return icon and tostring(icon) or "", 18, 18
      end,
      order = 14,
      disabled = function() return not spellCache.GetIcon(trigger.names[2]) end,
      hidden = function() return not (trigger.type == "aura" and trigger.names[1] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name2 = {
      type = "input",
      order = 15,
      name = "",
      hidden = function() return not (trigger.type == "aura" and trigger.names[1] and not trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function(info) return trigger.spellIds[2] and tostring(trigger.spellIds[2]) or trigger.names[2] end,
      set = function(info, v)
        if(v == "") then
          if(trigger.names[2]) then
            tremove(trigger.names, 2);
            spellId_tremove(trigger.spellIds, 2);
          end
        else
          if(tonumber(v)) then
            WeakAuras.ShowSpellIDDialog(trigger, v);
          end
          trigger.names[2], trigger.spellIds[2] = WeakAuras.spellCache.CorrectAuraName(v);
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
    },
    name3space = {
      type = "execute",
      name = "",
      width = "half",
      image = function() return "", 0, 0 end,
      order = 16,
      hidden = function() return not (trigger.type == "aura" and trigger.names[2] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name3icon = {
      type = "execute",
      name = function() return getAuraMatchesLabel(trigger.names[3]) end,
      desc = function() return getAuraMatchesList(trigger.names[3]) end,
      width = "half",
      image = function()
        local icon = spellCache.GetIcon(trigger.names[3]);
        return icon and tostring(icon) or "", 18, 18
      end,
      order = 17,
      disabled = function() return not spellCache.GetIcon(trigger.names[3]) end,
      hidden = function() return not (trigger.type == "aura" and trigger.names[2] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name3 = {
      type = "input",
      order = 18,
      name = "",
      hidden = function() return not (trigger.type == "aura" and trigger.names[2] and not trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function(info) return trigger.spellIds[3] and tostring(trigger.spellIds[3]) or trigger.names[3] end,
      set = function(info, v)
        if(v == "") then
          if(trigger.names[3]) then
            tremove(trigger.names, 3);
            spellId_tremove(trigger.spellIds, 3);
          end
        else
          if(tonumber(v)) then
            WeakAuras.ShowSpellIDDialog(trigger, v);
          end
          trigger.names[3], trigger.spellIds[3] = WeakAuras.spellCache.CorrectAuraName(v);
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
    },
    name4space = {
      type = "execute",
      name = "",
      width = "half",
      image = function() return "", 0, 0 end,
      order = 19,
      hidden = function() return not (trigger.type == "aura" and trigger.names[3] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name4icon = {
      type = "execute",
      name = function() return getAuraMatchesLabel(trigger.names[4]) end,
      desc = function() return getAuraMatchesList(trigger.names[4]) end,
      width = "half",
      image = function()
        local icon = spellCache.GetIcon(trigger.names[4]);
        return icon and tostring(icon) or "", 18, 18
      end,
      order = 20,
      disabled = function() return not spellCache.GetIcon(trigger.names[4]) end,
      hidden = function() return not (trigger.type == "aura" and trigger.names[3] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name4 = {
      type = "input",
      order = 21,
      name = "",
      hidden = function() return not (trigger.type == "aura" and trigger.names[3] and not trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function(info) return trigger.spellIds[4] and tostring(trigger.spellIds[4]) or trigger.names[4] end,
      set = function(info, v)
        if(v == "") then
          if(trigger.names[4]) then
            tremove(trigger.names, 4);
            spellId_tremove(trigger.spellIds, 4);
          end
        else
          if(tonumber(v)) then
            WeakAuras.ShowSpellIDDialog(trigger, v);
          end
          trigger.names[4], trigger.spellIds[4] = WeakAuras.spellCache.CorrectAuraName(v);
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
    },
    name5space = {
      type = "execute",
      name = "",
      width = "half",
      image = function() return "", 0, 0 end,
      order = 22,
      disabled = function() return not spellCache.GetIcon(trigger.names[5]) end,
      hidden = function() return not (trigger.type == "aura" and trigger.names[4] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name5icon = {
      type = "execute",
      name = function() return getAuraMatchesLabel(trigger.names[5]) end,
      desc = function() return getAuraMatchesList(trigger.names[5]) end,
      width = "half",
      image = function()
        local icon = spellCache.GetIcon(trigger.names[5]);
        return icon and tostring(icon) or "", 18, 18
      end,
      order = 23,
      hidden = function() return not (trigger.type == "aura" and trigger.names[4] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name5 = {
      type = "input",
      order = 24,
      name = "",
      hidden = function() return not (trigger.type == "aura" and trigger.names[4] and not trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function(info) return trigger.spellIds[5] and tostring(trigger.spellIds[5]) or trigger.names[5] end,
      set = function(info, v)
        if(v == "") then
          if(trigger.names[5]) then
            tremove(trigger.names, 5);
            spellId_tremove(trigger.spellIds, 5);
          end
        else
          if(tonumber(v)) then
            WeakAuras.ShowSpellIDDialog(trigger, v);
          end
          trigger.names[5], trigger.spellIds[5] = WeakAuras.spellCache.CorrectAuraName(v);
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
    },
    name6space = {
      type = "execute",
      name = "",
      width = "half",
      image = function() return "", 0, 0 end,
      order = 25,
      hidden = function() return not (trigger.type == "aura" and trigger.names[5] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name6icon = {
      type = "execute",
      name = function() return getAuraMatchesLabel(trigger.names[6]) end,
      desc = function() return getAuraMatchesList(trigger.names[6]) end,
      width = "half",
      image = function()
        local icon = spellCache.GetIcon(trigger.names[6]);
        return icon and tostring(icon) or "", 18, 18
      end,
      order = 26,
      disabled = function() return not spellCache.GetIcon(trigger.names[6]) end,
      hidden = function() return not (trigger.type == "aura" and trigger.names[5] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name6 = {
      type = "input",
      order = 27,
      name = "",
      hidden = function() return not (trigger.type == "aura" and trigger.names[5] and not trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function(info) return trigger.spellIds[6] and tostring(trigger.spellIds[6]) or trigger.names[6] end,
      set = function(info, v)
        if(v == "") then
          if(trigger.names[6]) then
            tremove(trigger.names, 6);
            spellId_tremove(trigger.spellIds, 6);
          end
        else
          if(tonumber(v)) then
            WeakAuras.ShowSpellIDDialog(trigger, v);
          end
          trigger.names[6], trigger.spellIds[6] = WeakAuras.spellCache.CorrectAuraName(v);
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
    },
    name7space = {
      type = "execute",
      name = "",
      width = "half",
      image = function() return "", 0, 0 end,
      order = 28,
      hidden = function() return not (trigger.type == "aura" and trigger.names[6] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name7icon = {
      type = "execute",
      name = function() return getAuraMatchesLabel(trigger.names[7]) end,
      desc = function() return getAuraMatchesList(trigger.names[7]) end,
      width = "half",
      image = function()
        local icon = spellCache.GetIcon(trigger.names[7]);
        return icon and tostring(icon) or "", 18, 18
      end,
      order = 29,
      disabled = function() return not spellCache.GetIcon(trigger.names[7]) end,
      hidden = function() return not (trigger.type == "aura" and trigger.names[6] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name7 = {
      type = "input",
      order = 30,
      name = "",
      hidden = function() return not (trigger.type == "aura" and trigger.names[6] and not trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function(info) return trigger.spellIds[7] and tostring(trigger.spellIds[7]) or trigger.names[7] end,
      set = function(info, v)
        if(v == "") then
          if(trigger.names[7]) then
            tremove(trigger.names, 7);
            spellId_tremove(trigger.spellIds, 7);
          end
        else
          if(tonumber(v)) then
            WeakAuras.ShowSpellIDDialog(trigger, v);
          end
          trigger.names[7], trigger.spellIds[7] = WeakAuras.spellCache.CorrectAuraName(v);
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
    },
    name8space = {
      type = "execute",
      name = "",
      width = "half",
      image = function() return "", 0, 0 end,
      order = 31,
      hidden = function() return not (trigger.type == "aura" and trigger.names[7] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name8icon = {
      type = "execute",
      name = function() return getAuraMatchesLabel(trigger.names[8]) end,
      desc = function() return getAuraMatchesList(trigger.names[8]) end,
      width = "half",
      image = function()
        local icon = spellCache.GetIcon(trigger.names[8]);
        return icon and tostring(icon) or "", 18, 18
      end,
      order = 32,
      disabled = function() return not spellCache.GetIcon(trigger.names[8]) end,
      hidden = function() return not (trigger.type == "aura" and trigger.names[7] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name8 = {
      type = "input",
      order = 33,
      name = "",
      hidden = function() return not (trigger.type == "aura" and trigger.names[7] and not trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function(info) return trigger.spellIds[8] and tostring(trigger.spellIds[8]) or trigger.names[8] end,
      set = function(info, v)
        if(v == "") then
          if(trigger.names[8]) then
            tremove(trigger.names, 8);
            spellId_tremove(trigger.spellIds, 8);
          end
        else
          if(tonumber(v)) then
            WeakAuras.ShowSpellIDDialog(trigger, v);
          end
          trigger.names[8], trigger.spellIds[8] = WeakAuras.spellCache.CorrectAuraName(v);
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
    },
    name9space = {
      type = "execute",
      name = "",
      width = "half",
      image = function() return "", 0, 0 end,
      order = 34,
      hidden = function() return not (trigger.type == "aura" and trigger.names[8] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name9icon = {
      type = "execute",
      name = function() return getAuraMatchesLabel(trigger.names[9]) end,
      desc = function() return getAuraMatchesList(trigger.names[9]) end,
      width = "half",
      image = function()
        local icon = spellCache.GetIcon(trigger.names[9]);
        return icon and tostring(icon) or "", 18, 18
      end,
      order = 35,
      disabled = function() return not spellCache.GetIcon(trigger.names[9]) end,
      hidden = function() return not (trigger.type == "aura" and trigger.names[8] and not trigger.fullscan and trigger.unit ~= "multi"); end,
    },
    name9 = {
      type = "input",
      order = 36,
      name = "",
      hidden = function() return not (trigger.type == "aura" and trigger.names[8] and not trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function(info) return trigger.spellIds[9] and tostring(trigger.spellIds[9]) or trigger.names[9] end,
      set = function(info, v)
        if(v == "") then
          if(trigger.names[9]) then
            tremove(trigger.names, 9);
            spellId_tremove(trigger.spellIds, 9);
          end
        else
          if(tonumber(v)) then
            WeakAuras.ShowSpellIDDialog(trigger, v);
          end
          trigger.names[9], trigger.spellIds[9] = WeakAuras.spellCache.CorrectAuraName(v);
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
    },
    useUnit = {
      type = "toggle",
      name = L["Unit"],
      order = 40,
      disabled = true,
      hidden = function() return not (trigger.type == "aura"); end,
      get = function() return true end
    },
    unit = {
      type = "select",
      name = L["Unit"],
      order = 41,
      values = function()
        if(trigger.fullscan) then
          return actual_unit_types_with_specific;
        else
          return unit_types;
        end
      end,
      hidden = function() return not (trigger.type == "aura"); end,
      set = function(info, v)
        trigger.unit = v;
        trigger.use_specific_unit = (v == "member");
        if(v == "multi") then
          WeakAuras.ShowCloneDialog(data);
          WeakAuras.UpdateCloneConfig(data);
        else
          WeakAuras.CollapseAllClones(data.id);
        end
        WeakAuras.Add(data);
      end,
      get = function()
        if(trigger.fullscan and (trigger.unit == "group" or trigger.unit == "multi")) then
          trigger.unit = "player";
        end
        return trigger.unit;
      end
    },
    useSpecificUnit = {
      type = "toggle",
      name = L["Specific Unit"],
      order = 42,
      disabled = true,
      hidden = function() return not (trigger.type == "aura" and trigger.unit == "member") end,
      get = function() return true end
    },
    specificUnit = {
      type = "input",
      name = L["Specific Unit"],
      order = 43,
      desc = L["Can be a name or a UID (e.g., party1). Only works on friendly players in your group."],
      hidden = function() return not (trigger.type == "aura" and trigger.unit == "member") end
    },
    useGroup_count = {
      type = "toggle",
      name = L["Group Member Count"],
      disabled = true,
      hidden = function() return not (trigger.type == "aura" and trigger.unit == "group"); end,
      get = function() return true; end,
      order = 45
    },
    group_countOperator = {
      type = "select",
      name = L["Operator"],
      order = 46,
      width = "half",
      values = operator_types,
      hidden = function() return not (trigger.type == "aura" and trigger.unit == "group"); end,
      get = function() return trigger.group_countOperator; end
    },
    group_count = {
      type = "input",
      name = L["Count"],
      desc = function()
        local groupType = unit_types[trigger.unit or "group"] or "|cFFFF0000error|r";
        return L["Group aura count description"]:format(groupType, groupType, groupType, groupType, groupType, groupType, groupType);
      end,
      order = 47,
      width = "half",
      hidden = function() return not (trigger.type == "aura" and trigger.unit == "group"); end,
      get = function() return trigger.group_count; end,
      set = function(info, v)
        if(WeakAuras.ParseNumber(v)) then
          trigger.group_count = v;
        else
          trigger.group_count = "";
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    groupclone = {
      type = "toggle",
      name = L["Show all matches (Auto-clone)"],
      width = "double",
      hidden = function() return not (trigger.type == "aura" and trigger.unit == "group"); end,
      set = function(info, v)
        trigger.groupclone = v;
        if(v == true) then
          WeakAuras.ShowCloneDialog(data);
          WeakAuras.UpdateCloneConfig(data);
        else
          WeakAuras.CollapseAllClones(data.id);
        end
        WeakAuras.Add(data);
      end,
      order = 47.1
    },
    name_info = {
      type = "select",
      name = L["Name Info"],
      order = 47.3,
      hidden = function() return not (trigger.type == "aura" and trigger.unit == "group" and not trigger.groupclone); end,
      disabled = function() return not WeakAuras.CanShowNameInfo(data); end,
      get = function()
        if(WeakAuras.CanShowNameInfo(data)) then
          return trigger.name_info;
        else
          return nil;
        end
      end,
      values = group_aura_name_info_types
    },
    stack_info = {
      type = "select",
      name = L["Stack Info"],
      order = 47.6,
      hidden = function() return not (trigger.type == "aura" and trigger.unit == "group" and not trigger.groupclone); end,
      disabled = function() return not WeakAuras.CanShowStackInfo(data); end,
      get = function()
        if(WeakAuras.CanShowStackInfo(data)) then
          return trigger.stack_info;
        else
          return nil;
        end
      end,
      values = group_aura_stack_info_types
    },
    hideAlone = {
      type = "toggle",
      name = L["Hide When Not In Group"],
      order = 48,
      width = "double",
      hidden = function() return not (trigger.type == "aura" and trigger.unit == "group"); end,
    },
    useDebuffType = {
      type = "toggle",
      name = L["Aura Type"],
      order = 50,
      disabled = true,
      hidden = function() return not (trigger.type == "aura"); end,
      get = function() return true end
    },
    debuffType = {
      type = "select",
      name = L["Aura Type"],
      order = 51,
      values = debuff_types,
      hidden = function() return not (trigger.type == "aura"); end
    },
    subcount = {
      type = "toggle",
      width = "double",
      name = L["Use tooltip \"size\" instead of stacks"],
      hidden = function() return not (trigger.type == "aura" and trigger.fullscan) end,
      order = 55
    },
    useRem = {
      type = "toggle",
      name = L["Remaining Time"],
      hidden = function() return not (trigger.type == "aura" and not trigger.fullscan and trigger.unit ~= "multi"); end,
      order = 56
    },
    remOperator = {
      type = "select",
      name = L["Operator"],
      order = 57,
      width = "half",
      values = operator_types,
      disabled = function() return not trigger.useRem; end,
      hidden = function() return not (trigger.type == "aura" and not trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function() return trigger.useRem and trigger.remOperator or nil end
    },
    rem = {
      type = "input",
      name = L["Remaining Time"],
      validate = ValidateNumeric,
      order = 58,
      width = "half",
      disabled = function() return not trigger.useRem; end,
      hidden = function() return not (trigger.type == "aura" and not trigger.fullscan and trigger.unit ~= "multi"); end,
      get = function() return trigger.useRem and trigger.rem or nil end
    },
    useCount = {
      type = "toggle",
      name = L["Stack Count"],
      hidden = function() return not (trigger.type == "aura" and trigger.unit ~= "multi"); end,
      order = 60
    },
    countOperator = {
      type = "select",
      name = L["Operator"],
      order = 62,
      width = "half",
      values = operator_types,
      disabled = function() return not trigger.useCount; end,
      hidden = function() return not (trigger.type == "aura" and trigger.unit ~= "multi"); end,
      get = function() return trigger.useCount and trigger.countOperator or nil end
    },
    count = {
      type = "input",
      name = L["Stack Count"],
      validate = ValidateNumeric,
      order = 65,
      width = "half",
      disabled = function() return not trigger.useCount; end,
      hidden = function() return not (trigger.type == "aura" and trigger.unit ~= "multi"); end,
      get = function() return trigger.useCount and trigger.count or nil end
    },
    ownOnly = {
      type = "toggle",
      name = function()
        local value = trigger.ownOnly;
        if(value == nil) then return L["Own Only"];
        elseif(value == false) then return "|cFFFF0000 "..L["Negator"].." "..L["Own Only"];
        else return "|cFF00FF00"..L["Own Only"]; end
      end,
      desc = function()
        local value = trigger.ownOnly;
        if(value == nil) then return L["Only match auras cast by the player"];
        elseif(value == false) then return L["Only match auras cast by people other than the player"];
        else return L["Only match auras cast by the player"]; end
      end,
      get = function()
        local value = trigger.ownOnly;
        if(value == nil) then return false;
        elseif(value == false) then return "false";
        else return "true"; end
      end,
      set = function(info, v)
        if(v) then
          trigger.ownOnly = true;
        else
          local value = trigger.ownOnly;
          if(value == false) then trigger.ownOnly = nil;
          else trigger.ownOnly = false end
        end
        WeakAuras.Add(data);
      end,
      order = 70,
      hidden = function() return not (trigger.type == "aura"); end
    },
    inverse = {
      type = "toggle",
      name = L["Inverse"],
      desc = function()
        if(trigger.unit == "group") then
          return L["Show players that are |cFFFF0000not affected"];
        else
          return L["Activate when the given aura(s) |cFFFF0000can't|r be found"];
        end
      end,
      order = 75,
      hidden = function() return not (trigger.type == "aura" and not(trigger.unit ~= "group" and trigger.autoclone) and trigger.unit ~= "multi" and not(trigger.unit == "group" and not trigger.groupclone)); end
    }
  };

  local function deleteTrigger()
    if(data.controlledChildren) then
      for index, childId in pairs(data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        if(childData) then
          if (optionTriggerChoices[childId] == 0) then
            childData.trigger = childData.additional_triggers[1].trigger;
            childData.untrigger = childData.additional_triggers[1].untrigger;
            tremove(childData.additional_triggers, 1);
          else
            tremove(childData.additional_triggers, optionTriggerChoices[childId]);
            optionTriggerChoices[childId] = optionTriggerChoices[childId] - 1;
          end
          childData.numTriggers = 1 + (childData.additional_triggers and #childData.additional_triggers or 0)
          WeakAuras.ReloadTriggerOptions(childData);
        end
      end
    else
      if (optionTriggerChoices[id] == 0) then
        data.trigger = data.additional_triggers[1].trigger;
        data.untrigger = data.additional_triggers[1].untrigger;
        tremove(data.additional_triggers, 1);
      else
        tremove(data.additional_triggers, optionTriggerChoices[id]);
        optionTriggerChoices[id] = optionTriggerChoices[id] - 1;
      end
      data.numTriggers = 1 + (data.additional_triggers and #data.additional_triggers or 0)
    end
    WeakAuras.Add(data);
    WeakAuras.ReloadTriggerOptions(data);
  end

  local trigger_options = {
    disjunctive = {
      type = "select",
      name = L["Required For Activation"],
      width = "double",
      order = 0,
      hidden = function() return not (data.additional_triggers and #data.additional_triggers > 0) end,
      values = WeakAuras.trigger_require_types,
      get = function() return data.disjunctive or "all" end,
      set = function(info, v) data.disjunctive = v end
    },
    custom_trigger_combination = {
      type = "input",
      name = L["Custom"],
      order = 0.1,
      multiline = true,
      width = "normal",
      hidden = function() return not (data.disjunctive == "custom") end,
      get = function() return data.customTriggerLogic end,
      set = function(info, v)
        data.customTriggerLogic = v;
        WeakAuras.Add(data);
      end
    },
    custom_trigger_combination_expand = {
      type = "execute",
      order = 0.15,
      name = L["Expand Text Editor"],
      func = function()
        WeakAuras.OpenTextEditor(data, {"customTriggerLogic"})
      end,
      hidden = function() return not (data.disjunctive == "custom") end,
    },
    custom_trigger_combination_error = {
      type = "description",
      name = function()
        if not(data.customTriggerLogic) then
          return "";
        end
        local _, errorString = loadstring("return "..data.customTriggerLogic);
        return errorString and "|cFFFF0000"..errorString or "";
      end,
      width = "double",
      order = 0.2,
      hidden = function()
        if not(data.disjunctive == "custom" and data.customTriggerLogic) then
          return true;
        else
          local loadedFunction, errorString = loadstring("return "..data.customTriggerLogic);
          if(errorString and not loadedFunction) then
            return false;
          else
            return true;
          end
        end
      end
    },
    activeTriggerMode = {
      type = "select",
      name = L["Dynamic information"],
      width = "double",
      order = 0.3,
      values = function()
        local vals = {};
        vals[WeakAuras.trigger_modes.first_active] = L["Dynamic information from first Active Trigger"];
        local numTriggers = data.additional_triggers and #data.additional_triggers or 0;
        for i=0,numTriggers do
          vals[i] = L["Dynamic information from Trigger %i"]:format(i + 1);
        end
        return vals;
      end,
      get = function()
        return data.activeTriggerMode or WeakAuras.trigger_modes.first_active;
      end,
      set = function(info, v)
        data.activeTriggerMode = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end,
      hidden = function() return data.numTriggers <= 1 end
    },
    chooseTrigger = {
      type = "select",
      name = L["Choose Trigger"],
      order = 0.5,
      values = function()
        local ret = {[0] = L["Trigger %d"]:format(1)};
        if(data.controlledChildren) then
          for index=1,(data.numTriggers and data.numTriggers + 1 or 9) do
            local all, none, any = true, true, false;
            for _, childId in pairs(data.controlledChildren) do
              local childData = WeakAuras.GetData(childId);
              if(childData) then
                none = false;
                if(childData.additional_triggers and childData.additional_triggers[index]) then
                  any = true;
                else
                  all = false;
                end
              end
            end
            if not(none) then
              if(all) then
                ret[index] = L["Trigger %d"]:format(index + 1);
              elseif(any) then
                ret[index] = "|cFF777777"..L["Trigger %d"]:format(index + 1);
              end
            end
          end
        elseif(data.additional_triggers) then
          for index, trigger in pairs(data.additional_triggers) do
            ret[index] = L["Trigger %d"]:format(index + 1);
          end
        end
        return ret;
      end,
      get = function() return optionTriggerChoices[id]; end,
      set = function(info, v)
        if(v == 0 or (data.additional_triggers and data.additional_triggers[v])) then
          optionTriggerChoices[id] = v;

          WeakAuras.ReloadTriggerOptions(data);
        end
      end
    },
    addTrigger = {
      type = "execute",
      name = L["Add Trigger"],
      order = 1,
      func = function()
        if(data.controlledChildren) then
          for index, childId in pairs(data.controlledChildren) do
            local childData = WeakAuras.GetData(childId);
            if(childData) then
              childData.additional_triggers = childData.additional_triggers or {};
              tinsert(childData.additional_triggers, {trigger = {}, untrigger = {}});
              childData.numTriggers = 1 + (childData.additional_triggers and #childData.additional_triggers or 0)
              optionTriggerChoices[childId] = #childData.additional_triggers;
              WeakAuras.ReloadTriggerOptions(childData);
            end
          end
        else
          data.additional_triggers = data.additional_triggers or {};
          tinsert(data.additional_triggers, {trigger = {}, untrigger = {}});
          data.numTriggers = 1 + (data.additional_triggers and #data.additional_triggers or 0)
          optionTriggerChoices[id] = #data.additional_triggers;
        end
        WeakAuras.ReloadTriggerOptions(data);
      end
    },
    triggerHeader = {
      type = "header",
      name = function(info)
        if(info == "default") then
          return L["Multiple Triggers"];
        else
          if(optionTriggerChoices[id] == 0) then
            return L["Trigger %d"]:format(1);
          else
            return L["Trigger %d"]:format(optionTriggerChoices[id] + 1);
          end
        end
      end,
      order = 2
    },
    applyTemplate = {
      type = "execute",
      name = L["Apply Template"],
      order = 2.5,
      func = function()
        WeakAuras.OpenTriggerTemplate(data);
      end,
      hidden = function()
        return GetAddOnEnableState(UnitName("player"), "WeakAurasTemplates") == 0
      end
    },
    deleteTriggerHalf = {
      type = "execute",
      name = L["Delete Trigger"],
      order = 3,
      func = deleteTrigger,
      hidden = function()
        return data.numTriggers == 1 or GetAddOnEnableState(UnitName("player"), "WeakAurasTemplates") == 0
      end
    },
    deleteTriggerSpace = {
      type = "execute",
      name = "",
      order = 3.1,
      image = function() return "", 0, 0 end,
      hidden = function()
        return data.numTriggers ~= 1 or GetAddOnEnableState(UnitName("player"), "WeakAurasTemplates") == 0
      end,
    },
    deleteTriggerFull = {
      type = "execute",
      name = L["Delete Trigger"],
      order = 3,
      width = "double",
      func = deleteTrigger,
      hidden = function() return data.numTriggers == 1 or GetAddOnEnableState(UnitName("player"), "WeakAurasTemplates") ~= 0 end
    },
    typedesc = {
      type = "toggle",
      name = L["Type"],
      order = 5,
      disabled = true,
      get = function() return true end
    },
    type = {
      type = "select",
      name = L["Type"],
      desc = L["The type of trigger"],
      order = 6,
      values = trigger_types,
      set = function(info, v)
        trigger.type = v;
        if(trigger.event) then
          local prototype = WeakAuras.event_prototypes[trigger.event];
          if(prototype) then
            if(v == "status" and prototype.type == "event") then
              trigger.event = "Health";
            elseif(v == "event" and prototype.type == "status") then
              trigger.event = "Chat Message";
            end
          end
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
        WeakAuras.ReloadTriggerOptions(data);
      end
    },
    event = {
      type = "select",
      name = function()
        if(trigger.type == "event") then
          return L["Event"];
        elseif(trigger.type == "status") then
          return L["Status"];
        end
      end,
      order = 7,
      width = "double",
      values = function()
        local type;
        if (data.controlledChildren) then
          type = getAll(data, {"trigger", "type"});
        else
          type = trigger.type;
        end
        if(type == "event") then
          return event_types;
        elseif(type == "status") then
          return status_types;
        end
      end,
      control = "WeakAurasSortedDropdown",
      hidden = function() return not (trigger.type == "event" or trigger.type == "status"); end
    },
    subeventPrefix = {
      type = "select",
      name = L["Message Prefix"],
      order = 8,
      values = subevent_prefix_types,
      hidden = function() return not (trigger.type == "event" and trigger.event == "Combat Log"); end
    },
    subeventSuffix = {
      type = "select",
      name = L["Message Suffix"],
      order = 9,
      values = subevent_suffix_types,
      hidden = function() return not (trigger.type == "event" and trigger.event == "Combat Log" and subevent_actual_prefix_types[trigger.subeventPrefix]); end
    },
    spacer_suffix = {
      type = "description",
      name = "",
      order = 9.1,
      hidden = function() return not (trigger.type == "event" and trigger.event == "Combat Log"); end
    },
    custom_type = {
      type = "select",
      name = L["Event Type"],
      order = 7,
      width = "double",
      values = custom_trigger_types,
      hidden = function() return not (trigger.type == "custom") end
    },
    check = {
      type = "select",
      name = L["Check On..."],
      order = 8,
      values = check_types,
      hidden = function() return not (trigger.type == "custom"
        and (trigger.custom_type == "status" or trigger.custom_type == "stateupdate")
        and trigger.check ~= "update")
      end,
      get = function() return trigger.check end,
      set = function(info, v)
        trigger.check = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    check2 = {
      type = "select",
      name = L["Check On..."],
      order = 8,
      width = "double",
      values = check_types,
      hidden = function() return not (trigger.type == "custom"
        and (trigger.custom_type == "status" or trigger.custom_type == "stateupdate")
        and trigger.check == "update")
      end,
      get = function() return trigger.check end,
      set = function(info, v)
        trigger.check = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    events = {
      type = "input",
      name = L["Event(s)"],
      desc = L["Custom trigger status tooltip"],
      order = 9,
      hidden = function() return not (trigger.type == "custom"
        and (trigger.custom_type == "status" or trigger.custom_type == "stateupdate")
        and trigger.check ~= "update") end,
      get = function() return trigger.events end,
      set = function(info, v)
        trigger.events = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    events2 = {
      type = "input",
      name = L["Event(s)"],
      desc = L["Custom trigger event tooltip"],
      width = "double",
      order = 9,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type == "event" and trigger.check ~= "update") end,
      get = function() return trigger.events end,
      set = function(info, v)
        trigger.events = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    custom_trigger = {
      type = "input",
      name = L["Custom Trigger"],
      order = 10,
      multiline = true,
      width = "normal",
      hidden = function() return not (trigger.type == "custom") end,
      get = function() return trigger.custom end,
      set = function(info, v)
        trigger.custom = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    custom_trigger_expand = {
      type = "execute",
      order = 10.5,
      name = L["Expand Text Editor"],
      func = function()
        WeakAuras.OpenTextEditor(data, appendToTriggerPath("custom"))
      end,
      hidden = function() return not (trigger.type == "custom") end,
    },
    custom_trigger_error = {
      type = "description",
      name = function()
        if not(trigger.custom) then
          return "";
        end
        local _, errorString = loadstring("return "..trigger.custom);
        return errorString and "|cFFFF0000"..errorString or "";
      end,
      width = "double",
      order = 11,
      hidden = function()
        if not(trigger.type == "custom" and trigger.custom) then
          return true;
        else
          local loadedFunction, errorString = loadstring("return "..trigger.custom);
          if(errorString and not loadedFunction) then
            return false;
          else
            return true;
          end
        end
      end
    },
    custom_hide = {
      type = "select",
      name = L["Hide"],
      order = 12,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type == "event" and trigger.custom_hide ~= "custom") end,
      values = eventend_types,
      get = function() trigger.custom_hide = trigger.custom_hide or "timed"; return trigger.custom_hide end,
      set = function(info, v)
        trigger.custom_hide = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    custom_hide2 = {
      type = "select",
      name = L["Hide"],
      order = 12,
      width = "double",
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type == "event" and trigger.custom_hide == "custom") end,
      values = eventend_types,
      get = function() return trigger.custom_hide end,
      set = function(info, v)
        trigger.custom_hide = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    duration = {
      type = "input",
      name = L["Duration (s)"],
      order = 13,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type == "event" and trigger.custom_hide ~= "custom") end
    },
    custom_untrigger = {
      type = "input",
      name = L["Custom Untrigger"],
      order = 14,
      multiline = true,
      width = "normal",
      hidden = function() return not (trigger.type == "custom"
        and (trigger.custom_type == "status" or (trigger.custom_type == "event" and trigger.custom_hide == "custom"))) end,
      get = function() return untrigger and untrigger.custom end,
      set = function(info, v)
        if(untrigger) then
          untrigger.custom = v;
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    custom_untrigger_expand = {
      type = "execute",
      order = 14.5,
      name = L["Expand Text Editor"],
      func = function()
        WeakAuras.OpenTextEditor(data, appendToUntriggerPath("custom"))
      end,
      hidden = function() return not (trigger.type == "custom"
        and (trigger.custom_type == "status" or (trigger.custom_type == "event" and trigger.custom_hide == "custom"))) end,
    },
    custom_untrigger_error = {
      type = "description",
      name = function()
        if not(untrigger and untrigger.custom) then
          return "";
        end
        local _, errorString = loadstring("return "..(untrigger and untrigger.custom or ""));
        return errorString and "|cFFFF0000"..errorString or "";
      end,
      width = "double",
      order = 15,
      hidden = function()
        if not(trigger.type == "custom" and (trigger.custom_type == "status" or (trigger.custom_type == "event" and trigger.custom_hide == "custom")) and untrigger and untrigger.custom) then
          return true;
        else
          local loadedFunction, errorString = loadstring("return "..(untrigger and untrigger.custom or ""));
          if(errorString and not loadedFunction) then
            return false;
          else
            return true;
          end
        end
      end
    },
    custom_duration = {
      type = "input",
      name = L["Duration Info"],
      order = 16,
      multiline = true,
      width = "normal",
      hidden = function() return not (trigger.type == "custom"
        and (trigger.custom_type == "status" or (trigger.custom_type == "event" and trigger.custom_hide ~= "timed")))
      end,
      get = function() return trigger.customDuration end,
      set = function(info, v)
        trigger.customDuration = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    custom_duration_expand = {
      type = "execute",
      order = 16.5,
      name = L["Expand Text Editor"],
      func = function()
        WeakAuras.OpenTextEditor(data, appendToTriggerPath("customDuration"))
      end,
      hidden = function() return not (trigger.type == "custom"
        and (trigger.custom_type == "status" or (trigger.custom_type == "event" and trigger.custom_hide ~= "timed")))
      end,
    },
    custom_duration_error = {
      type = "description",
      name = function()
        if not(trigger.type == "custom"
          and (trigger.custom_type == "status" or (trigger.custom_type == "event" and trigger.custom_hide ~= "timed"))
          and trigger.customDuration and trigger.customDuration ~= "") then
          return "";
        end
        local _, errorString = loadstring("return "..(trigger.customDuration or ""));
        return errorString and "|cFFFF0000"..errorString or "";
      end,
      width = "double",
      order = 17,
      hidden = function()
        if not(trigger.type == "custom"
          and (trigger.custom_type == "status" or (trigger.custom_type == "event" and trigger.custom_hide ~= "timed"))
          and trigger.customDuration and trigger.customDuration ~= "") then
          return true;
        else
          local loadedFunction, errorString = loadstring("return "..(trigger.customDuration or ""));
          if(errorString and not loadedFunction) then
            return false;
          else
            return true;
          end
        end
      end
    },
    custom_name = {
      type = "input",
      name = L["Name Info"],
      order = 18,
      multiline = true,
      width = "normal",
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type ~= "stateupdate") end,
      get = function() return trigger.customName end,
      set = function(info, v)
        trigger.customName = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    custom_name_expand = {
      type = "execute",
      order = 18.5,
      name = L["Expand Text Editor"],
      func = function()
        WeakAuras.OpenTextEditor(data, appendToTriggerPath("customName"))
      end,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type ~= "stateupdate") end,
    },
    custom_name_error = {
      type = "description",
      name = function()
        if not(trigger.customName and trigger.customName ~= "") then
          return "";
        end
        local _, errorString = loadstring("return "..(trigger.customName or ""));
        return errorString and "|cFFFF0000"..errorString or "";
      end,
      width = "double",
      order = 19,
      hidden = function()
        if not(trigger.type == "custom" and trigger.custom_type ~= "stateupdate" and trigger.customName and trigger.customName ~= "") then
          return true;
        else
          local loadedFunction, errorString = loadstring("return "..(trigger.customName or ""));
          if(errorString and not loadedFunction) then
            return false;
          else
            return true;
          end
        end
      end
    },
    custom_icon = {
      type = "input",
      name = L["Icon Info"],
      order = 20,
      multiline = true,
      width = "normal",
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type ~= "stateupdate") end,
      get = function() return trigger.customIcon end,
      set = function(info, v)
        trigger.customIcon = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    custom_icon_expand = {
      type = "execute",
      order = 20.5,
      name = L["Expand Text Editor"],
      func = function()
        WeakAuras.OpenTextEditor(data, appendToTriggerPath("customIcon"))
      end,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type ~= "stateupdate") end,
    },
    custom_icon_error = {
      type = "description",
      name = function()
        if not(trigger.customIcon and trigger.customIcon ~= "") then
          return "";
        end
        local _, errorString = loadstring("return "..(trigger.customIcon or ""));
        return errorString and "|cFFFF0000"..errorString or "";
      end,
      width = "double",
      order = 21,
      hidden = function()
        if not(trigger.type == "custom" and trigger.custom_type ~= "stateupdate" and trigger.customIcon and trigger.customIcon ~= "") then
          return true;
        else
          local loadedFunction, errorString = loadstring("return "..(trigger.customIcon or ""));
          if(errorString and not loadedFunction) then
            return false;
          else
            return true;
          end
        end
      end
    },
    custom_texture = {
      type = "input",
      name = L["Texture Info"],
      order = 21.5,
      multiline = true,
      width = "normal",
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type ~= "stateupdate") end,
      get = function() return trigger.customTexture end,
      set = function(info, v)
        trigger.customTexture = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    custom_texture_expand = {
      type = "execute",
      order = 22,
      name = L["Expand Text Editor"],
      func = function()
        WeakAuras.OpenTextEditor(data, appendToTriggerPath("customTexture"))
      end,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type ~= "stateupdate") end,
    },
    custom_texture_error = {
      type = "description",
      name = function()
        if not(trigger.customTexture and trigger.custom_type ~= "stateupdate" and trigger.customTexture ~= "") then
          return "";
        end
        local _, errorString = loadstring("return "..(trigger.customTexture or ""));
        return errorString and "|cFFFF0000"..errorString or "";
      end,
      width = "double",
      order = 22.5,
      hidden = function()
        if not(trigger.type == "custom" and trigger.custom_type ~= "stateupdate" and trigger.customTexture and trigger.customTexture ~= "") then
          return true;
        else
          local loadedFunction, errorString = loadstring("return "..(trigger.customTexture or ""));
          if(errorString and not loadedFunction) then
            return false;
          else
            return true;
          end
        end
      end
    },
    custom_stacks = {
      type = "input",
      name = L["Stack Info"],
      order = 23,
      multiline = true,
      width = "normal",
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type ~= "stateupdate") end,
      get = function() return trigger.customStacks end,
      set = function(info, v)
        trigger.customStacks = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.UpdateDisplayButton(data);
      end
    },
    custom_stacks_expand = {
      type = "execute",
      order = 23.5,
      name = L["Expand Text Editor"],
      func = function()
        WeakAuras.OpenTextEditor(data, appendToTriggerPath("customStacks"))
      end,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type ~= "stateupdate") end,
    },
    custom_stacks_error = {
      type = "description",
      name = function()
        if not(trigger.customStacks and trigger.custom_type ~= "stateupdate" and trigger.customStacks ~= "") then
          return "";
        end
        local _, errorString = loadstring("return "..(trigger.customStacks or ""));
        return errorString and "|cFFFF0000"..errorString or "";
      end,
      width = "double",
      order = 24,
      hidden = function()
        if not(trigger.type == "custom" and trigger.customStacks and trigger.customStacks ~= "") then
          return true;
        else
          local loadedFunction, errorString = loadstring("return "..(trigger.customStacks or ""));
          if(errorString and not loadedFunction) then
            return false;
          else
            return true;
          end
        end
      end
    }
  };

  local order = 81;

  if(data.controlledChildren) then
    local function options_set(info, ...)
      setAll(data, info, ...);
      WeakAuras.Add(data);
      WeakAuras.SetThumbnail(data);
      WeakAuras.SetIconNames(data);
      WeakAuras.UpdateDisplayButton(data);
      WeakAuras.ReloadTriggerOptions(data);
    end

    removeFuncs(displayOptions[id]);

    if(optionTriggerChoices[id] >= 0 and getAll(data, {"trigger", "type"}) == "aura") then
      displayOptions[id].args.trigger.args = union(trigger_options, aura_options);
      removeFuncs(displayOptions[id].args.trigger);
      displayOptions[id].args.trigger.args.type.set = options_set;
    elseif(optionTriggerChoices[id] >= 0 and (getAll(data, {"trigger", "type"}) == "event" or getAll(data, {"trigger", "type"}) == "status")) then
      local event = getAll(data, {"trigger", "event"});
      local unevent = getAll(data, {"trigger", "unevent"});
      if(event and WeakAuras.event_prototypes[event]) then
        local trigger_options_created;
        if(event == "Combat Log") then
          local subeventPrefix = getAll(data, {"trigger", "subeventPrefix"});
          local subeventSuffix = getAll(data, {"trigger", "subeventSuffix"});
          if(subeventPrefix and subeventSuffix) then
            trigger_options_created = true;
            displayOptions[id].args.trigger.args = union(trigger_options, WeakAuras.ConstructOptions(WeakAuras.event_prototypes[event], data, 10, subeventPrefix, subeventSuffix, optionTriggerChoices[id], nil, unevent));
          end
        end

        if not(trigger_options_created) then
          displayOptions[id].args.trigger.args = union(trigger_options, WeakAuras.ConstructOptions(WeakAuras.event_prototypes[event], data, 10, nil, nil, optionTriggerChoices[id], nil, unevent));
        end
      else
        displayOptions[id].args.trigger.args = union(trigger_options, {});
        removeFuncs(displayOptions[id].args.trigger);
      end
      removeFuncs(displayOptions[id].args.trigger);
      replaceNameDescFuncs(displayOptions[id].args.trigger, data);
      replaceImageFuncs(displayOptions[id].args.trigger, data);
      replaceValuesFuncs(displayOptions[id].args.trigger, data);

      if(displayOptions[id].args.trigger.args.unevent) then
        displayOptions[id].args.trigger.args.unevent.set = options_set;
      end
      if(displayOptions[id].args.trigger.args.subeventPrefix) then
        displayOptions[id].args.trigger.args.subeventPrefix.set = function(info, v)
          if not(subevent_actual_prefix_types[v]) then
            data.trigger.subeventSuffix = "";
          end
          options_set(info, v);
        end
      end
      if(displayOptions[id].args.trigger.args.subeventSuffix) then
        displayOptions[id].args.trigger.args.subeventSuffix.set = options_set;
      end

      if(displayOptions[id].args.trigger.args.type) then
        displayOptions[id].args.trigger.args.type.set = options_set;
      end
      if(displayOptions[id].args.trigger.args.event) then
        displayOptions[id].args.trigger.args.event.set = options_set;
      end
    else
      displayOptions[id].args.trigger.args = trigger_options;
      removeFuncs(displayOptions[id].args.trigger);
    end

    displayOptions[id].get = function(info, ...) return getAll(data, info, ...); end;
    displayOptions[id].set = function(info, ...)
      setAll(data, info, ...);
      if(type(id) == "string") then
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
      end
    end
    displayOptions[id].hidden = function(info, ...) return hiddenAll(data, info, ...); end;
    displayOptions[id].disabled = function(info, ...) return disabledAll(data, info, ...); end;

    displayOptions[id].args.trigger.args.chooseTrigger.set = options_set;
    displayOptions[id].args.trigger.args.type.set = options_set;
    displayOptions[id].args.trigger.args.event.set = options_set;

    replaceNameDescFuncs(displayOptions[id], data);
    replaceImageFuncs(displayOptions[id], data);
    replaceValuesFuncs(displayOptions[id], data);

    local regionOption;
    if (regionOptions[data.regionType]) then
      regionOption = regionOptions[data.regionType].create(id, data);
    else
      regionOption = {
        unsupported = {
          type = "description",
          name = L["This region of type \"%s\" is not supported."]:format(data.regionType)
        }
      };
    end
    displayOptions[id].args.group = {
      type = "group",
      name = L["Group"],
      order = 0,
      get = function(info)
        if(info.type == "color") then
          data[info[#info]] = data[info[#info]] or {};
          local c = data[info[#info]];
          return c[1], c[2], c[3], c[4];
        else
          return data[info[#info]];
        end
      end,
      set = function(info, v, g, b, a)
        if(info.type == "color") then
          data[info[#info]] = data[info[#info]] or {};
          local c = data[info[#info]];
          c[1], c[2], c[3], c[4] = v, g, b, a;
        elseif(info.type == "toggle") then
          data[info[#info]] = v;
        else
          data[info[#info]] = (v ~= "" and v) or nil;
        end
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.SetIconNames(data);
        WeakAuras.ResetMoverSizer();
      end,
      hidden = function() return false end,
      disabled = function() return false end,
      args = regionOption
    };

    data.load.use_class = getAll(data, {"load", "use_class"});
    local single_class = getAll(data, {"load", "class"});
    data.load.class = {}
    data.load.class.single = single_class;

    displayOptions[id].args.load.args = WeakAuras.ConstructOptions(WeakAuras.load_prototype, data, 10, nil, nil, optionTriggerChoices[id], "load");
    removeFuncs(displayOptions[id].args.load);
    replaceNameDescFuncs(displayOptions[id].args.load, data);
    replaceImageFuncs(displayOptions[id].args.load, data);
    replaceValuesFuncs(displayOptions[id].args.load, data);

    WeakAuras.ReloadGroupRegionOptions(data);
  else -- One aura selected
    local function options_set(info, v)
      trigger[info[#info]] = v;
      WeakAuras.Add(data);
      WeakAuras.SetThumbnail(data);
      WeakAuras.SetIconNames(data);
      WeakAuras.UpdateDisplayButton(data);
      WeakAuras.ReloadTriggerOptions(data);
    end
    local triggernum = optionTriggerChoices[id];
    if(trigger.type == "aura") then
      displayOptions[id].args.trigger.args = union(trigger_options, aura_options);
    elseif(trigger.type == "event" or trigger.type == "status") then
      if(WeakAuras.event_prototypes[trigger.event]) then
        if(trigger.event == "Combat Log") then
          displayOptions[id].args.trigger.args = union(trigger_options, WeakAuras.ConstructOptions(WeakAuras.event_prototypes[trigger.event], data, 10, (trigger.subeventPrefix or ""), (trigger.subeventSuffix or ""), optionTriggerChoices[id]));
        else
          displayOptions[id].args.trigger.args = union(trigger_options, WeakAuras.ConstructOptions(WeakAuras.event_prototypes[trigger.event], data, 10, nil, nil, optionTriggerChoices[id]));
        end
        if(displayOptions[id].args.trigger.args.unevent) then
          displayOptions[id].args.trigger.args.unevent.set = options_set;
        end
        if(displayOptions[id].args.trigger.args.subeventPrefix) then
          displayOptions[id].args.trigger.args.subeventPrefix.set = function(info, v)
            if not(subevent_actual_prefix_types[v]) then
              trigger.subeventSuffix = "";
            end
            options_set(info, v);
          end
        end
        if(displayOptions[id].args.trigger.args.subeventSuffix) then
          displayOptions[id].args.trigger.args.subeventSuffix.set = options_set;
        end
      else
        print("No prototype for", trigger.event);
        displayOptions[id].args.trigger.args = union(trigger_options, {});
      end
    else
      displayOptions[id].args.trigger.args = union(trigger_options, {});
    end

    displayOptions[id].args.load.args = WeakAuras.ConstructOptions(WeakAuras.load_prototype, data, 10, nil, nil, optionTriggerChoices[id], "load");

    if (displayOptions[id].args.trigger.args.event) then
      displayOptions[id].args.trigger.args.event.set = function(info, v, ...)
        local prototype = WeakAuras.event_prototypes[v];
        if(prototype) then
          if(prototype.automatic or prototype.automaticrequired) then
            trigger.unevent = "auto";
          else
            trigger.unevent = "timed";
          end
        end
        options_set(info, v, ...);
      end
    end
    trigger.event = trigger.event or "Health";
    trigger.subeventPrefix = trigger.subeventPrefix or "SPELL"
    trigger.subeventSuffix = trigger.subeventSuffix or "_CAST_START";

    displayOptions[id].args.trigger.get = function(info) return trigger[info[#info]] end;
    displayOptions[id].args.trigger.set = function(info, v)
      trigger[info[#info]] = (v ~= "" and v) or nil;
      WeakAuras.Add(data);
      WeakAuras.SetThumbnail(data);
      WeakAuras.SetIconNames(data);
      WeakAuras.UpdateDisplayButton(data);
    end;
  end
  if(type(id) ~= "string") then
    displayOptions[id].args.group = nil;
  end
end

function WeakAuras.ReloadGroupRegionOptions(data)
  local regionType;
  local first = true;
  for index, childId in ipairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    if(childData) then
      if(first) then
        regionType = childData.regionType;
        first = false;
      else
        if(childData.regionType ~= regionType) then
          regionType = false;
        end
      end
    end
  end

  local id = data.id;
  WeakAuras.EnsureOptions(id);
  local options = displayOptions[id];
  local regionOption;
  if(regionType) then
    if(regionOptions[regionType]) then
      regionOption = regionOptions[regionType].create(id, data);
    else
      regionOption = {
        unsupported = {
          type = "description",
          name = L["This region of type \"%s\" is not supported."]:format(data.regionType)
        }
      };
    end
  end
  if(regionOption) then
    if(data.regionType == "dynamicgroup") then
      regionOption.selfPoint = nil;
      regionOption.anchorPoint = nil;
      regionOption.anchorPointGroup = nil;
      regionOption.xOffset1 = nil;
      regionOption.xOffset2 = nil;
      regionOption.xOffset3 = nil;
      regionOption.yOffset1 = nil;
      regionOption.yOffset2 = nil;
      regionOption.yOffset3 = nil;
    end
    replaceNameDescFuncs(regionOption, data);
    replaceImageFuncs(regionOption, data);
    replaceValuesFuncs(regionOption, data);
  else
    regionOption = {
      invalid = {
        type = "description",
        name = L["The children of this group have different display types, so their display options cannot be set as a group."],
        fontSize = "large"
      }
    };
  end
  removeFuncs(regionOption);
  options.args.region.args = regionOption;
end

function WeakAuras.AddPositionOptions(input, id, data)
  local function IsParentDynamicGroup()
    return data.parent and db.displays[data.parent] and db.displays[data.parent].regionType == "dynamicgroup";
  end

  local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20;
  local positionOptions = {
    width = {
      type = "range",
      name = L["Width"],
      order = 60,
      min = 1,
      softMax = screenWidth,
      bigStep = 1
    },
    height = {
      type = "range",
      name = L["Height"],
      order = 65,
      min = 1,
      softMax = screenHeight,
      bigStep = 1
    },
    selfPoint = {
      type = "select",
      name = L["Anchor"],
      order = 70,
      hidden = IsParentDynamicGroup,
      values = point_types
    },
    anchorFrameType = {
      type = "select",
      name = L["anchored to"],
      order = 72,
      hidden = IsParentDynamicGroup,
      values = WeakAuras.anchor_frame_types
    },
    -- Input field to select frame to anchor on
    anchorFrameFrame = {
      type = "input",
      name = L["Frame"],
      order = 72.2,
      hidden = function()
        if (IsParentDynamicGroup()) then
          return true;
        end
        return not (data.anchorFrameType == "SELECTFRAME")
      end
    },
    -- Button to select frame to anchor on
    chooseAnchorFrameFrame = {
      type = "execute",
      name = L["Choose"],
      order = 72.4,
      hidden = function()
        if (IsParentDynamicGroup()) then
          return true;
        end
        return not (data.anchorFrameType == "SELECTFRAME")
      end,
      func = function()
        WeakAuras.StartFrameChooser(data, {"anchorFrameFrame"});
      end
    },
    anchorPoint = {
      type = "select",
      name = function()
        if (data.anchorFrameType == "SCREEN") then
          return L["to screen's"]
        elseif (data.anchorFrameType == "PRD") then
          return L["to Personal Ressource Display's"];
        elseif (data.anchorFrameType == "SELECTFRAME") then
          return L["frame's"];
        end
      end,
      order = 75,
      hidden = function()
        if (data.parent) then
          if (IsParentDynamicGroup()) then
            return true;
          end
          return data.anchorFrameType == "SCREEN" or data.anchorFrameType == "MOUSE";
        else
          return data.anchorFrameType == "MOUSE";
        end
      end,
      values = point_types
    },
    anchorPointGroup = {
      type = "select",
      name = function() return L["to group's"] end,
      order = 75,
      hidden = function()
        if (data.anchorFrameType ~= "SCREEN") then
          return true;
        end
        if (data.parent) then
          return IsParentDynamicGroup();
        end
        return true;
      end,
      disabled = true,
      values = {["CENTER"] = L["Anchor Point"]},
      get = function() return "CENTER"; end
    },
    anchorFrameParent = {
      type = "toggle",
      name = L["Set Parent to Anchor"],
      order = 77,
      get = function()
        return data.anchorFrameParent or data.anchorFrameParent == nil;
      end,
      hidden = function()
        return (data.anchorFrameType == "SCREEN" or data.anchorFrameType == "MOUSE");
      end,
    },
    frameStrata = {
      type = "select",
      name = L["Frame Strata"],
      order = 78,
      values = WeakAuras.frame_strata_types
    },
    anchorFrameSpace = {
      type = "execute",
      name = "",
      order = 79,
      image = function() return "", 0, 0 end,
      hidden = function()
        return not (data.anchorFrameType ~= "SCREEN");
      end
    },
    -- IsParentDynamicGroup => none
    -- InGroup/Attached to mouse/PRD/SELECTFRAME => -screen -- +screen
    -- Attached to Screen => depends on anchorPoint
    --   LEFT/BOTTOM => 0 -- +screen
    --   CENTER => -screen/2 -- +screen / 2
    --   RIGHT/TOP => -screen -- +screen
    xOffset1 = {
      type = "range",
      name = L["X Offset"],
      order = 80,
      softMin = 0,
      softMax = screenWidth,
      bigStep = 10,
      hidden = function()
        if (IsParentDynamicGroup()) then
          return true;
        end
        if (data.parent or data.anchorFrameType ~= "SCREEN") then
          return true;
        end
        return not data.anchorPoint:find("LEFT")
      end,
      get = function() return data.xOffset end,
      set = function(info, v)
        data.xOffset = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
        if(data.parent) then
          local parentData = WeakAuras.GetData(data.parent);
          if(parentData) then
            WeakAuras.Add(parentData);
            WeakAuras.SetThumbnail(parentData);
          end
        end
      end
    },
    xOffset2 = {
      type = "range",
      name = L["X Offset"],
      order = 80,
      softMin = ((-1/2) * screenWidth),
      softMax = ((1/2) * screenWidth),
      bigStep = 10,
      hidden = function()
        if (IsParentDynamicGroup()) then
          return true;
        end
        if (data.parent or data.anchorFrameType ~= "SCREEN") then
          return true;
        end
        return (data.anchorPoint:find("LEFT") or data.anchorPoint:find("RIGHT"));
      end,
      get = function() return data.xOffset end,
      set = function(info, v)
        data.xOffset = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
        if(data.parent) then
          local parentData = WeakAuras.GetData(data.parent);
          if(parentData) then
            WeakAuras.Add(parentData);
            WeakAuras.SetThumbnail(parentData);
          end
        end
      end
    },
    xOffset3 = {
      type = "range",
      name = L["X Offset"],
      order = 80,
      softMin = (-1 * screenWidth),
      softMax = 0,
      bigStep = 10,
      hidden = function()
        if (IsParentDynamicGroup()) then
          return true;
        end
        if (data.parent or data.anchorFrameType ~= "SCREEN") then
          return true;
        end
        return not data.anchorPoint:find("RIGHT");
      end,
      get = function() return data.xOffset end,
      set = function(info, v)
        data.xOffset = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
        if(data.parent) then
          local parentData = WeakAuras.GetData(data.parent);
          if(parentData) then
            WeakAuras.Add(parentData);
            WeakAuras.SetThumbnail(parentData);
          end
        end
      end
    },
    xOffset4 = {
      type = "range",
      name = L["X Offset"],
      order = 80,
      softMin = (-1 * screenWidth),
      softMax = screenWidth,
      bigStep = 10,
      hidden = function()
        if (IsParentDynamicGroup()) then
          return true;
        end
        if (data.parent or data.anchorFrameType ~= "SCREEN") then
          return false;
        end
        return true;
      end,
      get = function() return data.xOffset end,
      set = function(info, v)
        data.xOffset = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
        if(data.parent) then
          local parentData = WeakAuras.GetData(data.parent);
          if(parentData) then
            WeakAuras.Add(parentData);
            WeakAuras.SetThumbnail(parentData);
          end
        end
      end
    },
    yOffset1 = {
      type = "range",
      name = L["Y Offset"],
      order = 85,
      softMin = 0,
      softMax = screenHeight,
      bigStep = 10,
      hidden = function()
        if (IsParentDynamicGroup()) then
          return true;
        end
        if (data.parent or data.anchorFrameType ~= "SCREEN") then
          return true;
        end
        return not data.anchorPoint:find("BOTTOM");
      end,
      get = function() return data.yOffset end,
      set = function(info, v)
        data.yOffset = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
        if(data.parent) then
          local parentData = WeakAuras.GetData(data.parent);
          if(parentData) then
            WeakAuras.Add(parentData);
            WeakAuras.SetThumbnail(parentData);
          end
        end
      end
    },
    yOffset2 = {
      type = "range",
      name = L["Y Offset"],
      order = 85,
      softMin = ((-1/2) * screenHeight),
      softMax = ((1/2) * screenHeight),
      bigStep = 10,
      hidden = function()
        if (IsParentDynamicGroup()) then
          return true;
        end
        if (data.parent or data.anchorFrameType ~= "SCREEN") then
          return true;
        end
        return data.anchorPoint:find("BOTTOM") or data.anchorPoint:find("TOP");
      end,
      get = function() return data.yOffset end,
      set = function(info, v)
        data.yOffset = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
        if(data.parent) then
          local parentData = WeakAuras.GetData(data.parent);
          if(parentData) then
            WeakAuras.Add(parentData);
            WeakAuras.SetThumbnail(parentData);
          end
        end
      end
    },
    yOffset3 = {
      type = "range",
      name = L["Y Offset"],
      order = 85,
      softMin = (-1 * screenHeight),
      softMax = 0,
      bigStep = 10,
      hidden = function()
        if (IsParentDynamicGroup()) then
          return true;
        end
        if (data.parent or data.anchorFrameType ~= "SCREEN") then
          return true;
        end
        return not data.anchorPoint:find("TOP");
      end,
      get = function() return data.yOffset end,
      set = function(info, v)
        data.yOffset = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
        if(data.parent) then
          local parentData = WeakAuras.GetData(data.parent);
          if(parentData) then
            WeakAuras.Add(parentData);
            WeakAuras.SetThumbnail(parentData);
          end
        end
      end
    },
    yOffset4 = {
      type = "range",
      name = L["Y Offset"],
      order = 85,
      softMin = (-1 * screenHeight),
      softMax = screenHeight,
      bigStep = 10,
      hidden = function()
        if (IsParentDynamicGroup()) then
          return true;
        end
        if (data.parent or data.anchorFrameType ~= "SCREEN") then
          return false;
        end
        return true;
      end,
      get = function() return data.yOffset end,
      set = function(info, v)
        data.yOffset = v;
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        WeakAuras.ResetMoverSizer();
        if(data.parent) then
          local parentData = WeakAuras.GetData(data.parent);
          if(parentData) then
            WeakAuras.Add(parentData);
            WeakAuras.SetThumbnail(parentData);
          end
        end
      end
    },
  };

  return union(input, positionOptions);
end

function WeakAuras.AddBorderOptions(input, id, data)
  local borderOptions = {
    border = {
      type = "toggle",
      name = L["Border"],
      order = 46.05
    },
    borderEdge = {
      type = "select",
      dialogControl = "LSM30_Border",
      name = L["Border Style"],
      order = 46.1,
      values = AceGUIWidgetLSMlists.border,
      disabled = function() return not data.border end,
      hidden = function() return not data.border end,
    },
    borderBackdrop = {
      type = "select",
      dialogControl = "LSM30_Background",
      name = L["Backdrop Style"],
      order = 46.2,
      values = AceGUIWidgetLSMlists.background,
      disabled = function() return not data.border end,
      hidden = function() return not data.border end,
    },
    borderOffset = {
      type = "range",
      name = L["Border Offset"],
      order = 46.3,
      softMin = 0,
      softMax = 32,
      bigStep = 1,
      disabled = function() return not data.border end,
      hidden = function() return not data.border end,
    },
    borderSize = {
      type = "range",
      name = L["Border Size"],
      order = 46.4,
      softMin = 1,
      softMax = 64,
      bigStep = 1,
      disabled = function() return not data.border end,
      hidden = function() return not data.border end,
    },
    borderInset = {
      type = "range",
      name = L["Border Inset"],
      order = 46.5,
      softMin = 1,
      softMax = 32,
      bigStep = 1,
      disabled = function() return not data.border end,
      hidden = function() return not data.border end,
    },
    borderColor = {
      type = "color",
      name = L["Border Color"],
      hasAlpha = true,
      order = 46.6,
      disabled = function() return not data.border end,
      hidden = function() return not data.border end,
    },
    backdropColor = {
      type = "color",
      name = L["Backdrop Color"],
      hasAlpha = true,
      order = 46.8,
      disabled = function() return not data.border end,
      hidden = function() return not data.border end,
    },
  }

  return union(input, borderOptions);
end

function WeakAuras.OpenTextEditor(...)
  frame.texteditor:Open(...);
end

function WeakAuras.ExportToString(id)
  frame.importexport:Open("export", id);
end

function WeakAuras.ExportToTable(id)
  frame.importexport:Open("table", id);
end

function WeakAuras.ImportFromString()
  frame.importexport:Open("import");
end

function WeakAuras.CloseImportExport()
  frame.codereview:Close();
  frame.importexport:Close();
end

function WeakAuras.ConvertDisplay(data, newType)
  local id = data.id;
  -- thumbnails[id].region:SetScript("OnUpdate", nil);
  thumbnails[id].region:Hide();
  thumbnails[id] = nil;

  WeakAuras.Convert(data, newType);
  displayButtons[id]:SetViewRegion(WeakAuras.regions[id].region);
  displayButtons[id]:Initialize();
  displayOptions[id] = nil;
  WeakAuras.AddOption(id, data);
  frame:FillOptions(displayOptions[id]);
  WeakAuras.UpdateDisplayButton(data);
  frame.mover.moving.region = WeakAuras.regions[id].region;
  WeakAuras.ResetMoverSizer();
end

function WeakAuras.NewDisplayButton(data)
  local id = data.id;
  WeakAuras.ScanForLoads();
  WeakAuras.EnsureDisplayButton(db.displays[id]);
  WeakAuras.UpdateDisplayButton(db.displays[id]);
  if(WeakAuras.regions[id].region.SetStacks) then
    WeakAuras.regions[id].region:SetStacks(1);
  end
  frame.buttonsScroll:AddChild(displayButtons[id]);
  WeakAuras.AddOption(id, data);
  WeakAuras.SetIconNames(data);
  WeakAuras.SortDisplayButtons();
end

function WeakAuras.UpdateGroupOrders(data)
  if(data.controlledChildren) then
    local total = #data.controlledChildren;
    for index, id in pairs(data.controlledChildren) do
      local button = WeakAuras.GetDisplayButton(id);
      button:SetGroupOrder(index, total);
    end
  end
end

function WeakAuras.UpdateButtonsScroll()
  if WeakAuras.IsOptionsProcessingPaused() then return end
  frame.buttonsScroll:DoLayout()
end

local previousFilter;
function WeakAuras.SortDisplayButtons(filter, overrideReset, id)
  if (WeakAuras.IsOptionsProcessingPaused()) then
    return;
  end
  local recenter = false;
  filter = filter or (overrideReset and previousFilter or "");
  if(frame.filterInput:GetText() ~= filter) then
    frame.filterInput:SetText(filter);
  end
  if(previousFilter and previousFilter ~= "" and (filter == "" or not filter)) then
    recenter = true;
  end
  previousFilter = filter;
  filter = filter:lower();

  wipe(frame.buttonsScroll.children);
  tinsert(frame.buttonsScroll.children, frame.newButton);
  if(frame.addonsButton) then
    tinsert(frame.buttonsScroll.children, frame.addonsButton);
  end
  tinsert(frame.buttonsScroll.children, frame.loadedButton);
  local numLoaded = 0;
  local to_sort = {};
  local children = {};
  local containsFilter = false;
  for id, child in pairs(displayButtons) do
    containsFilter = false;
    local data = WeakAuras.GetData(id);
    if not(data) then
      print("No data for", id);
    else
      if(filter and data.controlledChildren) then
        for index, childId in pairs(data.controlledChildren) do
          if(childId:lower():find(filter, 1, true)) then
            containsFilter = true;
            break;
          end
        end
      end
      if(
        frame.loadedButton:GetExpanded()
        and (not filter or id:lower():find(filter, 1, true) or containsFilter)
        ) then
        child.frame:Show();
        local group = child:GetGroup();
        if(group) then
          if(loaded[group]) then
            if(loaded[id]) then
              child:EnableLoaded();
            else
              child:DisableLoaded();
            end
            children[group] = children[group] or {};
            tinsert(children[group], child);
          end
        else
          if(loaded[id] ~= nil) then
            if(loaded[id]) then
              child:EnableLoaded();
            else
              child:DisableLoaded();
            end
            tinsert(to_sort, child);
          end
        end
      else
        child.frame:Hide();
      end
    end
  end
  table.sort(to_sort, function(a, b) return a:GetTitle() < b:GetTitle() end);
  for _, child in ipairs(to_sort) do
    tinsert(frame.buttonsScroll.children, child);
    local controlledChildren = children[child:GetTitle()];
    if(controlledChildren) then
      table.sort(controlledChildren, function(a, b) return a:GetGroupOrder() < b:GetGroupOrder(); end);
      for _, groupchild in ipairs(controlledChildren) do
        if(child:GetExpanded()) then
          tinsert(frame.buttonsScroll.children, groupchild);
        else
          groupchild.frame:Hide();
        end
      end
    end
  end

  tinsert(frame.buttonsScroll.children, frame.unloadedButton);
  local numUnloaded = 0;
  wipe(to_sort);
  wipe(children);
  for id, child in pairs(displayButtons) do
    containsFilter = false;
    local data = WeakAuras.GetData(id);
    if(filter and data.controlledChildren) then
      for index, childId in pairs(data.controlledChildren) do
        if(childId:lower():find(filter, 1, true)) then
          containsFilter = true;
          break;
        end
      end
    end
    if(
      frame.unloadedButton:GetExpanded()
      and (not filter or id:lower():find(filter, 1, true) or containsFilter)
      ) then
      local group = child:GetGroup();
      if(group) then
        if not(loaded[group]) then
          if(loaded[id]) then
            child:EnableLoaded();
          else
            child:DisableLoaded();
          end
          children[group] = children[group] or {};
          tinsert(children[group], child);
        end
      else
        if(loaded[id] == nil) then
          child:DisableLoaded();
          tinsert(to_sort, child);
        end
      end
    else
      child.frame:Hide();
    end
  end
  table.sort(to_sort, function(a, b) return a:GetTitle() < b:GetTitle() end);
  for _, child in ipairs(to_sort) do
    tinsert(frame.buttonsScroll.children, child);
    local controlledChildren = children[child:GetTitle()];
    if(controlledChildren) then
      table.sort(controlledChildren, function(a, b) return a:GetGroupOrder() < b:GetGroupOrder(); end);
      for _, groupchild in ipairs(controlledChildren) do
        if(child:GetExpanded()) then
          tinsert(frame.buttonsScroll.children, groupchild);
        else
          groupchild.frame:Hide();
        end
      end
    end
  end

  frame.buttonsScroll:DoLayout();
  if(recenter) then
    frame:CenterOnPicked();
  end
end

WeakAuras.afterScanForLoads = function()
  if(frame) then
    if (frame:IsVisible()) then
      WeakAuras.SortDisplayButtons();
    else
      frame.needsSort = true;
    end
  end
end

function WeakAuras.IsPickedMultiple()
  if(frame.pickedDisplay == tempGroup) then
    return true;
  else
    return false;
  end
end

function WeakAuras.IsDisplayPicked(id)
  if(frame.pickedDisplay == tempGroup) then
    for index, childId in pairs(tempGroup.controlledChildren) do
      if(id == childId) then
        return true;
      end
    end
    return false;
  else
    return frame.pickedDisplay == id;
  end
end

function WeakAuras.PickDisplay(id)
  frame:PickDisplay(id);
end

function WeakAuras.PickAndEditDisplay(id)
  frame:PickDisplay(id);
  displayButtons[id].callbacks.OnRenameClick();
end

function WeakAuras.PickDisplayMultiple(id)
  frame:PickDisplayMultiple(id);
end

function WeakAuras.GetDisplayButton(id)
  if(id and displayButtons[id]) then
    return displayButtons[id];
  end
end

function WeakAuras.AddDisplayButton(data)
  WeakAuras.EnsureDisplayButton(data);
  WeakAuras.UpdateDisplayButton(data);
  frame.buttonsScroll:AddChild(displayButtons[data.id]);
  WeakAuras.AddOption(data.id, data);
  WeakAuras.SetIconNames(data);
  if(WeakAuras.regions[data.id] and WeakAuras.regions[data.id].region.SetStacks) then
    WeakAuras.regions[data.id].region:SetStacks(1);
  end
end

function WeakAuras.EnsureDisplayButton(data)
  local id = data.id;
  if not(displayButtons[id]) then
    displayButtons[id] = AceGUI:Create("WeakAurasDisplayButton");
    if(displayButtons[id]) then
      displayButtons[id]:SetData(data);
      displayButtons[id]:Initialize();
    else
      print("Error creating button for", id);
    end
  end
end

function WeakAuras.SetCopying(data)
  for id, button in pairs(displayButtons) do
    button:SetCopying(data);
  end
end

function WeakAuras.SetGrouping(data)
  for id, button in pairs(displayButtons) do
    button:SetGrouping(data);
  end
end

function WeakAuras.SetDragging(data, drop)
  WeakAuras_DropDownMenu:Hide()
  for id, button in pairs(displayButtons) do
    button:SetDragging(data, drop)
  end
end

function WeakAuras.DropIndicator()
  local indicator = frame.dropIndicator
  if not indicator then
    indicator = CreateFrame("Frame", "WeakAuras_DropIndicator")
    indicator:SetHeight(4)
    indicator:SetFrameStrata("FULLSCREEN")

    local texture = indicator:CreateTexture(nil, "FULLSCREEN")
    texture:SetBlendMode("ADD")
    texture:SetAllPoints(indicator)
    texture:SetTexture("Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight")

    local icon = indicator:CreateTexture(nil, "OVERLAY")
    icon:SetSize(16,16)
    icon:SetPoint("CENTER", indicator)

    indicator.icon = icon
    indicator.texture = texture
    frame.dropIndicator = indicator
    indicator:Hide()
  end
  return indicator
end

function WeakAuras.UpdateDisplayButton(data)
  local id = data.id;
  local button = displayButtons[id];
  if (button) then
    button:SetIcon(WeakAuras.SetThumbnail(data));
  end
end

function WeakAuras.SetThumbnail(data)
  local regionType = data.regionType;
  local regionTypes = WeakAuras.regionTypes;
  if not(regionType) then
    error("Improper arguments to WeakAuras.SetThumbnail - regionType not defined");
  else
    local id = data.id;
    local button = displayButtons[id];
    if (not button) then return end;
    local thumbnail;
    if((not thumbnails[id]) or (not thumbnails[id].region) or thumbnails[id].regionType ~= regionType) then
      if(regionOptions[regionType] and regionOptions[regionType].createThumbnail and regionOptions[regionType].modifyThumbnail) then
        thumbnail = regionOptions[regionType].createThumbnail(button.frame, regionTypes[regionType].create);
      else
        thumbnail = button.frame:CreateTexture();
        thumbnail:SetTexture("Interface\\Icons\\INV_Misc_QuestionMark");
      end
      thumbnails[id] = {
        regionType = regionType,
        region = thumbnail
      };
    end

    thumbnail = thumbnails[id].region;
    if(regionOptions[regionType] and regionOptions[regionType].modifyThumbnail) then
      WeakAuras.validate(data, regionTypes[regionType].default);
      regionOptions[regionType].modifyThumbnail(button.frame, thumbnail, data, regionTypes[regionType].modify);
    end

    return thumbnail;
  end
end

function WeakAuras.OpenTexturePicker(data, field, textures, stopMotion)
  frame.texturePicker:Open(data, field, textures, stopMotion);
end

function WeakAuras.OpenIconPicker(data, field)
  frame.iconPicker:Open(data, field);
end

function WeakAuras.OpenModelPicker(data, field)
  if not(IsAddOnLoaded("WeakAurasModelPaths")) then
    local loaded, reason = LoadAddOn("WeakAurasModelPaths");
    if not(loaded) then
      print("|cff9900FF".."WeakAurasModelPaths"..FONT_COLOR_CODE_CLOSE.." could not be loaded: "..RED_FONT_COLOR_CODE.._G["ADDON_"..reason]);
      WeakAuras.ModelPaths = {};
    end
    frame.modelPicker.modelTree:SetTree(WeakAuras.ModelPaths);
  end
  frame.modelPicker:Open(data, field);
end

function WeakAuras.OpenCodeReview(data)
  frame.codereview:Open(data);
end

function WeakAuras.CloseCodeReview(data)
  frame.codereview:Close();
end

function WeakAuras.OpenTriggerTemplate(data)
  if not(IsAddOnLoaded("WeakAurasTemplates")) then
    local loaded, reason = LoadAddOn("WeakAurasTemplates");
    if not(loaded) then
      print("|cff9900FF".."WeakAurasTemplates"..FONT_COLOR_CODE_CLOSE.." could not be loaded: "..RED_FONT_COLOR_CODE.._G["ADDON_"..reason]);
      return;
    end
    frame.newView = WeakAuras.CreateTemplateView(frame);
  end
  frame.newView:Open(data);
end

function WeakAuras.ResetMoverSizer()
  if(frame and frame.mover and frame.moversizer and frame.mover.moving.region and frame.mover.moving.data) then
    frame.moversizer:SetToRegion(frame.mover.moving.region, frame.mover.moving.data);
  end
end

function WeakAuras.ShowCloneDialog(data)
  if(
    not(
    data.parent
    and WeakAuras.GetData(data.parent)
    and WeakAuras.GetData(data.parent).regionType == "dynamicgroup"
    )
    and not(odb.preventCloneDialog)
    ) then
    StaticPopupDialogs["WEAKAURAS_CLONE_OPTION_ENABLED"] = {
      text = L["Clone option enabled dialog"],
      button1 = L["Yes"],
      button2 = L["No"],
      button3 = L["Never"],
      OnAccept = function()
        local new_id = data.id.." Group";
        local num = 2;
        while(WeakAuras.GetData(new_id)) do
          new_id = "New "..num;
          num = num + 1;
        end

        local parentData = {
          id = new_id,
          regionType = "dynamicgroup",
          trigger = {},
          load = {}
        };
        WeakAuras.Add(parentData);
        WeakAuras.NewDisplayButton(parentData);

        tinsert(parentData.controlledChildren, data.id);
        data.parent = parentData.id;
        WeakAuras.Add(parentData);
        WeakAuras.Add(data);

        local button = WeakAuras.GetDisplayButton(data.id);
        button:SetGroup(parentData.id, true);
        button:SetGroupOrder(1, #parentData.controlledChildren);

        local parentButton = WeakAuras.GetDisplayButton(parentData.id);
        parentButton.callbacks.UpdateExpandButton();
        WeakAuras.UpdateDisplayButton(parentData);
        WeakAuras.ReloadGroupRegionOptions(parentData);
        WeakAuras.SortDisplayButtons();
        parentButton:Expand();

        pickonupdate = data.id;
      end,
      OnCancel = function()
      -- do nothing
      end,
      OnAlt = function()
        odb.preventCloneDialog = true
      end,
      hideOnEscape = true,
      whileDead = true,
      timeout = 0,
      preferredindex = STATICPOPUP_NUMDIALOGS
    };

    StaticPopup_Show("WEAKAURAS_CLONE_OPTION_ENABLED");
  end
end

function WeakAuras.ShowSpellIDDialog(trigger, id)
  if not(odb.preventSpellIDDialog) then
    StaticPopupDialogs["WEAKAURAS_SPELLID_CHECK"] = {
      text = L["Spell ID dialog"],
      button1 = L["Yes"],
      button2 = L["No"],
      button3 = L["Never"],
      OnAccept = function()
        trigger.fullscan = true;
        trigger.use_spellId = true;
        trigger.spellId = id;

        AceConfigDialog:Open("WeakAuras", frame.container);
      end,
      OnCancel = function()
      -- do nothing
      end,
      OnAlt = function()
        odb.preventSpellIDDialog = true
      end,
      hideOnEscape = true,
      whileDead = true,
      timeout = 0,
      preferredindex = STATICPOPUP_NUMDIALOGS
    };

    StaticPopup_Show("WEAKAURAS_SPELLID_CHECK");
  end
end

-- Lua APIs
local tinsert, tconcat, tremove, wipe = table.insert, table.concat, table.remove, wipe
local select, pairs, next, type, unpack = select, pairs, next, type, unpack

local AceGUI = LibStub("AceGUI-3.0")

-- GLOBALS: WeakAuras WeakAurasOptions

local collisions = WeakAuras.collisions
local displayButtons = WeakAuras.displayButtons
local savedVars = WeakAuras.savedVars
local thumbnails = WeakAuras.thumbnails

local importAddonButtons = {}
local importDisplayButtons = {}
WeakAuras.importDisplayButtons = importDisplayButtons

function WeakAuras.CreateImportButtons()
  wipe(importAddonButtons);
  wipe(importDisplayButtons);
  for addonName, addonData in pairs(WeakAuras.addons) do
    local addonButton = AceGUI:Create("WeakAurasImportButton");
    importAddonButtons[addonName] = addonButton;
    addonButton:SetTitle(addonData.displayName);
    addonButton:SetIcon(addonData.icon);
    addonButton:SetDescription(addonData.description);
    addonButton:SetClick(function()
      if(addonButton.checkbox:GetChecked()) then
        for id, data in pairs(addonData.displays) do
          if not(data.parent) then
            local childButton = importDisplayButtons[id];
            childButton.checkbox:SetChecked(true);
            WeakAuras.EnableAddonDisplay(id);
          end
        end
        for id, data in pairs(addonData.displays) do
          if(data.parent) then
            local childButton = importDisplayButtons[id];
            childButton.checkbox:SetChecked(true);
            WeakAuras.EnableAddonDisplay(id);
          end
        end
      else
        for id, data in pairs(addonData.displays) do
          if not(data.parent) then
            local childButton = importDisplayButtons[id];
            childButton.checkbox:SetChecked(false);
            WeakAuras.DisableAddonDisplay(id);
          end
        end
        for id, data in pairs(addonData.displays) do
          if(data.parent) then
            local childButton = importDisplayButtons[id];
            childButton.checkbox:SetChecked(false);
            WeakAuras.DisableAddonDisplay(id);
          end
        end
      end
      WeakAuras.ResolveCollisions(function()
        for groupId, dataFromAddon in pairs(addonData.displays) do
          if(dataFromAddon.controlledChildren) then
            local data = WeakAuras.GetData(groupId);
            if(data) then
              for index, childId in pairs(data.controlledChildren) do
                local childButton = WeakAuras.GetDisplayButton(childId);
                childButton:SetGroup(groupId, data.regionType == "dynamicgroup");
                childButton:SetGroupOrder(index, #data.controlledChildren);
              end

              local button = WeakAuras.GetDisplayButton(groupId);
              button.callbacks.UpdateExpandButton();
              WeakAuras.UpdateDisplayButton(data);
              WeakAuras.ReloadGroupRegionOptions(data);
            end
          end
        end

        WeakAuras.ScanForLoads();
        WeakAuras.SortDisplayButtons();
      end);
    end);

    local function UpdateAddonChecked()
      local shouldBeChecked = true;
      for id, data in pairs(addonData.displays) do
        if not(WeakAuras.IsDefinedByAddon(id)) then
          shouldBeChecked = false;
          break;
        end
      end
      addonButton.checkbox:SetChecked(shouldBeChecked);
    end

    local numAddonDisplays = 0;
    for id, data in pairs(addonData.displays) do
      if(data.controlledChildren) then
        numAddonDisplays = numAddonDisplays + 1;
        local groupButton = AceGUI:Create("WeakAurasImportButton");
        importDisplayButtons[id] = groupButton;

        groupButton:SetTitle(id);
        groupButton:SetDescription(data.desc);

        local numGroupDisplays = 0;

        local function UpdateGroupChecked()
          local shouldBeChecked = true;
          for index, childId in pairs(data.controlledChildren) do
            if not(WeakAuras.IsDefinedByAddon(childId)) then
              shouldBeChecked = false;
              break;
            end
          end
          groupButton.checkbox:SetChecked(shouldBeChecked);
          UpdateAddonChecked();
        end

        for index, childId in pairs(data.controlledChildren) do
          numGroupDisplays = numGroupDisplays + 1;
          numAddonDisplays = numAddonDisplays + 1;
          local childButton = AceGUI:Create("WeakAurasImportButton");
          importDisplayButtons[childId] = childButton;

          local data = WeakAuras.addons[addonName].displays[childId];

          childButton:SetTitle(childId);
          childButton:SetDescription(data.desc);
          childButton:SetExpandVisible(false);
          childButton:SetLevel(3);

          childButton:SetClick(function()
            if(childButton.checkbox:GetChecked()) then
              WeakAuras.EnableAddonDisplay(childId);
            else
              WeakAuras.DisableAddonDisplay(childId);
            end
            WeakAuras.ResolveCollisions(function()
              WeakAuras.ScanForLoads();
              WeakAuras.SortDisplayButtons();
              UpdateGroupChecked();
            end);
          end);
          childButton.updateChecked = UpdateGroupChecked;
          childButton.checkbox:SetChecked(WeakAuras.IsDefinedByAddon(childId));
        end

        groupButton:SetClick(function()
          if(groupButton.checkbox:GetChecked()) then
            WeakAuras.EnableAddonDisplay(id);
            for index, childId in pairs(data.controlledChildren) do
              local childButton = importDisplayButtons[childId];
              childButton.checkbox:SetChecked(true);
              WeakAuras.EnableAddonDisplay(childId);
            end
          else
            WeakAuras.DisableAddonDisplay(id);
            for index, childId in pairs(data.controlledChildren) do
              local childButton = importDisplayButtons[childId];
              childButton.checkbox:SetChecked(false);
              WeakAuras.DisableAddonDisplay(childId);
            end
          end
          WeakAuras.ResolveCollisions(function()
            local data = WeakAuras.GetData(id);
            if(data) then
              for index, childId in pairs(data.controlledChildren) do
                local childButton = WeakAuras.GetDisplayButton(childId);
                childButton:SetGroup(id, data.regionType == "dynamicgroup");
                childButton:SetGroupOrder(index, #data.controlledChildren);
              end

              local button = WeakAuras.GetDisplayButton(id);
              button.callbacks.UpdateExpandButton();
              WeakAuras.UpdateDisplayButton(data);
              WeakAuras.ReloadGroupRegionOptions(data);
            end

            WeakAuras.ScanForLoads();
            WeakAuras.SortDisplayButtons();
            UpdateAddonChecked();
          end);
        end);
        groupButton.updateChecked = UpdateAddonChecked;
        groupButton:SetExpandVisible(true);
        if(numGroupDisplays > 0) then
          groupButton:EnableExpand();
          groupButton:SetOnExpandCollapse(WeakAuras.SortImportButtons);
        end
        groupButton:SetLevel(2);
        UpdateGroupChecked();
      elseif not(importDisplayButtons[id]) then
        numAddonDisplays = numAddonDisplays + 1;
        local displayButton = AceGUI:Create("WeakAurasImportButton");
        importDisplayButtons[id] = displayButton;

        displayButton:SetTitle(id);
        displayButton:SetDescription(data.desc);
        displayButton:SetExpandVisible(false);
        displayButton:SetLevel(2);

        displayButton:SetClick(function()
          if(displayButton.checkbox:GetChecked()) then
            WeakAuras.EnableAddonDisplay(id);
          else
            WeakAuras.DisableAddonDisplay(id);
          end
          WeakAuras.ResolveCollisions(function()
            WeakAuras.SortDisplayButtons()
            UpdateAddonChecked();
          end);
        end);
        displayButton.updateChecked = UpdateAddonChecked;
        displayButton.checkbox:SetChecked(WeakAuras.IsDefinedByAddon(id));
      end
    end

    addonButton:SetExpandVisible(true);
    if(numAddonDisplays > 0) then
      addonButton:EnableExpand();
      addonButton:SetOnExpandCollapse(WeakAuras.SortImportButtons);
    end
    addonButton:SetLevel(1);
    UpdateAddonChecked();
  end
end

local container = nil;
function WeakAuras.SortImportButtons(newContainer)
  container = newContainer or container;
  wipe(container.children);
  local toSort = {};
  for addon, addonData in pairs(WeakAuras.addons) do
    container:AddChild(importAddonButtons[addon]);
    wipe(toSort);
    for id, data in pairs(addonData.displays) do
      if not(data.parent) then
        tinsert(toSort, id);
      end
    end
    table.sort(toSort, function(a, b) return a < b end);
    for index, id in ipairs(toSort) do
      if(importAddonButtons[addon]:GetExpanded()) then
        importDisplayButtons[id].frame:Show();
        container:AddChild(importDisplayButtons[id]);
      else
        importDisplayButtons[id].frame:Hide();
      end
      if(addonData.displays[id].controlledChildren) then
        for childIndex, childId in pairs(addonData.displays[id].controlledChildren) do
          if(importAddonButtons[addon]:GetExpanded() and importDisplayButtons[id]:GetExpanded()) then
            importDisplayButtons[childId].frame:Show();
            container:AddChild(importDisplayButtons[childId]);
          else
            importDisplayButtons[childId].frame:Hide();
          end
        end
      end
    end
  end

  container:DoLayout();
end

function WeakAuras.EnableAddonDisplay(id)
  local db = savedVars.db
  if not(db.registered[id]) then
    local addon, data;
    for addonName, addonData in pairs(WeakAuras.addons) do
      if(addonData.displays[id]) then
        addon = addonName;
        data = {}
        WeakAuras.DeepCopy(addonData.displays[id], data);
        break;
      end
    end

    if(db.displays[id]) then
      -- ID collision
      collisions[id] = {addon, data};
    else
      db.registered[id] = addon;
      if(data.controlledChildren) then
        wipe(data.controlledChildren);
      end
      WeakAuras.Add(data);
      WeakAuras.SyncParentChildRelationships(true);
      WeakAuras.AddDisplayButton(data);
    end
  end
end

-- This function overrides the WeakAuras.CollisionResolved that is defined in WeakAuras.lua,
-- ensuring that sidebar buttons are created properly after collision resolution
function WeakAuras.CollisionResolved(addon, data, force)
  WeakAuras.EnableAddonDisplay(data.id);
end

function WeakAuras.DisableAddonDisplay(id)
  local frame = WeakAuras.OptionsFrame()
  local db = savedVars.db
  db.registered[id] = false;
  local data = WeakAuras.GetData(id);
  if(data) then
    local parentData;
    if(data.parent) then
      parentData = db.displays[data.parent];
    end

    if(data.controlledChildren) then
      for index, childId in pairs(data.controlledChildren) do
        local childButton = displayButtons[childId];
        if(childButton) then
          childButton:SetGroup();
        end
        local childData = db.displays[childId];
        if(childData) then
          childData.parent = nil;
        end
      end
    end

    WeakAuras.Delete(data);
    WeakAuras.SyncParentChildRelationships(true);
    frame.buttonsScroll:DeleteChild(displayButtons[id]);
    thumbnails[id].region:Hide();
    thumbnails[id] = nil;
    displayButtons[id] = nil;

    if(parentData and parentData.controlledChildren) then
      for index, childId in pairs(parentData.controlledChildren) do
        local childButton = displayButtons[childId];
        if(childButton) then
          childButton:SetGroupOrder(index, #parentData.controlledChildren);
        end
      end
      WeakAuras.Add(parentData);
      WeakAuras.ReloadGroupRegionOptions(parentData);
      WeakAuras.UpdateDisplayButton(parentData);
    end
  end
end

-- Lua APIs
local tinsert, tconcat, tremove, wipe = table.insert, table.concat, table.remove, wipe
local select, pairs, next, type, unpack, error = select, pairs, next, type, unpack, error
local _G = _G

-- WoW APIs
local GetScreenWidth, GetScreenHeight, GetTime, CreateFrame, GetAddOnInfo, PlaySound, IsAddOnLoaded, LoadAddOn, UnitName
  = GetScreenWidth, GetScreenHeight, GetTime, CreateFrame, GetAddOnInfo, PlaySound, IsAddOnLoaded, LoadAddOn, UnitName

-- GLOBALS: WeakAuras WeakAuras_DropDownMenu
-- GLOBALS: GameTooltip GameTooltip_Hide UIParent FONT_COLOR_CODE_CLOSE RED_FONT_COLOR_CODE GetAddOnEnableState

local AceGUI = LibStub("AceGUI-3.0")
local AceConfig = LibStub("AceConfig-3.0")
local AceConfigDialog = LibStub("AceConfigDialog-3.0")

local WeakAuras = WeakAuras
local L = WeakAuras.L

local displayButtons = WeakAuras.displayButtons
local displayOptions = WeakAuras.displayOptions
local loaded = WeakAuras.loaded
local regionOptions = WeakAuras.regionOptions
local savedVars = WeakAuras.savedVars
local tempGroup = WeakAuras.tempGroup

local function CreateDecoration(frame)
  local deco = CreateFrame("Frame", nil, frame)
  deco:SetSize(17, 40)

  local bg1 = deco:CreateTexture(nil, "BACKGROUND")
  bg1:SetTexture("Interface\\DialogFrame\\UI-DialogBox-Header")
  bg1:SetTexCoord(0.31, 0.67, 0, 0.63)
  bg1:SetAllPoints(deco)

  local bg2 = deco:CreateTexture(nil, "BACKGROUND")
  bg2:SetTexture("Interface\\DialogFrame\\UI-DialogBox-Header")
  bg2:SetTexCoord(0.235, 0.275, 0, 0.63)
  bg2:SetPoint("RIGHT", bg1, "LEFT")
  bg2:SetSize(10, 40)

  local bg3 = deco:CreateTexture(nil, "BACKGROUND")
  bg3:SetTexture("Interface\\DialogFrame\\UI-DialogBox-Header")
  bg3:SetTexCoord(0.72, 0.76, 0, 0.63)
  bg3:SetPoint("LEFT", bg1, "RIGHT")
  bg3:SetSize(10, 40)

  return deco
end

local function CreateDecorationWide(frame)
  local deco1 = frame:CreateTexture(nil, "OVERLAY")
  deco1:SetTexture("Interface\\DialogFrame\\UI-DialogBox-Header")
  deco1:SetTexCoord(0.31, 0.67, 0, 0.63)
  deco1:SetSize(120, 40)

  local deco2 = frame:CreateTexture(nil, "OVERLAY")
  deco2:SetTexture("Interface\\DialogFrame\\UI-DialogBox-Header")
  deco2:SetTexCoord(0.21, 0.31, 0, 0.63)
  deco2:SetPoint("RIGHT", deco1, "LEFT")
  deco2:SetSize(30, 40)

  local deco3 = frame:CreateTexture(nil, "OVERLAY")
  deco3:SetTexture("Interface\\DialogFrame\\UI-DialogBox-Header")
  deco3:SetTexCoord(0.67, 0.77, 0, 0.63)
  deco3:SetPoint("LEFT", deco1, "RIGHT")
  deco3:SetSize(30, 40)

  return deco1
end

local function CreateFrameSizer(frame, callback)
  callback = callback or (function() end)

  local handle = CreateFrame("BUTTON", nil, frame)
  handle:SetPoint("BOTTOMLEFT", frame)
  handle:SetSize(25, 25)
  handle:EnableMouse()

  handle:SetScript("OnMouseDown", function() frame:StartSizing("BOTTOMLEFT") end)
  handle:SetScript("OnMouseUp", function()
    frame:StopMovingOrSizing()
    callback()
  end)

  local normal = handle:CreateTexture(nil, "OVERLAY")
  normal:SetTexture("Interface\\ChatFrame\\UI-ChatIM-SizeGrabber-Up")
  normal:SetTexCoord(1, 0, 0, 1)
  normal:SetPoint("BOTTOMLEFT", handle, 6, 6)
  normal:SetPoint("TOPRIGHT", handle)
  handle:SetNormalTexture(normal)

  local pushed = handle:CreateTexture(nil, "OVERLAY")
  pushed:SetTexture("Interface\\ChatFrame\\UI-ChatIM-SizeGrabber-Down")
  pushed:SetTexCoord(1, 0, 0, 1)
  pushed:SetPoint("BOTTOMLEFT", handle, 6, 6)
  pushed:SetPoint("TOPRIGHT", handle)
  handle:SetPushedTexture(pushed)

  local highlight = handle:CreateTexture(nil, "OVERLAY")
  highlight:SetTexture("Interface\\ChatFrame\\UI-ChatIM-SizeGrabber-Highlight")
  highlight:SetTexCoord(1, 0, 0, 1)
  highlight:SetPoint("BOTTOMLEFT", handle, 6, 6)
  highlight:SetPoint("TOPRIGHT", handle)
  handle:SetHighlightTexture(highlight)

  return handle
end

function WeakAuras.CreateFrame()
  local WeakAuras_DropDownMenu = CreateFrame("frame", "WeakAuras_DropDownMenu", nil, "UIDropDownMenuTemplate");
  local frame;
  local db = savedVars.db;
  local odb = savedVars.odb;
  -------- Mostly Copied from AceGUIContainer-Frame--------
  frame = CreateFrame("FRAME", nil, UIParent);
  frame:SetBackdrop({
    bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background",
    edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
    tile = true,
    tileSize = 32,
    edgeSize = 32,
    insets = { left = 8, right = 8, top = 8, bottom = 8 }
  });
  frame:SetBackdropColor(0, 0, 0, 1);
  frame:EnableMouse(true);
  frame:SetMovable(true);
  frame:SetResizable(true);
  frame:SetMinResize(610, 240);
  frame:SetFrameStrata("DIALOG");
  frame.window = "default";

  local xOffset, yOffset;
  if(db.frame) then
    xOffset, yOffset = db.frame.xOffset, db.frame.yOffset;
  end
  if not(xOffset and yOffset) then
    xOffset = (610 - GetScreenWidth()) / 2;
    yOffset = (492 - GetScreenHeight()) / 2;
  end
  frame:SetPoint("TOPRIGHT", UIParent, "TOPRIGHT", xOffset, yOffset);
  frame:Hide();

  local width, height;
  if(db.frame) then
    width, height = db.frame.width, db.frame.height;
  end
  if not(width and height) then
    width, height = 630, 492;
  end
  frame:SetWidth(width);
  frame:SetHeight(height);

  local close = CreateDecoration(frame)
  close:SetPoint("TOPRIGHT", -30, 12)

  local closebutton = CreateFrame("BUTTON", nil, close)
  closebutton:SetWidth(30);
  closebutton:SetHeight(30);
  closebutton:SetPoint("CENTER", close, "CENTER", 1, -1);
  closebutton:SetNormalTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Up.blp");
  closebutton:SetPushedTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Down.blp");
  closebutton:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  closebutton:SetScript("OnClick", WeakAuras.HideOptions);

  local import = CreateDecoration(frame)
  import:SetPoint("TOPRIGHT", -100, 12)
  --import:Hide()

  local importbutton = CreateFrame("CheckButton", nil, import, "OptionsCheckButtonTemplate")
  importbutton:SetWidth(30);
  importbutton:SetHeight(30);
  importbutton:SetPoint("CENTER", import, "CENTER", 1, -1);
  importbutton:SetHitRectInsets(0,0,0,0)
  importbutton:SetChecked(db.import_disabled)

  importbutton:SetScript("PostClick", function(self)
    if self:GetChecked() then
      PlaySound("igMainMenuOptionCheckBoxOn")
      db.import_disabled = true
    else
      PlaySound("igMainMenuOptionCheckBoxOff")
      db.import_disabled = nil
    end
  end)
  importbutton:SetScript("OnEnter", function(self)
    GameTooltip:SetOwner(self, "ANCHOR_CURSOR")
    GameTooltip:SetText("Disable Import")
    GameTooltip:AddLine("If this option is enabled, you are no longer able to import auras.", 1, 1, 1)
    GameTooltip:Show()
  end)
  importbutton:SetScript("OnLeave", GameTooltip_Hide)

  local titlebg = CreateDecorationWide(frame)
  titlebg:SetPoint("TOP", 0, 12)

  local title = CreateFrame("Frame", nil, frame)

  local function commitWindowChanges()
    local xOffset = frame:GetRight() - GetScreenWidth();
    local yOffset = frame:GetTop() - GetScreenHeight();
    if(title:GetRight() > GetScreenWidth()) then
      xOffset = xOffset + (GetScreenWidth() - title:GetRight());
    elseif(title:GetLeft() < 0) then
      xOffset = xOffset + (0 - title:GetLeft());
    end
    if(title:GetTop() > GetScreenHeight()) then
      yOffset = yOffset + (GetScreenHeight() - title:GetTop());
    elseif(title:GetBottom() < 0) then
      yOffset = yOffset + (0 - title:GetBottom());
    end
    db.frame = db.frame or {};
    db.frame.xOffset = xOffset;
    db.frame.yOffset = yOffset;
    if(not frame.minimized) then
      db.frame.width = frame:GetWidth();
      db.frame.height = frame:GetHeight();
    end
    frame:ClearAllPoints();
    frame:SetPoint("TOPRIGHT", UIParent, "TOPRIGHT", xOffset, yOffset);
  end

  title:EnableMouse(true)
  title:SetScript("OnMouseDown", function() frame:StartMoving() end)
  title:SetScript("OnMouseUp", function()
    frame:StopMovingOrSizing();
    commitWindowChanges();
  end);
  title:SetPoint("BOTTOMLEFT", titlebg, "BOTTOMLEFT", -25, 0);
  title:SetPoint("TOPRIGHT", titlebg, "TOPRIGHT", 25, 0);

  local titletext = title:CreateFontString(nil, "OVERLAY", "GameFontNormal")
  titletext:SetPoint("TOP", titlebg, "TOP", 0, -14)
  titletext:SetText(L["WeakAurasOptions"]);

  frame.sizer = CreateFrameSizer(frame, commitWindowChanges);

  local minimize = CreateDecoration(frame)
  minimize:SetPoint("TOPRIGHT", -65, 12)

  local minimizebutton = CreateFrame("BUTTON", nil, minimize)
  minimizebutton:SetWidth(30);
  minimizebutton:SetHeight(30);
  minimizebutton:SetPoint("CENTER", minimize, "CENTER", 1, -1);
  minimizebutton:SetNormalTexture("Interface\\BUTTONS\\UI-Panel-CollapseButton-Up.blp");
  minimizebutton:SetPushedTexture("Interface\\BUTTONS\\UI-Panel-CollapseButton-Down.blp");
  minimizebutton:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  minimizebutton:SetScript("OnClick", function()
    if(frame.minimized) then
      frame.minimized = nil;
      if db.frame then
        if db.frame.height < 240 then
          db.frame.height = 500
        end
      end
      frame:SetHeight(db.frame and db.frame.height or 500);
      if(frame.window == "default") then
        frame.buttonsContainer.frame:Show();
        frame.container.frame:Show();
      elseif(frame.window == "texture") then
        frame.texturePicker.frame:Show();
      elseif(frame.window == "icon") then
        frame.iconPicker.frame:Show();
      elseif(frame.window == "model") then
        frame.modelPicker.frame:Show();
      elseif(frame.window == "importexport") then
        frame.importexport.frame:Show();
      elseif(frame.window == "texteditor") then
        frame.texteditor.frame:Show();
      elseif(frame.window == "codereview") then
        frame.codereview.frame:Show();
      elseif(frame.window == "newview") then
        frame.newView.frame:Show();
      end
      minimizebutton:SetNormalTexture("Interface\\BUTTONS\\UI-Panel-CollapseButton-Up.blp");
      minimizebutton:SetPushedTexture("Interface\\BUTTONS\\UI-Panel-CollapseButton-Down.blp");
    else
      frame.minimized = true;
      frame:SetHeight(40);
      frame.buttonsContainer.frame:Hide();
      frame.texturePicker.frame:Hide();
      frame.iconPicker.frame:Hide();
      frame.modelPicker.frame:Hide();
      frame.importexport.frame:Hide();
      frame.texteditor.frame:Hide();
      frame.codereview.frame:Hide();
      if (frame.newView) then
        frame.newView.frame:Hide();
      end
      frame.container.frame:Hide();
      minimizebutton:SetNormalTexture("Interface\\BUTTONS\\UI-Panel-ExpandButton-Up.blp");
      minimizebutton:SetPushedTexture("Interface\\BUTTONS\\UI-Panel-ExpandButton-Down.blp");
    end
  end);

  local _, _, _, enabled, loadable = GetAddOnInfo("WeakAurasTutorials");
  if(enabled and loadable) then
    local tutorial = CreateDecoration(frame)
    tutorial:SetPoint("TOPRIGHT", -140, 12)

    local tutorialbutton = CreateFrame("BUTTON", nil, tutorial)
    tutorialbutton:SetWidth(30);
    tutorialbutton:SetHeight(30);
    tutorialbutton:SetPoint("CENTER", tutorial, "CENTER", 1, -1);
    tutorialbutton:SetNormalTexture("Interface\\GossipFrame\\DailyActiveQuestIcon");
    tutorialbutton:GetNormalTexture():ClearAllPoints();
    tutorialbutton:GetNormalTexture():SetSize(16, 16);
    tutorialbutton:GetNormalTexture():SetPoint("center", -2, 0);
    tutorialbutton:SetPushedTexture("Interface\\GossipFrame\\DailyActiveQuestIcon");
    tutorialbutton:GetPushedTexture():ClearAllPoints();
    tutorialbutton:GetPushedTexture():SetSize(16, 16);
    tutorialbutton:GetPushedTexture():SetPoint("center", -2, -2);
    tutorialbutton:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
    tutorialbutton:SetScript("OnClick", function()
      if not(IsAddOnLoaded("WeakAurasTutorials")) then
        local loaded, reason = LoadAddOn("WeakAurasTutorials");
        if not(loaded) then
          print("|cff9900FF".."WeakAurasTutorials"..FONT_COLOR_CODE_CLOSE.." could not be loaded: "..RED_FONT_COLOR_CODE.._G["ADDON_"..reason]);
          return;
        end
      end
      WeakAuras.ToggleTutorials();
    end);
  end

  local container = AceGUI:Create("InlineGroup");
  container.frame:SetParent(frame);
  container.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 12);
  container.frame:SetPoint("TOPLEFT", frame, "TOPRIGHT", -423, -10);
  container.frame:Show();
  container.frame:SetClipsChildren(true);
  container.titletext:Hide();
  frame.container = container;

  frame.texturePicker = WeakAuras.TexturePicker(frame)
  frame.iconPicker = WeakAuras.IconPicker(frame)
  frame.modelPicker = WeakAuras.ModelPicker(frame)
  frame.importexport = WeakAuras.ImportExport(frame)
  frame.texteditor = WeakAuras.TextEditor(frame)
  frame.codereview = WeakAuras.CodeReview(frame);

  frame.moversizer, frame.move = WeakAuras.MoverSizer(frame);

  local buttonsContainer = AceGUI:Create("InlineGroup");
  buttonsContainer:SetWidth(170);
  buttonsContainer.frame:SetParent(frame);
  buttonsContainer.frame:SetPoint("BOTTOMLEFT", frame, "BOTTOMLEFT", 17, 12);
  buttonsContainer.frame:SetPoint("TOP", frame, "TOP", 0, -10);
  buttonsContainer.frame:SetPoint("right", container.frame, "left", -17);
  buttonsContainer.frame:Show();
  frame.buttonsContainer = buttonsContainer;

  local loadProgress = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
  loadProgress:SetPoint("TOP", buttonsContainer.frame, "TOP", 0, -4)
  loadProgress:SetText(L["Creating options: "].."0/0");
  frame.loadProgress = loadProgress;

  local filterInput = CreateFrame("editbox", "WeakAurasFilterInput", buttonsContainer.frame, "InputBoxTemplate");

  filterInput:SetAutoFocus(false);
  filterInput:SetScript("OnTextChanged", function(...) WeakAuras.SortDisplayButtons(filterInput:GetText()) end);
  filterInput:SetScript("OnEnterPressed", function(...) filterInput:ClearFocus() end);
  filterInput:SetScript("OnEscapePressed", function(...) filterInput:SetText(""); filterInput:ClearFocus() end);
  filterInput:SetWidth(150);
  filterInput:SetPoint("BOTTOMLEFT", buttonsContainer.frame, "TOPLEFT", 2, -18);
  filterInput:SetPoint("TOPLEFT", buttonsContainer.frame, "TOPLEFT", 2, -2);
  filterInput:SetTextInsets(16, 0, 0, 0);

  local searchIcon = filterInput:CreateTexture(nil, "overlay");
  searchIcon:SetTexture("Interface\\Common\\UI-Searchbox-Icon");
  searchIcon:SetVertexColor(0.6, 0.6, 0.6);
  searchIcon:SetWidth(14);
  searchIcon:SetHeight(14);
  searchIcon:SetPoint("left", filterInput, "left", 3, -1);
  filterInput:SetFont("Fonts\\FRIZQT__.TTF", 10);
  frame.filterInput = filterInput;
  filterInput:Hide();

  local filterInputClear = CreateFrame("BUTTON", nil, buttonsContainer.frame);
  frame.filterInputClear = filterInputClear;
  filterInputClear:SetWidth(12);
  filterInputClear:SetHeight(12);
  filterInputClear:SetPoint("left", filterInput, "right", 0, -1);
  filterInputClear:SetNormalTexture("Interface\\Common\\VoiceChat-Muted");
  filterInputClear:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  filterInputClear:SetScript("OnClick", function() filterInput:SetText(""); filterInput:ClearFocus() end);
  filterInputClear:Hide();

  local buttonsScroll = AceGUI:Create("ScrollFrame");
  buttonsScroll:SetLayout("ButtonsScrollLayout");
  buttonsScroll.width = "fill";
  buttonsScroll.height = "fill";
  buttonsContainer:SetLayout("fill");
  buttonsContainer:AddChild(buttonsScroll);
  buttonsScroll.DeleteChild = function(self, delete)
    for index, widget in ipairs(buttonsScroll.children) do
      if(widget == delete) then
        tremove(buttonsScroll.children, index);
      end
    end
    delete:OnRelease();
    buttonsScroll:DoLayout();
  end
  frame.buttonsScroll = buttonsScroll;

  function buttonsScroll:GetScrollPos()
    local status = self.status or self.localstatus;
    return status.offset, status.offset + self.scrollframe:GetHeight();
  end

  -- override SetScroll to make childrens visible as needed
  local oldSetScroll = buttonsScroll.SetScroll;
  buttonsScroll.SetScroll = function(self, value)
    if (self:GetScrollPos() ~= value) then
      oldSetScroll(self, value);
      self:DoLayout();
    end
  end

  function buttonsScroll:SetScrollPos(top, bottom)
    local status = self.status or self.localstatus;
    local viewheight = self.scrollframe:GetHeight();
    local height = self.content:GetHeight();
    local move;

    local viewtop = -1 * status.offset;
    local viewbottom = -1 * (status.offset + viewheight);
    if(top > viewtop) then
      move = top - viewtop;
    elseif(bottom < viewbottom) then
      move = bottom - viewbottom;
    else
      move = 0;
    end

    status.offset = status.offset - move;

    self.content:ClearAllPoints();
    self.content:SetPoint("TOPLEFT", 0, status.offset);
    self.content:SetPoint("TOPRIGHT", 0, status.offset);

    status.scrollvalue = status.offset / ((height - viewheight) / 1000.0);

    self:FixScroll();
  end

  local newButton = AceGUI:Create("WeakAurasNewHeaderButton");
  newButton:SetText(L["New"]);
  newButton:SetClick(function() frame:PickOption("New") end);
  frame.newButton = newButton;

  local numAddons = 0;
  for addon, addonData in pairs(WeakAuras.addons) do
    numAddons = numAddons + 1;
  end
  if(numAddons > 0) then
    local addonsButton = AceGUI:Create("WeakAurasNewHeaderButton");
    addonsButton:SetText(L["Addons"]);
    addonsButton:SetDescription(L["Manage displays defined by Addons"]);
    addonsButton:SetClick(function() frame:PickOption("Addons") end);
    frame.addonsButton = addonsButton;
  end

  local loadedButton = AceGUI:Create("WeakAurasLoadedHeaderButton");
  loadedButton:SetText(L["Loaded"]);
  loadedButton:Disable();
  loadedButton:EnableExpand();
  if(odb.loadedCollapse) then
    loadedButton:Collapse();
  else
    loadedButton:Expand();
  end
  loadedButton:SetOnExpandCollapse(function()
    if(loadedButton:GetExpanded()) then
      odb.loadedCollapse = nil;
    else
      odb.loadedCollapse = true;
    end
    WeakAuras.SortDisplayButtons()
  end);
  loadedButton:SetExpandDescription(L["Expand all loaded displays"]);
  loadedButton:SetCollapseDescription(L["Collapse all loaded displays"]);
  loadedButton:SetViewClick(function()
    if(loadedButton.view.func() == 2) then
      for id, child in pairs(displayButtons) do
        if(loaded[id] ~= nil) then
          child:PriorityHide(2);
        end
      end
    else
      for id, child in pairs(displayButtons) do
        if(loaded[id] ~= nil) then
          child:PriorityShow(2);
        end
      end
    end
  end);
  loadedButton:SetViewTest(function()
    local none, all = true, true;
    for id, child in pairs(displayButtons) do
      if(loaded[id] ~= nil) then
        if(child:GetVisibility() ~= 2) then
          all = false;
        end
        if(child:GetVisibility() ~= 0) then
          none = false;
        end
      end
    end
    if(all) then
      return 2;
    elseif(none) then
      return 0;
    else
      return 1;
    end
  end);
  loadedButton:SetViewDescription(L["Toggle the visibility of all loaded displays"]);
  frame.loadedButton = loadedButton;

  local unloadedButton = AceGUI:Create("WeakAurasLoadedHeaderButton");
  unloadedButton:SetText(L["Not Loaded"]);
  unloadedButton:Disable();
  unloadedButton:EnableExpand();
  if(odb.unloadedCollapse) then
    unloadedButton:Collapse();
  else
    unloadedButton:Expand();
  end
  unloadedButton:SetOnExpandCollapse(function()
    if(unloadedButton:GetExpanded()) then
      odb.unloadedCollapse = nil;
    else
      odb.unloadedCollapse = true;
    end
    WeakAuras.SortDisplayButtons()
  end);
  unloadedButton:SetExpandDescription(L["Expand all non-loaded displays"]);
  unloadedButton:SetCollapseDescription(L["Collapse all non-loaded displays"]);
  unloadedButton:SetViewClick(function()
    if(unloadedButton.view.func() == 2) then
      for id, child in pairs(displayButtons) do
        if(loaded[id] == nil) then
          child:PriorityHide(2);
        end
      end
    else
      for id, child in pairs(displayButtons) do
        if not(loaded[id] == nil) then
          child:PriorityShow(2);
        end
      end
    end
  end);
  unloadedButton:SetViewTest(function()
    local none, all = true, true;
    for id, child in pairs(displayButtons) do
      if(loaded[id] == nil) then
        if(child:GetVisibility() ~= 2) then
          all = false;
        end
        if(child:GetVisibility() ~= 0) then
          none = false;
        end
      end
    end
    if(all) then
      return 2;
    elseif(none) then
      return 0;
    else
      return 1;
    end
  end);
  unloadedButton:SetViewDescription(L["Toggle the visibility of all non-loaded displays"]);
  frame.unloadedButton = unloadedButton;

  frame.FillOptions = function(self, optionTable)
    AceConfig:RegisterOptionsTable("WeakAuras", optionTable);
    AceConfigDialog:Open("WeakAuras", container);
    container:SetTitle("");
  end

  frame.ClearPicks = function(self, except)
    WeakAuras.PauseAllDynamicGroups();

    frame.pickedDisplay = nil;
    frame.pickedOption = nil;
    wipe(tempGroup.controlledChildren);
    for id, button in pairs(displayButtons) do
      button:ClearPick();
    end
    newButton:ClearPick();
    if(frame.addonsButton) then
      frame.addonsButton:ClearPick();
    end
    loadedButton:ClearPick();
    unloadedButton:ClearPick();
    container:ReleaseChildren();
    self.moversizer:Hide();

    WeakAuras.ResumeAllDynamicGroups();
  end

  frame.PickOption = function(self, option)
    self:ClearPicks();
    self.moversizer:Hide();
    self.pickedOption = option;
    if(option == "New") then
      newButton:Pick();

      local containerScroll = AceGUI:Create("ScrollFrame");
      containerScroll:SetLayout("flow");
      container:SetLayout("fill");
      container:AddChild(containerScroll);

      if(GetAddOnEnableState(UnitName("player"), "WeakAurasTemplates") ~= 0) then
        local button = AceGUI:Create("WeakAurasNewButton");
        button:SetTitle(L["From Template"]);
        button:SetDescription(L["Offer a guided way to create auras for your class"])
        button:SetIcon("Interface\\Icons\\INV_Misc_Book_06");
        button:SetClick(function()
          WeakAuras.OpenTriggerTemplate();
        end);
        containerScroll:AddChild(button);
      end

      for regionType, regionData in pairs(regionOptions) do
        local button = AceGUI:Create("WeakAurasNewButton");
        button:SetTitle(regionData.displayName);
        if(type(regionData.icon) == "string") then
          button:SetIcon(regionData.icon);
        elseif(type(regionData.icon) == "function") then
          button:SetIcon(regionData.icon());
        end
        button:SetDescription(regionData.description);
        button:SetClick(function()
          local new_id = "New";
          local num = 2;
          while(db.displays[new_id]) do
            new_id = "New "..num;
            num = num + 1;
          end

          local data = {
            id = new_id,
            regionType = regionType,
            activeTriggerMode = WeakAuras.trigger_modes.first_active,
            disjunctive = "all",
            trigger = {
              type = "aura",
              unit = "player",
              debuffType = "HELPFUL"
            },
            load = {}
          };
          WeakAuras.Add(data);
          WeakAuras.NewDisplayButton(data);
          WeakAuras.PickAndEditDisplay(new_id);
        end);
        containerScroll:AddChild(button);
      end
      local importButton = AceGUI:Create("WeakAurasNewButton");
      importButton:SetTitle(L["Import"]);

      local data = {
        outline = false,
        color = {1, 1, 1, 1},
        justify = "CENTER",
        font = "Friz Quadrata TT",
        fontSize = 8,
        displayText = [[
b4vmErLxtfM
xu5fDEn1CEn
vmUmJyZ4hyY
DtnEnvBEnfz
EnfzErLxtjx
zNL2BUrvEWv
MxtfwDYfMyH
jNxtLgzEnLt
LDNx051u25L
tXmdmY4fDE5]];
      };

      local thumbnail = regionOptions["text"].createThumbnail(UIParent);
      regionOptions["text"].modifyThumbnail(UIParent, thumbnail, data);
      thumbnail.mask:SetPoint("BOTTOMLEFT", thumbnail, "BOTTOMLEFT", 3, 3);
      thumbnail.mask:SetPoint("TOPRIGHT", thumbnail, "TOPRIGHT", -3, -3);

      importButton:SetIcon(thumbnail);
      importButton:SetDescription(L["Import a display from an encoded string"]);
      importButton:SetClick(WeakAuras.ImportFromString);
      containerScroll:AddChild(importButton);
    elseif(option == "Addons") then
      frame.addonsButton:Pick();

      local containerScroll = AceGUI:Create("ScrollFrame");
      containerScroll:SetLayout("AbsoluteList");
      container:SetLayout("fill");
      container:AddChild(containerScroll);

      WeakAuras.CreateImportButtons();
      WeakAuras.SortImportButtons(containerScroll);
    else
      error("An options button other than New or Addons was selected... but there are no other options buttons!");
    end
  end

  frame.PickDisplay = function(self, id)
    self:ClearPicks();
    local data = WeakAuras.GetData(id);

    local function finishPicking()
      displayButtons[id]:Pick();
      self.pickedDisplay = id;
      local data = db.displays[id];
      WeakAuras.ReloadTriggerOptions(data);
      self:FillOptions(displayOptions[id]);
      WeakAuras.regions[id].region:Collapse();
      WeakAuras.regions[id].region:Expand();
      self.moversizer:SetToRegion(WeakAuras.regions[id].region, db.displays[id]);
      local _, _, _, _, yOffset = displayButtons[id].frame:GetPoint(1);
      if (not yOffset) then
        yOffset = displayButtons[id].frame.yOffset;
      end
      if (yOffset) then
        self.buttonsScroll:SetScrollPos(yOffset, yOffset - 32);
      end
      if(data.controlledChildren) then
        for index, childId in pairs(data.controlledChildren) do
          displayButtons[childId]:PriorityShow(1);
        end
      end
      WeakAuras.ResumeAllDynamicGroups();
    end

    local list = {};
    local num = 0;
    if(data.controlledChildren) then
      for index, childId in pairs(data.controlledChildren) do
        if not(displayOptions[childId]) then
          list[childId] = WeakAuras.GetData(childId);
          num = num + 1;
        end
      end
    end
    WeakAuras.EnsureOptions(id);
    if(num > 1) then
      WeakAuras.PauseAllDynamicGroups();
      WeakAuras.BuildOptions(list, finishPicking);
    else
      WeakAuras.PauseAllDynamicGroups();
      finishPicking();
    end
  end

  frame.CenterOnPicked = function(self)
    if(self.pickedDisplay) then
      local centerId = type(self.pickedDisplay) == "string" and self.pickedDisplay or self.pickedDisplay.controlledChildren[1];

      if(displayButtons[centerId]) then
        local _, _, _, _, yOffset = displayButtons[centerId].frame:GetPoint(1);
        if not yOffset then
          yOffset = displayButtons[centerId].frame.yOffset
        end
        if yOffset then
          self.buttonsScroll:SetScrollPos(yOffset, yOffset - 32);
        end
      end
    end
  end

  frame.PickDisplayMultiple = function(self, id)
    if not(self.pickedDisplay) then
      self:PickDisplay(id);
    else
      local wasGroup = false;
      if(type(self.pickedDisplay) == "string") then
        if(WeakAuras.GetData(self.pickedDisplay).controlledChildren) then
          wasGroup = true;
        elseif not(WeakAuras.IsDisplayPicked(id)) then
          tinsert(tempGroup.controlledChildren, self.pickedDisplay);
        end
      end
      if(wasGroup) then
        self:PickDisplay(id);
      elseif not(WeakAuras.IsDisplayPicked(id)) then
        self.pickedDisplay = tempGroup;
        WeakAuras.EnsureOptions(id);
        displayButtons[id]:Pick();
        tinsert(tempGroup.controlledChildren, id);
        WeakAuras.ReloadTriggerOptions(tempGroup);
        self:FillOptions(displayOptions[tempGroup.id]);
      end
    end
  end

  frame.RefreshPick = function(self)
    if(type(self.pickedDisplay) == "string") then
      WeakAuras.EnsureOptions(self.pickedDisplay);
      self:FillOptions(displayOptions[self.pickedDisplay]);
    else
      WeakAuras.EnsureOptions(tempGroup.id);
      self:FillOptions(displayOptions[tempGroup.id]);
    end
  end

  frame:SetClampedToScreen(true);
  local w,h = frame:GetSize();
  local left,right,top,bottom = w/2,-w/2,0,h-25
  frame:SetClampRectInsets(left,right,top,bottom);

  return frame;
end

-- Lua APIs
local select, pairs, next, type, unpack = select, pairs, next, type, unpack

-- WoW APIs
local CreateFrame = CreateFrame

-- GLOBALS: WeakAuras WeakAuras_DropDownMenu
-- GLOBALS: GameTooltip GameTooltip_Hide UIParent FONT_COLOR_CODE_CLOSE RED_FONT_COLOR_CODE GetAddOnEnableState

local AceGUI = LibStub("AceGUI-3.0")
local SharedMedia = LibStub("LibSharedMedia-3.0")
local IndentationLib = IndentationLib

local WeakAuras = WeakAuras
local L = WeakAuras.L

local codeReview

local tableColor = "|c00ff3333"
local arithmeticColor = "|c00ff3333"
local relationColor = "|c00ff3333"
local logicColor = "|c004444ff"

local colorScheme = {
  [IndentationLib.tokens.TOKEN_SPECIAL] = "|c00ff3333",
  [IndentationLib.tokens.TOKEN_KEYWORD] = "|c004444ff",
  [IndentationLib.tokens.TOKEN_COMMENT_SHORT] = "|c0000aa00",
  [IndentationLib.tokens.TOKEN_COMMENT_LONG] = "|c0000aa00",
  [IndentationLib.tokens.TOKEN_NUMBER] = "|c00ff9900",
  [IndentationLib.tokens.TOKEN_STRING] = "|c00999999",
  -- ellipsis, curly braces, table acces
  ["..."] = tableColor,
  ["{"] = tableColor,
  ["}"] = tableColor,
  ["["] = tableColor,
  ["]"] = tableColor,
  -- arithmetic operators
  ["+"] = arithmeticColor,
  ["-"] = arithmeticColor,
  ["/"] = arithmeticColor,
  ["*"] = arithmeticColor,
  [".."] = arithmeticColor,
  -- relational operators
  ["=="] = relationColor,
  ["<"] = relationColor,
  ["<="] = relationColor,
  [">"] = relationColor,
  [">="] = relationColor,
  ["~="] = relationColor,
  -- logical operators
  ["and"] = logicColor,
  ["or"] = logicColor,
  ["not"] = logicColor,
  -- misc
  [0] = "|r",
}

local function ConstructCodeReview(frame)
  local group = AceGUI:Create("InlineGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 30);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -10);
  group.frame:Hide();
  group:SetLayout("flow");

  local codeTree = AceGUI:Create("TreeGroup");
  group.codeTree = codeTree;
  group:SetLayout("fill");
  group:AddChild(codeTree);

  local codebox = AceGUI:Create("MultiLineEditBox");
  codebox.frame:SetAllPoints(codeTree.content);
  codebox.frame:SetFrameStrata("FULLSCREEN");
  codebox:SetLabel("");
  group:AddChild(codebox);

  codebox.button:Hide();
  IndentationLib.enable(codebox.editBox, colorScheme, 4);
  local fontPath = SharedMedia:Fetch("font", "Fira Mono Medium");
  if(fontPath) then
    codebox.editBox:SetFont(fontPath, 12);
  end
  group.codebox = codebox;

  codeTree:SetCallback("OnGroupSelected", function(self, event, value)
    for _, v in pairs(group.data) do
      if (v.value == value) then
        codebox:SetText(v.code);
      end
    end
  end);

  local cancel = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  cancel:SetScript("OnClick", function() group:Close() end);
  cancel:SetPoint("bottomright", frame, "bottomright", -27, 11);
  cancel:SetHeight(20);
  cancel:SetWidth(100);
  cancel:SetText(L["Okay"]);

  function group.Open(self, data)
    if frame.window == "codereview" then
      return
    end

    self.data = data;

    self.codeTree:SetTree(data);
    self.codebox.frame:Show();

    WeakAuras.ShowOptions();

    frame.importexport.frame:Hide();
    frame.container.frame:Hide();
    frame.buttonsContainer.frame:Hide();
    self.frame:Show();
    frame.window = "codereview";
  end

  function group.Close()
    group.frame:Hide();
    codebox.frame:Hide();
    frame.container.frame:Show();
    frame.buttonsContainer.frame:Show();
    frame.window = "default";
  end

  return group
end

function WeakAuras.CodeReview(frame)
  codeReview = codeReview or ConstructCodeReview(frame)
  return codeReview
end

-- Lua APIs
local select, pairs, next, type, unpack = select, pairs, next, type, unpack

-- WoW APIs
local CreateFrame, GetSpellInfo = CreateFrame, GetSpellInfo

-- GLOBALS: WeakAuras

local AceGUI = LibStub("AceGUI-3.0")
local AceConfigDialog = LibStub("AceConfigDialog-3.0")

local WeakAuras = WeakAuras
local L = WeakAuras.L

local iconPicker

local spellCache = WeakAuras.spellCache

local function ConstructIconPicker(frame)
  local group = AceGUI:Create("InlineGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 30); -- 12
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -50);
  group.frame:Hide();
  group:SetLayout("flow");

  local scroll = AceGUI:Create("ScrollFrame");
  scroll:SetLayout("flow");
  scroll.frame:SetClipsChildren(true);
  group:AddChild(scroll);

  local function iconPickerFill(subname, doSort)
    scroll:ReleaseChildren();

    local distances = {};
    local names = {};

    subname = tonumber(subname) and GetSpellInfo(tonumber(subname)) or subname;
    subname = subname:lower();

    local usedIcons = {};
    local num = 0;
    if(subname ~= "") then
      for name, icons in pairs(spellCache.Get()) do
        local bestDistance = math.huge;
        local bestName;
        if(name:lower():find(subname, 1, true)) then

          for spellId, icon in pairs(icons) do
            if (not usedIcons[icon]) then
              local button = AceGUI:Create("WeakAurasIconButton");
              button:SetName(name);
              button:SetTexture(icon);
              button:SetClick(function()
                group:Pick(icon);
              end);
              scroll:AddChild(button);

              usedIcons[icon] = true;
              num = num + 1;
              if(num >= 500) then
                break;
              end
            end
          end
        end

        if(num >= 500) then
          break;
        end
      end
    end
  end

  local input = CreateFrame("EDITBOX", nil, group.frame, "InputBoxTemplate");
  input:SetScript("OnTextChanged", function(...) iconPickerFill(input:GetText(), false); end);
  input:SetScript("OnEnterPressed", function(...) iconPickerFill(input:GetText(), true); end);
  input:SetScript("OnEscapePressed", function(...) input:SetText(""); iconPickerFill(input:GetText(), true); end);
  input:SetWidth(170);
  input:SetHeight(15);
  input:SetPoint("BOTTOMRIGHT", group.frame, "TOPRIGHT", -12, -5);
  WeakAuras.input = input;

  local inputLabel = input:CreateFontString(nil, "OVERLAY", "GameFontNormal");
  inputLabel:SetText(L["Search"]);
  inputLabel:SetJustifyH("RIGHT");
  inputLabel:SetPoint("BOTTOMLEFT", input, "TOPLEFT", 0, 5);

  local icon = AceGUI:Create("WeakAurasIconButton");
  icon.frame:Disable();
  icon.frame:SetParent(group.frame);
  icon.frame:SetPoint("BOTTOMLEFT", group.frame, "TOPLEFT", 15, -15);

  local iconLabel = input:CreateFontString(nil, "OVERLAY", "GameFontNormalHuge");
  iconLabel:SetNonSpaceWrap("true");
  iconLabel:SetJustifyH("LEFT");
  iconLabel:SetPoint("LEFT", icon.frame, "RIGHT", 5, 0);
  iconLabel:SetPoint("RIGHT", input, "LEFT", -50, 0);

  function group.Pick(self, texturePath)
    if(self.data.controlledChildren) then
      for index, childId in pairs(self.data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        if(childData) then
          childData[self.field] = texturePath;
          WeakAuras.Add(childData);
          WeakAuras.SetThumbnail(childData);
          WeakAuras.SetIconNames(childData);
        end
      end
    else
      self.data[self.field] = texturePath;
      WeakAuras.Add(self.data);
      WeakAuras.SetThumbnail(self.data);
      WeakAuras.SetIconNames(self.data);
    end
    local success = icon:SetTexture(texturePath) and texturePath;
    if(success) then
      iconLabel:SetText(texturePath);
    else
      iconLabel:SetText();
    end
  end

  function group.Open(self, data, field)
    self.data = data;
    self.field = field;
    if(data.controlledChildren) then
      self.givenPath = {};
      for index, childId in pairs(data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        if(childData) then
          self.givenPath[childId] = childData[field];
        end
      end
    else
      self.givenPath = self.data[self.field];
    end
    -- group:Pick(self.givenPath);
    frame.container.frame:Hide();
    frame.buttonsContainer.frame:Hide();
    self.frame:Show();
    frame.window = "icon";
    input:SetText("");
  end

  function group.Close()
    group.frame:Hide();
    frame.container.frame:Show();
    frame.buttonsContainer.frame:Show();
    frame.window = "default";
    AceConfigDialog:Open("WeakAuras", frame.container);
  end

  function group.CancelClose()
    if(group.data.controlledChildren) then
      for index, childId in pairs(group.data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        if(childData) then
          childData[group.field] = group.givenPath[childId] or childData[group.field];
          WeakAuras.Add(childData);
          WeakAuras.SetThumbnail(childData);
          WeakAuras.SetIconNames(childData);
        end
      end
    else
      group:Pick(group.givenPath);
    end
    group.Close();
  end

  local cancel = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  cancel:SetScript("OnClick", group.CancelClose);
  cancel:SetPoint("bottomright", frame, "bottomright", -27, 11);
  cancel:SetHeight(20);
  cancel:SetWidth(100);
  cancel:SetText(L["Cancel"]);

  local close = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  close:SetScript("OnClick", group.Close);
  close:SetPoint("RIGHT", cancel, "LEFT", -10, 0);
  close:SetHeight(20);
  close:SetWidth(100);
  close:SetText(L["Okay"]);

  scroll.frame:SetPoint("BOTTOM", close, "TOP", 0, 10);
  return group
end

function WeakAuras.IconPicker(frame)
  iconPicker = iconPicker or ConstructIconPicker(frame)
  return iconPicker
end

-- Lua APIs
local fmt, tostring, string_char, strtrim, strsub = string.format, tostring, string.char, strtrim, strsub
local select, pairs, next, type, unpack = select, pairs, next, type, unpack

-- WoW APIs
local GetTime, CreateFrame = GetTime, CreateFrame

-- GLOBALS: WeakAuras

local AceGUI = LibStub("AceGUI-3.0")

local WeakAuras = WeakAuras
local L = WeakAuras.L

local importexport

local function ConstructImportExport(frame)
  local group = AceGUI:Create("InlineGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 12);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -10);
  group.frame:Hide();
  group:SetLayout("fill");

  local input = AceGUI:Create("MultiLineEditBox");
  input:SetWidth(400);
  input.button:Hide();
  input.frame:SetClipsChildren(true);
  group:AddChild(input);

  local close = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  close:SetScript("OnClick", function() group:Close() end);
  close:SetPoint("BOTTOMRIGHT", -27, 13);
  close:SetHeight(20);
  close:SetWidth(100);
  close:SetText(L["Done"])

  function group.Open(self, mode, id)
    if(frame.window == "texture") then
      frame.texturePicker:CancelClose();
    elseif(frame.window == "icon") then
      frame.iconPicker:CancelClose();
    elseif(frame.window == "model") then
      frame.modelPicker:CancelClose();
    end
    frame.container.frame:Hide();
    frame.buttonsContainer.frame:Hide();
    self.frame:Show();
    frame.window = "importexport";
    if(mode == "export" or mode == "table") then
      if(id) then
        local displayStr;
        if(mode == "export") then
          displayStr = WeakAuras.DisplayToString(id, true);
        elseif(mode == "table") then
          displayStr = WeakAuras.DisplayToTableString(id);
        end
        input.editBox:SetMaxBytes(nil);
        input.editBox:SetScript("OnEscapePressed", function() group:Close(); end);
        input.editBox:SetScript("OnChar", function() input:SetText(displayStr); input.editBox:HighlightText(); end);
        input.editBox:SetScript("OnMouseUp", function() input.editBox:HighlightText(); end);
        input:SetLabel(id.." - "..#displayStr);
        input.button:Hide();
        input:SetText(displayStr);
        input.editBox:HighlightText();
        input:SetFocus();
      end
    elseif(mode == "import") then
      local textBuffer, i, lastPaste = {}, 0, 0
      local function clearBuffer(self)
        self:SetScript('OnUpdate', nil)
        local pasted = strtrim(table.concat(textBuffer))
        input.editBox:ClearFocus();
        pasted = pasted:match( "^%s*(.-)%s*$" );
        if (#pasted > 20) then
          WeakAuras.ImportString(pasted);
          input:SetLabel(L["Processed %i chars"]:format(i));
          input.editBox:SetMaxBytes(2500);
          input.editBox:SetText(strsub(pasted, 1, 2500));
        end
      end

      input.editBox:SetScript('OnChar', function(self, c)
        if lastPaste ~= GetTime() then
          textBuffer, i, lastPaste = {}, 0, GetTime()
          self:SetScript('OnUpdate', clearBuffer)
        end
        i = i + 1
        textBuffer[i] = c
      end)

      input.editBox:SetText("");
      input.editBox:SetMaxBytes(2500);
      input.editBox:SetScript("OnEscapePressed", function() group:Close(); end);
      input.editBox:SetScript("OnMouseUp", nil);
      input:SetLabel(L["Paste text below"]);
      input:SetFocus();
    end
  end

  function group.Close(self)
    input:ClearFocus();
    self.frame:Hide();
    frame.container.frame:Show();
    frame.buttonsContainer.frame:Show();
    frame.window = "default";
  end

  return group
end

function WeakAuras.ImportExport(frame)
  importexport = importexport or ConstructImportExport(frame)
  return importexport
end

-- Lua APIs
local select, pairs, next, type, unpack, rad = select, pairs, next, type, unpack, rad

-- WoW APIs
local CreateFrame = CreateFrame

-- GLOBALS: WeakAuras

local AceGUI = LibStub("AceGUI-3.0")
local AceConfigDialog = LibStub("AceConfigDialog-3.0")

local WeakAuras = WeakAuras
local L = WeakAuras.L

local modelPicker

local function ConstructModelPicker(frame)
  local group = AceGUI:Create("InlineGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 87);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -10);
  group.frame:Hide();
  group:SetLayout("flow");

  -- Old X Y Z controls
  local modelPickerZ = AceGUI:Create("Slider");
  modelPickerZ:SetSliderValues(-20, 20, 0.05);
  modelPickerZ:SetLabel(L["Z Offset"]);
  modelPickerZ.frame:SetParent(group.frame);
  modelPickerZ:SetCallback("OnValueChanged", function()
    group:Pick(nil, modelPickerZ:GetValue());
  end);

  local modelPickerX = AceGUI:Create("Slider");
  modelPickerX:SetSliderValues(-20, 20, 0.05);
  modelPickerX:SetLabel(L["X Offset"]);
  modelPickerX.frame:SetParent(group.frame);
  modelPickerX:SetCallback("OnValueChanged", function()
    group:Pick(nil, nil, modelPickerX:GetValue());
  end);

  local modelPickerY = AceGUI:Create("Slider");
  modelPickerY:SetSliderValues(-20, 20, 0.05);
  modelPickerY:SetLabel(L["Y Offset"]);
  modelPickerY.frame:SetParent(group.frame);
  modelPickerY:SetCallback("OnValueChanged", function()
    group:Pick(nil, nil, nil, modelPickerY:GetValue());
  end);

  -- New TX TY TZ, RX, RY, RZ, US controls
  local modelPickerTX = AceGUI:Create("Slider");
  modelPickerTX:SetSliderValues(-1000, 1000, 1);
  modelPickerTX:SetLabel(L["X Offset"]);
  modelPickerTX.frame:SetParent(group.frame);
  modelPickerTX:SetCallback("OnValueChanged", function()
    group:PickSt(nil, modelPickerTX:GetValue());
  end);

  local modelPickerTY = AceGUI:Create("Slider");
  modelPickerTY:SetSliderValues(-1000, 1000, 1);
  modelPickerTY:SetLabel(L["Y Offset"]);
  modelPickerTY.frame:SetParent(group.frame);
  modelPickerTY:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, modelPickerTY:GetValue());
  end);

  local modelPickerTZ = AceGUI:Create("Slider");
  modelPickerTZ:SetSliderValues(-1000, 1000, 1);
  modelPickerTZ:SetLabel(L["Z Offset"]);
  modelPickerTZ.frame:SetParent(group.frame);
  modelPickerTZ:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, nil, modelPickerTZ:GetValue());
  end);

  local modelPickerRX = AceGUI:Create("Slider");
  modelPickerRX:SetSliderValues(0, 360, 1);
  modelPickerRX:SetLabel(L["X Rotation"]);
  modelPickerRX.frame:SetParent(group.frame);
  modelPickerRX:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, nil, nil, modelPickerRX:GetValue());
  end);

  local modelPickerRY = AceGUI:Create("Slider");
  modelPickerRY:SetSliderValues(0, 360, 1);
  modelPickerRY:SetLabel(L["Y Rotation"]);
  modelPickerRY.frame:SetParent(group.frame);
  modelPickerRY:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, nil, nil, nil, modelPickerRY:GetValue());
  end);

  local modelPickerRZ = AceGUI:Create("Slider");
  modelPickerRZ:SetSliderValues(0, 360, 1);
  modelPickerRZ:SetLabel(L["Z Rotation"]);
  modelPickerRZ.frame:SetParent(group.frame);
  modelPickerRZ:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, nil, nil, nil, nil, modelPickerRZ:GetValue());
  end);

  local modelPickerUS = AceGUI:Create("Slider");
  modelPickerUS:SetSliderValues(5, 1000, 1);
  modelPickerUS:SetLabel(L["Scale"]);
  modelPickerUS.frame:SetParent(group.frame);
  modelPickerUS:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, nil, nil, nil, nil, nil, modelPickerUS:GetValue());
  end);

  local modelTree = AceGUI:Create("TreeGroup");
  group.modelTree = modelTree;
  group.frame:SetScript("OnUpdate", function()
    local frameWidth = frame:GetWidth();
    local sliderWidth = (frameWidth - 50) / 3;
    local narrowSliderWidth = (frameWidth - 50) / 7;

    modelTree:SetTreeWidth(frameWidth - 370);

    modelPickerZ.frame:SetPoint("bottomleft", frame, "bottomleft", 15, 43);
    modelPickerZ.frame:SetPoint("bottomright", frame, "bottomleft", 15 + sliderWidth, 43);

    modelPickerX.frame:SetPoint("bottomleft", frame, "bottomleft", 25 + sliderWidth, 43);
    modelPickerX.frame:SetPoint("bottomright", frame, "bottomleft", 25 + (2 * sliderWidth), 43);

    modelPickerY.frame:SetPoint("bottomleft", frame, "bottomleft", 35 + (2 * sliderWidth), 43);
    modelPickerY.frame:SetPoint("bottomright", frame, "bottomleft", 35 + (3 * sliderWidth), 43);

    -- New controls
    modelPickerTX.frame:SetPoint("bottomleft", frame, "bottomleft", 15, 43);
    modelPickerTX.frame:SetPoint("bottomright", frame, "bottomleft", 15 + narrowSliderWidth, 43);

    modelPickerTY.frame:SetPoint("bottomleft", frame, "bottomleft", 20 + narrowSliderWidth, 43);
    modelPickerTY.frame:SetPoint("bottomright", frame, "bottomleft", 20 + (2 * narrowSliderWidth), 43);

    modelPickerTZ.frame:SetPoint("bottomleft", frame, "bottomleft", 25 + (2 * narrowSliderWidth), 43);
    modelPickerTZ.frame:SetPoint("bottomright", frame, "bottomleft", 25 + (3 * narrowSliderWidth), 43);

    modelPickerRX.frame:SetPoint("bottomleft", frame, "bottomleft", 30 + (3 * narrowSliderWidth), 43);
    modelPickerRX.frame:SetPoint("bottomright", frame, "bottomleft", 30 + (4 * narrowSliderWidth), 43);

    modelPickerRY.frame:SetPoint("bottomleft", frame, "bottomleft", 35 + (4 * narrowSliderWidth), 43);
    modelPickerRY.frame:SetPoint("bottomright", frame, "bottomleft", 35 + (5 * narrowSliderWidth), 43);

    modelPickerRZ.frame:SetPoint("bottomleft", frame, "bottomleft", 40 + (5 * narrowSliderWidth), 43);
    modelPickerRZ.frame:SetPoint("bottomright", frame, "bottomleft", 40 + (6 * narrowSliderWidth), 43);

    modelPickerUS.frame:SetPoint("bottomleft", frame, "bottomleft", 45 + (6 * narrowSliderWidth), 43);
    modelPickerUS.frame:SetPoint("bottomright", frame, "bottomleft", 45 + (7 * narrowSliderWidth), 43);

  end);
  group:SetLayout("fill");
  modelTree:SetTree(WeakAuras.ModelPaths);
  modelTree:SetCallback("OnGroupSelected", function(self, event, value)
    local path = string.gsub(value, "\001", "/");
    if(string.lower(string.sub(path, -3, -1)) == ".m2") then
      local model_path = path;
      if (group.givenApi) then
        group:PickSt(model_path);
      else
        group:Pick(model_path);
      end
    end
  end);
  group:AddChild(modelTree);

  local model = CreateFrame("PlayerModel", nil, group.content);
  model:SetAllPoints(modelTree.content);
  model:SetFrameStrata("FULLSCREEN");
  group.model = model;

  function group.PickSt(self, model_path, model_tx, model_ty, model_tz, model_rx, model_ry, model_rz, model_us)
    model_path = model_path or self.data.model_path;
    model_tx = model_tx or self.data.model_st_tx;
    model_ty = model_ty or self.data.model_st_ty;
    model_tz = model_tz or self.data.model_st_tz;

    model_rx = model_rx or self.data.model_st_rx;
    model_ry = model_ry or self.data.model_st_ry;
    model_rz = model_rz or self.data.model_st_rz;

    model_us = model_us or self.data.model_st_us;

    if tonumber(model_path) then
      self.model:SetDisplayInfo(tonumber(model_path))
    else
      self.model:SetModel(model_path);
    end
    self.model:SetTransform(model_tx / 1000, model_ty / 1000, model_tz / 1000,
      rad(model_rx), rad(model_ry), rad(model_rz),
      model_us / 1000);
    if(self.data.controlledChildren) then
      for index, childId in pairs(self.data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        if(childData) then
          childData.model_path = model_path;
          childData.model_st_tx = model_tx;
          childData.model_st_ty = model_ty;
          childData.model_st_tz = model_tz;
          childData.model_st_rx = model_rx;
          childData.model_st_ry = model_ry;
          childData.model_st_rz = model_rz;
          childData.model_st_us = model_us;
          WeakAuras.Add(childData);
          WeakAuras.SetThumbnail(childData);
          WeakAuras.SetIconNames(childData);
        end
      end
    else
      self.data.model_path = model_path;
      self.data.model_st_tx = model_tx;
      self.data.model_st_ty = model_ty;
      self.data.model_st_tz = model_tz;
      self.data.model_st_rx = model_rx;
      self.data.model_st_ry = model_ry;
      self.data.model_st_rz = model_rz;
      self.data.model_st_us = model_us;
      WeakAuras.Add(self.data);
      WeakAuras.SetThumbnail(self.data);
      WeakAuras.SetIconNames(self.data);
    end
  end

  function group.Pick(self, model_path, model_z, model_x, model_y)
    model_path = model_path or self.data.model_path;
    model_z = model_z or self.data.model_z;
    model_x = model_x or self.data.model_x;
    model_y = model_y or self.data.model_y;

    if tonumber(model_path) then
      self.model:SetDisplayInfo(tonumber(model_path))
    else
      self.model:SetModel(model_path);
    end
    self.model:ClearTransform();
    self.model:SetPosition(model_z, model_x, model_y);
    self.model:SetFacing(rad(self.data.rotation));
    if(self.data.controlledChildren) then
      for index, childId in pairs(self.data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        if(childData) then
          childData.model_path = model_path;
          childData.model_z = model_z;
          childData.model_x = model_x;
          childData.model_y = model_y;
          WeakAuras.Add(childData);
          WeakAuras.SetThumbnail(childData);
          WeakAuras.SetIconNames(childData);
        end
      end
    else
      self.data.model_path = model_path;
      self.data.model_z = model_z;
      self.data.model_x = model_x;
      self.data.model_y = model_y;
      WeakAuras.Add(self.data);
      WeakAuras.SetThumbnail(self.data);
      WeakAuras.SetIconNames(self.data);
    end
  end

  function group.Open(self, data)
    self.data = data;
    if tonumber(data.model_path) then
      model:SetDisplayInfo(tonumber(data.model_path))
    else
      model:SetModel(data.model_path);
    end
    if (data.api) then
      self.model:SetTransform(data.model_st_tx / 1000, data.model_st_ty / 1000, data.model_st_tz / 1000,
        rad(data.model_st_rx), rad(data.model_st_ry), rad(data.model_st_rz),
        data.model_st_us / 1000);

      modelPickerTX:SetValue(data.model_st_tx);
      modelPickerTX.editbox:SetText(("%.2f"):format(data.model_st_tx));
      modelPickerTY:SetValue(data.model_st_ty);
      modelPickerTY.editbox:SetText(("%.2f"):format(data.model_st_ty));
      modelPickerTZ:SetValue(data.model_st_tz);
      modelPickerTZ.editbox:SetText(("%.2f"):format(data.model_st_tz));

      modelPickerRX:SetValue(data.model_st_rx);
      modelPickerRX.editbox:SetText(("%.2f"):format(data.model_st_rx));
      modelPickerRY:SetValue(data.model_st_ry);
      modelPickerRY.editbox:SetText(("%.2f"):format(data.model_st_ry));
      modelPickerRZ:SetValue(data.model_st_rz);
      modelPickerRZ.editbox:SetText(("%.2f"):format(data.model_st_rz));

      modelPickerUS:SetValue(data.model_st_us);
      modelPickerUS.editbox:SetText(("%.2f"):format(data.model_st_us));

      modelPickerZ.frame:Hide();
      modelPickerY.frame:Hide();
      modelPickerX.frame:Hide();

      modelPickerTX.frame:Show();
      modelPickerTY.frame:Show();
      modelPickerTZ.frame:Show();
      modelPickerRX.frame:Show();
      modelPickerRY.frame:Show();
      modelPickerRZ.frame:Show();
      modelPickerUS.frame:Show();

    else
      self.model:ClearTransform();
      self.model:SetPosition(data.model_z, data.model_x, data.model_y);
      self.model:SetFacing(rad(data.rotation));
      modelPickerZ:SetValue(data.model_z);
      modelPickerZ.editbox:SetText(("%.2f"):format(data.model_z));
      modelPickerX:SetValue(data.model_x);
      modelPickerX.editbox:SetText(("%.2f"):format(data.model_x));
      modelPickerY:SetValue(data.model_y);
      modelPickerY.editbox:SetText(("%.2f"):format(data.model_y));

      modelPickerZ.frame:Show();
      modelPickerY.frame:Show();
      modelPickerX.frame:Show();

      modelPickerTX.frame:Hide();
      modelPickerTY.frame:Hide();
      modelPickerTZ.frame:Hide();
      modelPickerRX.frame:Hide();
      modelPickerRY.frame:Hide();
      modelPickerRZ.frame:Hide();
      modelPickerUS.frame:Hide();
    end

    if(data.controlledChildren) then
      self.givenModel = {};
      self.givenApi = {};
      self.givenZ = {};
      self.givenX = {};
      self.givenY = {};
      self.givenTX = {};
      self.givenTY = {};
      self.givenTZ = {};
      self.givenRX = {};
      self.givenRY = {};
      self.givenRZ = {};
      self.givenUS = {};
      for index, childId in pairs(data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        if(childData) then
          self.givenModel[childId] = childData.model_path;
          self.givenApi[childId] = childData.api;
          if (childData.api) then
            self.givenTX[childId] = childData.model_st_tx;
            self.givenTY[childId] = childData.model_st_ty;
            self.givenTZ[childId] = childData.model_st_tz;
            self.givenRX[childId] = childData.model_st_rx;
            self.givenRY[childId] = childData.model_st_ry;
            self.givenRZ[childId] = childData.model_st_rz;
            self.givenUS[childId] = childData.model_st_us;
          else
            self.givenZ[childId] = childData.model_z;
            self.givenX[childId] = childData.model_x;
            self.givenY[childId] = childData.model_y;
          end
        end
      end
    else
      self.givenModel = data.model_path;
      self.givenApi = data.api;

      if (data.api) then
        self.givenTX = data.model_st_tx;
        self.givenTY = data.model_st_ty;
        self.givenTZ = data.model_st_tz;
        self.givenRX = data.model_st_rx;
        self.givenRY = data.model_st_ry;
        self.givenRZ = data.model_st_rz;
        self.givenUS = data.model_st_us;
      else
        self.givenZ = data.model_z;
        self.givenX = data.model_x;
        self.givenY = data.model_y;
      end
    end
    frame.container.frame:Hide();
    frame.buttonsContainer.frame:Hide();
    self.frame:Show();
    frame.window = "model";
  end

  function group.Close()
    group.frame:Hide();
    frame.container.frame:Show();
    frame.buttonsContainer.frame:Show();
    frame.window = "default";
    AceConfigDialog:Open("WeakAuras", frame.container);
  end

  function group.CancelClose(self)
    if(group.data.controlledChildren) then
      for index, childId in pairs(group.data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        if(childData) then
          childData.model_path = group.givenModel[childId];
          childData.api = group.givenApi[childId];
          if (childData.api) then
            childData.model_st_tx = group.givenTX[childId];
            childData.model_st_ty = group.givenTY[childId];
            childData.model_st_tz = group.givenTZ[childId];
            childData.model_st_rx = group.givenRX[childId];
            childData.model_st_ry = group.givenRY[childId];
            childData.model_st_rz = group.givenRZ[childId];
            childData.model_st_us = group.givenUS[childId];
          else
            childData.model_z = group.givenZ[childId];
            childData.model_x = group.givenX[childId];
            childData.model_y = group.givenY[childId];
          end
          WeakAuras.Add(childData);
          WeakAuras.SetThumbnail(childData);
          WeakAuras.SetIconNames(childData);
        end
      end
    else
      if (group.givenApi) then
        group:PickSt(group.givenPath, group.givenTX, group.givenTY, group.givenTZ,
          group.givenRX, group.givenRY, group.givenRZ, group.givenUS );
      else
        group:Pick(group.givenPath, group.givenZ, group.givenX, group.givenY);
      end
    end
    group.Close();
  end

  local cancel = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  cancel:SetScript("OnClick", group.CancelClose);
  cancel:SetPoint("bottomright", frame, "bottomright", -27, 16);
  cancel:SetHeight(20);
  cancel:SetWidth(100);
  cancel:SetText(L["Cancel"]);

  local close = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  close:SetScript("OnClick", group.Close);
  close:SetPoint("RIGHT", cancel, "LEFT", -10, 0);
  close:SetHeight(20);
  close:SetWidth(100);
  close:SetText(L["Okay"]);

  return group
end

function WeakAuras.ModelPicker(frame)
  modelPicker = modelPicker or ConstructModelPicker(frame)
  return modelPicker
end

-- Lua APIs
local select, pairs, next, type, unpack = select, pairs, next, type, unpack
local loadstring, assert, error = loadstring, assert, error

-- WoW APIs
local CreateFrame = CreateFrame

-- GLOBALS: WeakAuras

local AceGUI = LibStub("AceGUI-3.0")
local SharedMedia = LibStub("LibSharedMedia-3.0")
local IndentationLib = IndentationLib

local WeakAuras = WeakAuras
local L = WeakAuras.L

local textEditor

local valueFromPath = WeakAuras.ValueFromPath;
local valueToPath = WeakAuras.ValueToPath;

local tableColor = "|c00ff3333"
local arithmeticColor = "|c00ff3333"
local relationColor = "|c00ff3333"
local logicColor = "|c004444ff"

local colorScheme = {
  [IndentationLib.tokens.TOKEN_SPECIAL] = "|c00ff3333",
  [IndentationLib.tokens.TOKEN_KEYWORD] = "|c004444ff",
  [IndentationLib.tokens.TOKEN_COMMENT_SHORT] = "|c0000aa00",
  [IndentationLib.tokens.TOKEN_COMMENT_LONG] = "|c0000aa00",
  [IndentationLib.tokens.TOKEN_NUMBER] = "|c00ff9900",
  [IndentationLib.tokens.TOKEN_STRING] = "|c00999999",
  -- ellipsis, curly braces, table acces
  ["..."] = tableColor,
  ["{"] = tableColor,
  ["}"] = tableColor,
  ["["] = tableColor,
  ["]"] = tableColor,
  -- arithmetic operators
  ["+"] = arithmeticColor,
  ["-"] = arithmeticColor,
  ["/"] = arithmeticColor,
  ["*"] = arithmeticColor,
  [".."] = arithmeticColor,
  -- relational operators
  ["=="] = relationColor,
  ["<"] = relationColor,
  ["<="] = relationColor,
  [">"] = relationColor,
  [">="] = relationColor,
  ["~="] = relationColor,
  -- logical operators
  ["and"] = logicColor,
  ["or"] = logicColor,
  ["not"] = logicColor,
  -- misc
  [0] = "|r",
}

local function ConstructTextEditor(frame)
  local group = AceGUI:Create("InlineGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 12);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -10);
  group.frame:Hide();
  group:SetLayout("fill");

  local editor = AceGUI:Create("MultiLineEditBox");
  editor:SetWidth(400);
  editor.button:Hide();
  local fontPath = SharedMedia:Fetch("font", "Fira Mono Medium");
  if(fontPath) then
    editor.editBox:SetFont(fontPath, 12);
  end
  group:AddChild(editor);
  editor.frame:SetClipsChildren(true);

  -- The indention lib overrides GetText, but for the line number
  -- display we ned the original, so save it here.
  local originalGetText = editor.editBox.GetText;
  IndentationLib.enable(editor.editBox, colorScheme, 4);

  local cancel = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  cancel:SetScript("OnClick", function() group:CancelClose() end);
  cancel:SetPoint("BOTTOMRIGHT", -27, 13);
  cancel:SetHeight(20);
  cancel:SetWidth(100);
  cancel:SetText(L["Cancel"]);

  local close = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  close:SetScript("OnClick", function() group:Close() end);
  close:SetPoint("RIGHT", cancel, "LEFT", -10, 0)
  close:SetHeight(20);
  close:SetWidth(100);
  close:SetText(L["Done"]);

  local editorError = group.frame:CreateFontString(nil, "OVERLAY");
  editorError:SetFont("Fonts\\FRIZQT__.TTF", 10)
  editorError:SetJustifyH("LEFT");
  editorError:SetJustifyV("TOP");
  editorError:SetTextColor(1, 0, 0);
  editorError:SetPoint("TOPLEFT", editor.frame, "BOTTOMLEFT", 5, 25);
  editorError:SetPoint("BOTTOMRIGHT", close, "BOTTOMLEFT");

  local editorLine = CreateFrame("Editbox", nil, group.frame);
  -- Set script on enter pressed..
  editorLine:SetPoint("BOTTOMRIGHT", editor.frame, "TOPRIGHT", -10, -15);
  editorLine:SetFont("Fonts\\FRIZQT__.TTF", 10)
  editorLine:SetJustifyH("RIGHT");
  editorLine:SetWidth(80);
  editorLine:SetHeight(20);
  editorLine:SetNumeric(true);
  editorLine:SetTextInsets(10, 10, 0, 0);

  local oldOnCursorChanged = editor.editBox:GetScript("OnCursorChanged");
  editor.editBox:SetScript("OnCursorChanged", function(...)
    oldOnCursorChanged(...);
    local cursorPosition = editor.editBox:GetCursorPosition();
    local next = -1;
    local line = 0;
    while (next and cursorPosition >= next) do
      next = originalGetText(editor.editBox):find("[\n]", next + 1);
      line = line + 1;
    end
    editorLine:SetNumber(line);
  end);

  editorLine:SetScript("OnEnterPressed", function()
    local newLine = editorLine:GetNumber();
    local newPosition = 0;
    while (newLine > 1 and newPosition) do
      newPosition = originalGetText(editor.editBox):find("[\n]", newPosition + 1);
      newLine = newLine - 1;
    end

    if (newPosition) then
      editor.editBox:SetCursorPosition(newPosition);
      editor.editBox:SetFocus();
    end
  end);

  function group.Open(self, data, path, enclose, addReturn)
    self.data = data;
    self.path = path;
    self.addReturn = addReturn;
    if(frame.window == "texture") then
      frame.texturePicker:CancelClose();
    elseif(frame.window == "icon") then
      frame.iconPicker:CancelClose();
    end
    frame.container.frame:Hide();
    frame.buttonsContainer.frame:Hide();
    self.frame:Show();
    frame.window = "texteditor";
    local title = (type(data.id) == "string" and data.id or L["Temporary Group"]).." -";
    for index, field in pairs(path) do
      if(type(field) == "number") then
        field = "Trigger "..field+1
      end
      title = title.." "..field:sub(1, 1):upper()..field:sub(2);
    end
    editor:SetLabel(title);
    editor.editBox:SetScript("OnEscapePressed", function() group:CancelClose(); end);
    self.oldOnTextChanged = editor.editBox:GetScript("OnTextChanged");
    editor.editBox:SetScript("OnTextChanged", function(...)
      local str = editor.editBox:GetText();
      if not(str) or editor.combinedText == true then
        editorError:SetText("");
      else
        local _, errorString
        if(enclose) then
          _, errorString = loadstring("return function() "..str.."\n end");
        else
          _, errorString = loadstring("return "..str);
        end
        editorError:SetText(errorString or "");
      end
      self.oldOnTextChanged(...);
    end);
    if(data.controlledChildren) then
      local singleText;
      local sameTexts = true;
      local combinedText = "";
      for index, childId in pairs(data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        local text = valueFromPath(childData, path);
        if(addReturn and text and #text > 8) then
          text = text:sub(8);
        end
        if not(singleText) then
          singleText = text;
        else
          if not(singleText == text) then
            sameTexts = false;
          end
        end
        if not(combinedText == "") then
          combinedText = combinedText.."\n\n";
        end

        combinedText = combinedText.. L["-- Do not remove this comment, it is part of this trigger: "] .. childId .. "\n";
        combinedText = combinedText..(text or "");
      end
      if(sameTexts) then
        editor:SetText(singleText or "");
        editor.combinedText = false;
      else
        editor:SetText(combinedText);
        editor.combinedText = true;
      end
    else
      if(addReturn) then
        local value = valueFromPath(data, path);
        editor:SetText(value and #value > 8 and value:sub(8) or "");
      else
        editor:SetText(valueFromPath(data, path) or "");
      end
    end
    editor:SetFocus();
  end

  function group.CancelClose(self)
    editor.editBox:SetScript("OnTextChanged", self.oldOnTextChanged);
    editor:ClearFocus();
    self.frame:Hide();
    frame.container.frame:Show();
    frame.buttonsContainer.frame:Show();
    frame.window = "default";
  end

  local function extractTexts(input, ids)
    local texts = {};

    local currentPos, id, startIdLine, startId, endId, endIdLine;
    while (true) do
      startIdLine, startId = string.find(input, L["-- Do not remove this comment, it is part of this trigger: "], currentPos, true);
      if (not startId) then break end

      endId, endIdLine = string.find(input, "\n", startId, true);
      if (not endId) then break end;

      if (currentPos) then
        local trimmedPosition = startIdLine - 1;
        while (string.sub(input, trimmedPosition, trimmedPosition) == "\n") do
          trimmedPosition = trimmedPosition - 1;
        end

        texts[id] = string.sub(input, currentPos, trimmedPosition);
      end

      id = string.sub(input, startId + 1, endId - 1);

      currentPos = endIdLine + 1;
    end

    if (id) then
      texts[id] = string.sub(input, currentPos, string.len(input));
    end

    return texts;
  end

  function group.Close(self)
    if(self.data.controlledChildren) then
      local textById = editor.combinedText and extractTexts(editor:GetText(), self.data.controlledChildren);
      for index, childId in pairs(self.data.controlledChildren) do
        local text = editor.combinedText and (textById[childId] or "") or editor:GetText();
        local childData = WeakAuras.GetData(childId);
        if(self.addReturn) then
          valueToPath(childData, self.path, "return "..text);
        else
          valueToPath(childData, self.path, text);
        end
        WeakAuras.Add(childData);
      end
    else
      if(self.addReturn) then
        valueToPath(self.data, self.path, "return "..editor:GetText());
      else
        valueToPath(self.data, self.path, editor:GetText());
      end
      WeakAuras.Add(self.data);
    end

    editor.editBox:SetScript("OnTextChanged", self.oldOnTextChanged);
    editor:ClearFocus();
    self.frame:Hide();
    frame.container.frame:Show();
    frame.buttonsContainer.frame:Show();
    frame.window = "default";

    frame:RefreshPick();
  end

  return group
end

function WeakAuras.TextEditor(frame)
  textEditor = textEditor or ConstructTextEditor(frame)
  return textEditor
end

-- Lua APIs
local tinsert, tconcat, tremove, wipe = table.insert, table.concat, table.remove, wipe
local select, pairs, next, type, unpack = select, pairs, next, type, unpack

-- WoW APIs
local CreateFrame = CreateFrame

-- GLOBALS: WeakAuras

local AceGUI = LibStub("AceGUI-3.0")
local AceConfigDialog = LibStub("AceConfigDialog-3.0")

local WeakAuras = WeakAuras
local L = WeakAuras.L

local texturePicker

local function ConstructTexturePicker(frame)
  local group = AceGUI:Create("InlineGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 42);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -10);
  group.frame:Hide();
  group.children = {};
  group.categories = {};

  local dropdown = AceGUI:Create("DropdownGroup");
  dropdown:SetLayout("fill");
  dropdown.width = "fill";
  dropdown:SetHeight(390);
  group:SetLayout("fill");
  group:AddChild(dropdown);
  dropdown.list = {};
  dropdown:SetGroupList(dropdown.list);

  local scroll = AceGUI:Create("ScrollFrame");
  scroll:SetWidth(540);
  scroll:SetLayout("flow");
  scroll.frame:SetClipsChildren(true);
  dropdown:AddChild(scroll);

  local function texturePickerGroupSelected(widget, event, uniquevalue)
    scroll:ReleaseChildren();
    for texturePath, textureName in pairs(group.textures[uniquevalue]) do
      local textureWidget = AceGUI:Create("WeakAurasTextureButton");
      if (group.SetTextureFunc) then
        group.SetTextureFunc(textureWidget, texturePath, textureName);
      else
        textureWidget:SetTexture(texturePath, textureName);
        local d = group.textureData;
        textureWidget:ChangeTexture(d.r, d.g, d.b, d.a, d.rotate, d.discrete_rotation, d.rotation, d.mirror, d.blendMode);
      end

      textureWidget:SetClick(function()
        group:Pick(texturePath);
      end);
      scroll:AddChild(textureWidget);
      table.sort(scroll.children, function(a, b)
        local aPath, bPath = a:GetTexturePath(), b:GetTexturePath();
        local aNum, bNum = tonumber(aPath:match("%d+")), tonumber(bPath:match("%d+"));
        local aNonNumber, bNonNumber = aPath:match("[^%d]+"), bPath:match("[^%d]+")
        if(aNum and bNum and aNonNumber == bNonNumber) then
          return aNum < bNum;
        else
          return aPath < bPath;
        end
      end);
    end
    group:Pick(group.data[group.field]);
  end

  dropdown:SetCallback("OnGroupSelected", texturePickerGroupSelected)

  function group.UpdateList(self)
    wipe(dropdown.list);
    for categoryName, category in pairs(self.textures) do
      local match = false;
      for texturePath, textureName in pairs(category) do
        if(texturePath == self.data[self.field]) then
          match = true;
          break;
        end
      end
      dropdown.list[categoryName] = (match and "|cFF80A0FF" or "")..categoryName;
    end
    dropdown:SetGroupList(dropdown.list);
  end

  function group.Pick(self, texturePath)
    local pickedwidget;
    for index, widget in ipairs(scroll.children) do
      widget:ClearPick();
      if(widget:GetTexturePath() == texturePath) then
        pickedwidget = widget;
      end
    end
    if(pickedwidget) then
      pickedwidget:Pick();
    end

    if(self.data.controlledChildren) then
      setAll(self.data, {"region", self.field}, texturePath);
    else
      self.data[self.field] = texturePath;
    end
    if(type(self.data.id) == "string") then
      WeakAuras.Add(self.data);
      WeakAuras.SetIconNames(self.data);
      WeakAuras.SetThumbnail(self.data);
    end
    group:UpdateList();
    local status = dropdown.status or dropdown.localstatus
    dropdown.dropdown:SetText(dropdown.list[status.selected]);
  end

  function group.Open(self, data, field, textures, SetTextureFunc)
    self.data = data;
    self.field = field;
    self.textures = textures;
    self.SetTextureFunc = SetTextureFunc
    if(data.controlledChildren) then
      self.givenPath = {};
      for index, childId in pairs(data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        if(childData) then
          self.givenPath[childId] = childData[field];
        end
      end
      local colorAll = getAll(data, {"region", "color"}) or {1, 1, 1, 1};
      self.textureData = {
        r = colorAll[1] or 1,
        g = colorAll[2] or 1,
        b = colorAll[3] or 1,
        a = colorAll[4] or 1,
        rotate = getAll(data, {"region", "rotate"}),
        discrete_rotation = getAll(data, {"region", "discrete_rotation"}) or 0,
        rotation = getAll(data, {"region", "rotation"}) or 0,
        mirror = getAll(data, {"region", "mirror"}),
        blendMode = getAll(data, {"region", "blendMode"}) or "ADD"
      };
    else
      self.givenPath = data[field];
      data.color = data.color or {};
      self.textureData = {
        r = data.color[1] or 1,
        g = data.color[2] or 1,
        b = data.color[3] or 1,
        a = data.color[4] or 1,
        rotate = data.rotate,
        discrete_rotation = data.discrete_rotation or 0,
        rotation = data.rotation or 0,
        mirror = data.mirror,
        blendMode = data.blendMode or "ADD"
      };
    end
    frame.container.frame:Hide();
    frame.buttonsContainer.frame:Hide();
    self.frame:Show();
    frame.window = "texture";
    local picked = false;
    local _, givenPath
    if(type(self.givenPath) == "string") then
      givenPath = self.givenPath;
    else
      _, givenPath = next(self.givenPath);
    end
    WeakAuras.debug(givenPath, 3);
    for categoryName, category in pairs(self.textures) do
      if not(picked) then
        for texturePath, textureName in pairs(category) do
          if(texturePath == givenPath) then
            dropdown:SetGroup(categoryName);
            self:Pick(givenPath);
            picked = true;
            break;
          end
        end
      end
    end
    if not(picked) then
      for categoryName, category in pairs(self.textures) do
        dropdown:SetGroup(categoryName);
        break;
      end
    end
  end

  function group.Close()
    group.frame:Hide();
    frame.buttonsContainer.frame:Show();
    frame.container.frame:Show();
    frame.window = "default";
    AceConfigDialog:Open("WeakAuras", frame.container);
  end

  function group.CancelClose()
    if(group.data.controlledChildren) then
      for index, childId in pairs(group.data.controlledChildren) do
        local childData = WeakAuras.GetData(childId);
        if(childData) then
          childData[group.field] = group.givenPath[childId];
          WeakAuras.Add(childData);
          WeakAuras.SetThumbnail(childData);
          WeakAuras.SetIconNames(childData);
        end
      end
    else
      group:Pick(group.givenPath);
    end
    group.Close();
  end

  local cancel = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate")
  cancel:SetScript("OnClick", group.CancelClose)
  cancel:SetPoint("BOTTOMRIGHT", -27, -23)
  cancel:SetSize(100, 20)
  cancel:SetText(L["Cancel"])

  local close = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate")
  close:SetScript("OnClick", group.Close)
  close:SetPoint("RIGHT", cancel, "LEFT", -10, 0)
  close:SetSize(100, 20)
  close:SetText(L["Okay"])

  return group
end

function WeakAuras.TexturePicker(frame)
  texturePicker = texturePicker or ConstructTexturePicker(frame)
  return texturePicker
end

-- Lua APIs
local select, pairs, next, type, unpack = select, pairs, next, type, unpack

-- WoW APIs
local IsShiftKeyDown, CreateFrame =  IsShiftKeyDown, CreateFrame

-- GLOBALS: WeakAuras

local AceConfigDialog = LibStub("AceConfigDialog-3.0")

local WeakAuras = WeakAuras
local L = WeakAuras.L

local moversizer
local mover

local displayButtons = WeakAuras.displayButtons
local displayOptions = WeakAuras.displayOptions
local loaded = WeakAuras.loaded
local regionOptions = WeakAuras.regionOptions
local savedVars = WeakAuras.savedVars
local tempGroup = WeakAuras.tempGroup

local function EnsureTexture(self, texture)
  if(texture) then
    return texture;
  else
    local ret = self:CreateTexture();
    ret:SetTexture("Interface\\GLUES\\CharacterSelect\\Glues-AddOn-Icons.blp");
    ret:SetWidth(16);
    ret:SetHeight(16);
    ret:SetTexCoord(0, 0.25, 0, 1);
    ret:SetVertexColor(1, 1, 1, 0.25);
    return ret;
  end
end

local function ConstructSizer(frame)
  -- topright, bottomright, bottomleft, topleft

  local topright = CreateFrame("FRAME", nil, frame);
  topright:EnableMouse();
  topright:SetWidth(16);
  topright:SetHeight(16);
  topright:SetPoint("TOPRIGHT", frame, "TOPRIGHT");

  local texTR1 = topright:CreateTexture(nil, "OVERLAY");
  texTR1:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texTR1:SetBlendMode("ADD");
  texTR1:SetTexCoord(0.5, 0, 0, 0, 0.5, 1, 0, 1);
  texTR1:SetPoint("TOPRIGHT", topright, "TOPRIGHT", -3, -3);
  texTR1:SetPoint("BOTTOMLEFT", topright, "BOTTOM");

  local texTR2 = topright:CreateTexture(nil, "OVERLAY");
  texTR2:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texTR2:SetBlendMode("ADD");
  texTR2:SetTexCoord(0, 0, 0, 1, 0.5, 0, 0.5, 1);
  texTR2:SetPoint("TOPRIGHT", texTR1, "TOPLEFT");
  texTR2:SetPoint("BOTTOMLEFT", topright, "LEFT");

  topright.Highlight = function()
    texTR1:Show();
    texTR2:Show();
  end
  topright.Clear = function()
    texTR1:Hide();
    texTR2:Hide();
  end

  local bottomright = CreateFrame("FRAME", nil, frame);
  bottomright:EnableMouse();
  bottomright:SetWidth(16);
  bottomright:SetHeight(16);
  bottomright:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT");

  local texBR1 = bottomright:CreateTexture(nil, "OVERLAY");
  texBR1:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texBR1:SetBlendMode("ADD");
  texBR1:SetTexCoord(1, 0, 0.5, 0, 1, 1, 0.5, 1);
  texBR1:SetPoint("BOTTOMRIGHT", bottomright, "BOTTOMRIGHT", -3, 3);
  texBR1:SetPoint("TOPLEFT", bottomright, "TOP");

  local texBR2 = bottomright:CreateTexture(nil, "OVERLAY");
  texBR2:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texBR2:SetBlendMode("ADD");
  texBR2:SetTexCoord(0, 0, 0, 1, 0.5, 0, 0.5, 1);
  texBR2:SetPoint("BOTTOMRIGHT", texBR1, "BOTTOMLEFT");
  texBR2:SetPoint("TOPLEFT", bottomright, "LEFT");

  bottomright.Highlight = function()
    texBR1:Show();
    texBR2:Show();
  end
  bottomright.Clear = function()
    texBR1:Hide();
    texBR2:Hide();
  end

  local bottomleft = CreateFrame("FRAME", nil, frame);
  bottomleft:EnableMouse();
  bottomleft:SetSize(16, 16);
  bottomleft:SetHeight(16);
  bottomleft:SetPoint("BOTTOMLEFT", frame, "BOTTOMLEFT");

  local texBL1 = bottomleft:CreateTexture(nil, "OVERLAY");
  texBL1:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texBL1:SetBlendMode("ADD");
  texBL1:SetTexCoord(1, 0, 0.5, 0, 1, 1, 0.5, 1);
  texBL1:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMLEFT", 3, 3);
  texBL1:SetPoint("TOPRIGHT", bottomleft, "TOP");

  local texBL2 = bottomleft:CreateTexture(nil, "OVERLAY");
  texBL2:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texBL2:SetBlendMode("ADD");
  texBL2:SetTexCoord(0.5, 0, 0.5, 1, 1, 0, 1, 1);
  texBL2:SetPoint("BOTTOMLEFT", texBL1, "BOTTOMRIGHT");
  texBL2:SetPoint("TOPRIGHT", bottomleft, "RIGHT");

  bottomleft.Highlight = function()
    texBL1:Show();
    texBL2:Show();
  end
  bottomleft.Clear = function()
    texBL1:Hide();
    texBL2:Hide();
  end

  local topleft = CreateFrame("FRAME", nil, frame);
  topleft:EnableMouse();
  topleft:SetWidth(16);
  topleft:SetHeight(16);
  topleft:SetPoint("TOPLEFT", frame, "TOPLEFT");

  local texTL1 = topleft:CreateTexture(nil, "OVERLAY");
  texTL1:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texTL1:SetBlendMode("ADD");
  texTL1:SetTexCoord(0.5, 0, 0, 0, 0.5, 1, 0, 1);
  texTL1:SetPoint("TOPLEFT", topleft, "TOPLEFT", 3, -3);
  texTL1:SetPoint("BOTTOMRIGHT", topleft, "BOTTOM");

  local texTL2 = topleft:CreateTexture(nil, "OVERLAY");
  texTL2:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texTL2:SetBlendMode("ADD");
  texTL2:SetTexCoord(0.5, 0, 0.5, 1, 1, 0, 1, 1);
  texTL2:SetPoint("TOPLEFT", texTL1, "TOPRIGHT");
  texTL2:SetPoint("BOTTOMRIGHT", topleft, "RIGHT");

  topleft.Highlight = function()
    texTL1:Show();
    texTL2:Show();
  end
  topleft.Clear = function()
    texTL1:Hide();
    texTL2:Hide();
  end

  -- top, right, bottom, left

  local top = CreateFrame("FRAME", nil, frame);
  top:EnableMouse();
  top:SetHeight(8);
  top:SetPoint("TOPRIGHT", topright, "TOPLEFT");
  top:SetPoint("TOPLEFT", topleft, "TOPRIGHT");

  local texT = top:CreateTexture(nil, "OVERLAY");
  texT:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texT:SetBlendMode("ADD");
  texT:SetPoint("TOPRIGHT", topright, "TOPRIGHT", -3, -3);
  texT:SetPoint("BOTTOMLEFT", topleft, "LEFT", 3, 0);

  top.Highlight = function()
    texT:Show();
  end
  top.Clear = function()
    texT:Hide();
  end

  local right = CreateFrame("FRAME", nil, frame);
  right:EnableMouse();
  right:SetWidth(8);
  right:SetPoint("BOTTOMRIGHT", bottomright, "TOPRIGHT");
  right:SetPoint("TOPRIGHT", topright, "BOTTOMRIGHT");

  local texR = right:CreateTexture(nil, "OVERLAY");
  texR:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texR:SetBlendMode("ADD");
  texR:SetPoint("BOTTOMRIGHT", bottomright, "BOTTOMRIGHT", -3, 3);
  texR:SetPoint("TOPLEFT", topright, "TOP", 0, -3);

  right.Highlight = function()
    texR:Show();
  end
  right.Clear = function()
    texR:Hide();
  end

  local bottom = CreateFrame("FRAME", nil, frame);
  bottom:EnableMouse();
  bottom:SetHeight(8);
  bottom:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMRIGHT");
  bottom:SetPoint("BOTTOMRIGHT", bottomright, "BOTTOMLEFT");

  local texB = bottom:CreateTexture(nil, "OVERLAY");
  texB:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texB:SetBlendMode("ADD");
  texB:SetTexCoord(1, 0, 0, 0, 1, 1, 0, 1);
  texB:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMLEFT", 3, 3);
  texB:SetPoint("TOPRIGHT", bottomright, "RIGHT", -3, 0);

  bottom.Highlight = function()
    texB:Show();
  end
  bottom.Clear = function()
    texB:Hide();
  end

  local left = CreateFrame("FRAME", nil, frame);
  left:EnableMouse();
  left:SetWidth(8);
  left:SetPoint("TOPLEFT", topleft, "BOTTOMLEFT");
  left:SetPoint("BOTTOMLEFT", bottomleft, "TOPLEFT");

  local texL = left:CreateTexture(nil, "OVERLAY");
  texL:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  texL:SetBlendMode("ADD");
  texL:SetTexCoord(1, 0, 0, 0, 1, 1, 0, 1);
  texL:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMLEFT", 3, 3);
  texL:SetPoint("TOPRIGHT", topleft, "TOP", 0, -3);

  left.Highlight = function()
    texL:Show();
  end
  left.Clear = function()
    texL:Hide();
  end

  -- return in cw order
  return top, topright, right, bottomright, bottom, bottomleft, left, topleft
end

local function ConstructMoverSizer(parent)
  local frame = CreateFrame("FRAME", nil, parent);
  frame:SetBackdrop({
    edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
    edgeSize = 12,
    insets = {left = 0, right = 0, top = 0, bottom = 0}
  });
  frame:EnableMouse();
  frame:SetFrameStrata("HIGH");

  frame.top, frame.topright, frame.right, frame.bottomright, frame.bottom, frame.bottomleft, frame.left, frame.topleft
  = ConstructSizer(frame)

  frame.top.Clear();
  frame.topright.Clear();
  frame.right.Clear();
  frame.bottomright.Clear();
  frame.bottom.Clear();
  frame.bottomleft.Clear();
  frame.left.Clear();
  frame.topleft.Clear();

  local mover = CreateFrame("FRAME", nil, frame);
  mover:EnableMouse();
  mover.moving = {};
  mover.interims = {};
  mover.selfPointIcon = mover:CreateTexture();
  mover.selfPointIcon:SetTexture("Interface\\GLUES\\CharacterSelect\\Glues-AddOn-Icons.blp");
  mover.selfPointIcon:SetWidth(16);
  mover.selfPointIcon:SetHeight(16);
  mover.selfPointIcon:SetTexCoord(0, 0.25, 0, 1);
  mover.anchorPointIcon = mover:CreateTexture();
  mover.anchorPointIcon:SetTexture("Interface\\GLUES\\CharacterSelect\\Glues-AddOn-Icons.blp");
  mover.anchorPointIcon:SetWidth(16);
  mover.anchorPointIcon:SetHeight(16);
  mover.anchorPointIcon:SetTexCoord(0, 0.25, 0, 1);

  local moverText = mover:CreateFontString(nil, "OVERLAY", "GameFontNormal");
  mover.text = moverText;
  moverText:Hide();

  local sizerText = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal");
  frame.text = sizerText;
  sizerText:Hide();

  frame.ScaleCorners = function(self, width, height)
    local limit = math.min(width, height) + 16;
    local size = 16;
    if(limit <= 40) then
      size = limit * (2/5);
    end
    frame.bottomleft:SetWidth(size);
    frame.bottomleft:SetHeight(size);
    frame.bottomright:SetWidth(size);
    frame.bottomright:SetHeight(size);
    frame.topright:SetWidth(size);
    frame.topright:SetHeight(size);
    frame.topleft:SetWidth(size);
    frame.topleft:SetHeight(size);
  end

  frame.ReAnchor = function(self)
    if(mover.moving.region) then
      self:AnchorPoints(mover.moving.region, mover.moving.data);
    end
  end

  frame.AnchorPoints = function(self, region, data)
    local scale = region:GetEffectiveScale() / UIParent:GetEffectiveScale();
    local xOff, yOff;
    mover.selfPoint, mover.anchor, mover.anchorPoint, xOff, yOff = region:GetPoint(1);
    mover:ClearAllPoints();
    frame:ClearAllPoints();
    if(data.regionType == "group") then
      mover:SetWidth((region.trx - region.blx) * scale);
      mover:SetHeight((region.try - region.bly) * scale);
      mover:SetPoint(mover.selfPoint, mover.anchor, mover.anchorPoint, (xOff + region.blx) * scale, (yOff + region.bly) * scale);
    else
      mover:SetWidth(region:GetWidth() * scale);
      mover:SetHeight(region:GetHeight() * scale);
      mover:SetPoint(mover.selfPoint, mover.anchor, mover.anchorPoint, xOff * scale, yOff * scale);
    end
    frame:SetPoint("BOTTOMLEFT", mover, "BOTTOMLEFT", -8, -8);
    frame:SetPoint("TOPRIGHT", mover, "TOPRIGHT", 8, 8);
    frame:ScaleCorners(region:GetWidth(), region:GetHeight());
  end

  frame.SetToRegion = function(self, region, data)
    local scale = region:GetEffectiveScale() / UIParent:GetEffectiveScale();
    mover.moving.region = region;
    mover.moving.data = data;
    local xOff, yOff;
    mover.selfPoint, mover.anchor, mover.anchorPoint, xOff, yOff = region:GetPoint(1);
    mover:ClearAllPoints();
    frame:ClearAllPoints();
    if(data.regionType == "group") then
      mover:SetWidth((region.trx - region.blx) * scale);
      mover:SetHeight((region.try - region.bly) * scale);
      mover:SetPoint(mover.selfPoint, mover.anchor, mover.anchorPoint, (xOff + region.blx) * scale, (yOff + region.bly) * scale);
    else
      mover:SetWidth(region:GetWidth() * scale);
      mover:SetHeight(region:GetHeight() * scale);
      mover:SetPoint(mover.selfPoint, mover.anchor, mover.anchorPoint, xOff * scale, yOff * scale);
    end
    frame:SetPoint("BOTTOMLEFT", mover, "BOTTOMLEFT", -8, -8);
    frame:SetPoint("TOPRIGHT", mover, "TOPRIGHT", 8, 8);
    frame:ScaleCorners(region:GetWidth(), region:GetHeight());

    local db = savedVars.db;
    mover.startMoving = function()
      WeakAuras.CancelAnimation(region, true, true, true, true, true);
      mover:ClearAllPoints();
      if(data.regionType == "group") then
        local scale = region:GetEffectiveScale() / UIParent:GetEffectiveScale();
        mover:SetPoint(mover.selfPoint, region, mover.anchorPoint, region.blx * scale, region.bly * scale);
      else
        mover:SetPoint(mover.selfPoint, region, mover.selfPoint);
      end
      region:StartMoving();
      mover.isMoving = true;
      mover.text:Show();
    end

    mover.doneMoving = function(self)
      local scale = region:GetEffectiveScale() / UIParent:GetEffectiveScale();
      region:StopMovingOrSizing();
      mover.isMoving = false;
      mover.text:Hide();

      if(data.xOffset and data.yOffset) then
        local selfX, selfY = mover.selfPointIcon:GetCenter();
        local anchorX, anchorY = mover.anchorPointIcon:GetCenter();
        local dX = selfX - anchorX;
        local dY = selfY - anchorY;
        data.xOffset = dX / scale;
        data.yOffset = dY / scale;
      end
      WeakAuras.Add(data);
      WeakAuras.SetThumbnail(data);
      region:SetPoint(self.selfPoint, self.anchor, self.anchorPoint, data.xOffset, data.yOffset);
      mover.selfPoint, mover.anchor, mover.anchorPoint, xOff, yOff = region:GetPoint(1);
      mover:ClearAllPoints();
      if(data.regionType == "group") then
        mover:SetWidth((region.trx - region.blx) * scale);
        mover:SetHeight((region.try - region.bly) * scale);
        mover:SetPoint(mover.selfPoint, mover.anchor, mover.anchorPoint, (xOff + region.blx) * scale, (yOff + region.bly) * scale);
      else
        mover:SetWidth(region:GetWidth() * scale);
        mover:SetHeight(region:GetHeight() * scale);
        mover:SetPoint(mover.selfPoint, mover.anchor, mover.anchorPoint, xOff * scale, yOff * scale);
      end
      if(data.parent) then
        local parentData = db.displays[data.parent];
        if(parentData) then
          WeakAuras.Add(parentData);
          WeakAuras.SetThumbnail(parentData);
        end
      end
      AceConfigDialog:Open("WeakAuras", parent.container);
      WeakAuras.Animate("display", data.id, "main", data.animation.main, WeakAuras.regions[data.id].region, false, nil, true);
    end

    if(data.parent and db.displays[data.parent] and db.displays[data.parent].regionType == "dynamicgroup") then
      mover:SetScript("OnMouseDown", nil);
      mover:SetScript("OnMouseUp", nil);
    else
      mover:SetScript("OnMouseDown", mover.startMoving);
      mover:SetScript("OnMouseUp", mover.doneMoving);
    end

    if(region:IsResizable()) then
      frame.startSizing = function(point)
        mover.isMoving = true;
        WeakAuras.CancelAnimation(region, true, true, true, true, true);
        local rSelfPoint, rAnchor, rAnchorPoint, rXOffset, rYOffset = region:GetPoint(1);
        region:StartSizing(point);
        local textpoint, anchorpoint;
        if(point:find("BOTTOM")) then textpoint = "TOP"; anchorpoint = "BOTTOM";
        elseif(point:find("TOP")) then textpoint = "BOTTOM"; anchorpoint = "TOP";
        elseif(point:find("LEFT")) then textpoint = "RIGHT"; anchorpoint = "LEFT";
        elseif(point:find("RIGHT")) then textpoint = "LEFT"; anchorpoint = "RIGHT"; end
        frame.text:ClearAllPoints();
        frame.text:SetPoint(textpoint, frame, anchorpoint);
        frame.text:Show();
        mover:SetAllPoints(region);
        frame:SetScript("OnUpdate", function()
          frame.text:SetText(("(%.2f, %.2f)"):format(region:GetWidth(), region:GetHeight()));
          if(data.width and data.height) then
            data.width = region:GetWidth();
            data.height = region:GetHeight();
          end
          WeakAuras.Add(data);
          region:ClearAllPoints();
          region:SetPoint(rSelfPoint, rAnchor, rAnchorPoint, rXOffset, rYOffset);
          frame:ScaleCorners(region:GetWidth(), region:GetHeight());
          AceConfigDialog:Open("WeakAuras", parent.container);
        end);
      end

      frame.doneSizing = function()
        local scale = region:GetEffectiveScale() / UIParent:GetEffectiveScale();
        mover.isMoving = false;
        region:StopMovingOrSizing();
        WeakAuras.Add(data);
        WeakAuras.SetThumbnail(data);
        if(data.parent) then
          local parentData = db.displays[data.parent];
          WeakAuras.Add(parentData);
          WeakAuras.SetThumbnail(parentData);
        end
        frame.text:Hide();
        frame:SetScript("OnUpdate", nil);
        mover:ClearAllPoints();
        mover:SetWidth(region:GetWidth() * scale);
        mover:SetHeight(region:GetHeight() * scale);
        mover:SetPoint(mover.selfPoint, mover.anchor, mover.anchorPoint, xOff * scale, yOff * scale);
        WeakAuras.Animate("display", data.id, "main", data.animation.main, WeakAuras.regions[data.id].region, false, nil, true);
      end

      frame.bottomleft:SetScript("OnMouseDown", function() frame.startSizing("BOTTOMLEFT") end);
      frame.bottomleft:SetScript("OnMouseUp", frame.doneSizing);
      frame.bottomleft:SetScript("OnEnter", frame.bottomleft.Highlight);
      frame.bottomleft:SetScript("OnLeave", frame.bottomleft.Clear);
      frame.bottom:SetScript("OnMouseDown", function() frame.startSizing("BOTTOM") end);
      frame.bottom:SetScript("OnMouseUp", frame.doneSizing);
      frame.bottom:SetScript("OnEnter", frame.bottom.Highlight);
      frame.bottom:SetScript("OnLeave", frame.bottom.Clear);
      frame.bottomright:SetScript("OnMouseDown", function() frame.startSizing("BOTTOMRIGHT") end);
      frame.bottomright:SetScript("OnMouseUp", frame.doneSizing);
      frame.bottomright:SetScript("OnEnter", frame.bottomright.Highlight);
      frame.bottomright:SetScript("OnLeave", frame.bottomright.Clear);
      frame.right:SetScript("OnMouseDown", function() frame.startSizing("RIGHT") end);
      frame.right:SetScript("OnMouseUp", frame.doneSizing);
      frame.right:SetScript("OnEnter", frame.right.Highlight);
      frame.right:SetScript("OnLeave", frame.right.Clear);
      frame.topright:SetScript("OnMouseDown", function() frame.startSizing("TOPRIGHT") end);
      frame.topright:SetScript("OnMouseUp", frame.doneSizing);
      frame.topright:SetScript("OnEnter", frame.topright.Highlight);
      frame.topright:SetScript("OnLeave", frame.topright.Clear);
      frame.top:SetScript("OnMouseDown", function() frame.startSizing("TOP") end);
      frame.top:SetScript("OnMouseUp", frame.doneSizing);
      frame.top:SetScript("OnEnter", frame.top.Highlight);
      frame.top:SetScript("OnLeave", frame.top.Clear);
      frame.topleft:SetScript("OnMouseDown", function() frame.startSizing("TOPLEFT") end);
      frame.topleft:SetScript("OnMouseUp", frame.doneSizing);
      frame.topleft:SetScript("OnEnter", frame.topleft.Highlight);
      frame.topleft:SetScript("OnLeave", frame.topleft.Clear);
      frame.left:SetScript("OnMouseDown", function() frame.startSizing("LEFT") end);
      frame.left:SetScript("OnMouseUp", frame.doneSizing);
      frame.left:SetScript("OnEnter", frame.left.Highlight);
      frame.left:SetScript("OnLeave", frame.left.Clear);

      frame.bottomleft:Show();
      frame.bottom:Show();
      frame.bottomright:Show();
      frame.right:Show();
      frame.topright:Show();
      frame.top:Show();
      frame.topleft:Show();
      frame.left:Show();
    else
      frame.bottomleft:Hide();
      frame.bottom:Hide();
      frame.bottomright:Hide();
      frame.right:Hide();
      frame.topright:Hide();
      frame.top:Hide();
      frame.topleft:Hide();
      frame.left:Hide();
    end
    frame:Show();
  end

  mover:SetScript("OnUpdate", function(self, elaps)
    if(IsShiftKeyDown()) then
      self.goalAlpha = 0.1;
    else
      self.goalAlpha = 1;
    end

    if(self.currentAlpha ~= self.goalAlpha) then
      self.currentAlpha = self.currentAlpha or self:GetAlpha();
      local newAlpha = (self.currentAlpha < self.goalAlpha) and self.currentAlpha + (elaps * 4) or self.currentAlpha - (elaps * 4);
      local newAlpha = (newAlpha > 1 and 1) or (newAlpha < 0.1 and 0.1) or newAlpha;
      mover:SetAlpha(newAlpha);
      frame:SetAlpha(newAlpha);
      self.currentAlpha = newAlpha;
    end

    local db = savedVars.db;
    local region = self.moving.region;
    local data = self.moving.data;
    if not(self.isMoving) then
      self.selfPoint, self.anchor, self.anchorPoint = region:GetPoint(1);
    end
    self.selfPointIcon:ClearAllPoints();
    self.selfPointIcon:SetPoint("CENTER", region, self.selfPoint);
    local selfX, selfY = self.selfPointIcon:GetCenter();
    selfX, selfY = selfX or 0, selfY or 0;
    self.anchorPointIcon:ClearAllPoints();
    self.anchorPointIcon:SetPoint("CENTER", self.anchor, self.anchorPoint);
    local anchorX, anchorY = self.anchorPointIcon:GetCenter();
    anchorX, anchorY = anchorX or 0, anchorY or 0;
    if(data.parent and db.displays[data.parent] and db.displays[data.parent].regionType == "dynamicgroup") then
      self.selfPointIcon:Hide();
      self.anchorPointIcon:Hide();
    else
      self.selfPointIcon:Show();
      self.anchorPointIcon:Show();
    end

    local dX = selfX - anchorX;
    local dY = selfY - anchorY;
    local distance = sqrt(dX^2 + dY^2);
    local angle = atan2(dY, dX);

    local numInterim = floor(distance/40);

    for index, texture in pairs(self.interims) do
      texture:Hide();
    end
    for i = 1, numInterim  do
      local x = (distance - (i * 40)) * cos(angle);
      local y = (distance - (i * 40)) * sin(angle);
      self.interims[i] = EnsureTexture(self, self.interims[i]);
      self.interims[i]:ClearAllPoints();
      self.interims[i]:SetPoint("CENTER", self.anchorPointIcon, "CENTER", x, y);
      self.interims[i]:Show();
    end

    self.text:SetText(("(%.2f, %.2f)"):format(dX, dY));
    local midx = (distance / 2) * cos(angle);
    local midy = (distance / 2) * sin(angle);
    self.text:SetPoint("CENTER", self.anchorPointIcon, "CENTER", midx, midy);
    if((midx > 0 and (self.text:GetRight() or 0) > (frame:GetLeft() or 0)) or (midx < 0 and (self.text:GetLeft() or 0) < (frame:GetRight() or 0))) then
      if(midy > 0 and (self.text:GetTop() or 0) > (frame:GetBottom() or 0)) then
        midy = midy - ((self.text:GetTop() or 0) - (frame:GetBottom() or 0));
      elseif(midy < 0 and (self.text:GetBottom() or 0) < (frame:GetTop() or 0)) then
        midy = midy + ((frame:GetTop() or 0) - (self.text:GetBottom() or 0));
      end
    end
    self.text:SetPoint("CENTER", self.anchorPointIcon, "CENTER", midx, midy);
  end);

  return frame, mover
end

function WeakAuras.MoverSizer(parent)
  if not moversizer or not __mover then
    moversizer, mover = ConstructMoverSizer(parent)
  end
  return moversizer, mover
end

-- Lua APIs
local select, pairs, next, type, unpack = select, pairs, next, type, unpack
local loadstring, assert, error = loadstring, assert, error

-- WoW APIs
local CreateFrame, IsMouseButtonDown, SetCursor, GetMouseFocus, MouseIsOver, ResetCursor
  = CreateFrame, IsMouseButtonDown, SetCursor, GetMouseFocus, MouseIsOver, ResetCursor

-- GLOBALS: WeakAuras

local AceConfigDialog = LibStub("AceConfigDialog-3.0")

local WeakAuras = WeakAuras
local L = WeakAuras.L

local valueFromPath = WeakAuras.ValueFromPath
local valueToPath = WeakAuras.ValueToPath

local frameChooserFrame
local frameChooserBox

local oldFocus
local oldFocusName
function WeakAuras.StartFrameChooser(data, path)
  local frame = WeakAuras.OptionsFrame();
  if not(frameChooserFrame) then
    frameChooserFrame = CreateFrame("frame");
    frameChooserBox = CreateFrame("frame", nil, frameChooserFrame);
    frameChooserBox:SetFrameStrata("TOOLTIP");
    frameChooserBox:SetBackdrop({
      edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
      edgeSize = 12,
      insets = {left = 0, right = 0, top = 0, bottom = 0}
    });
    frameChooserBox:SetBackdropBorderColor(0, 1, 0);
    frameChooserBox:Hide();
  end
  local givenValue = valueFromPath(data, path);

  frameChooserFrame:SetScript("OnUpdate", function()
    if(IsMouseButtonDown("RightButton")) then
      valueToPath(data, path, givenValue);
      AceConfigDialog:Open("WeakAuras", frame.container);
      WeakAuras.StopFrameChooser(data);
    elseif(IsMouseButtonDown("LeftButton") and oldFocusName) then
      WeakAuras.StopFrameChooser(data);
    else
      SetCursor("CAST_CURSOR");

      local focus = GetMouseFocus();
      local focusName;

      if(focus) then
        focusName = focus:GetName();
        if(focusName == "WorldFrame" or not focusName) then
          focusName = nil;
          for id, regionData in pairs(WeakAuras.regions) do
            if(regionData.region:IsVisible() and MouseIsOver(regionData.region)) then
              focus = regionData.region;
              focusName = "WeakAuras:"..id;
            end
          end
        end

        if(focus ~= oldFocus) then
          if(focusName) then
            frameChooserBox:SetPoint("bottomleft", focus, "bottomleft", -4, -4);
            frameChooserBox:SetPoint("topright", focus, "topright", 4, 4);
            frameChooserBox:Show();
          end

          if(focusName ~= oldFocusName) then
            valueToPath(data, path, focusName);
            oldFocusName = focusName;
            AceConfigDialog:Open("WeakAuras", frame.container);
          end
          oldFocus = focus;
        end
      end

      if not(focusName) then
        frameChooserBox:Hide();
      end
    end
  end);
end

function WeakAuras.StopFrameChooser(data)
  if(frameChooserFrame) then
    frameChooserFrame:SetScript("OnUpdate", nil);
    frameChooserBox:Hide();
  end
  ResetCursor();
  WeakAuras.Add(data);
  WeakAuras.ResetMoverSizer();
end

local Type, Version = "WeakAurasNewHeaderButton", 20
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local L = WeakAuras.L;

-- GLOBALS: GameTooltip UIParent WeakAuras WeakAurasOptionsSaved

local function Hide_Tooltip()
    GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
    GameTooltip:SetOwner(owner, "ANCHOR_NONE");
    GameTooltip:SetPoint("LEFT", owner, "RIGHT");
    GameTooltip:ClearLines();
    GameTooltip:AddLine(line1);
    GameTooltip:AddLine(line2, 1, 1, 1, 1);
    GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
    ["OnAcquire"] = function(self)
        self:SetWidth(1000);
        self:SetHeight(20);
    end,
    ["SetText"] = function(self, text)
        self.frame:SetText(" "..text);
    end,
    ["SetDescription"] = function(self, description)
        self.frame.description = description;
    end,
    ["SetClick"] = function(self, func)
        self.frame:SetScript("OnClick", func);
    end,
    ["Disable"] = function(self)
        self.frame:Disable();
    end,
    ["Enable"] = function(self)
        self.frame:Enable();
    end,
    ["Pick"] = function(self)
        self.frame:LockHighlight();
    end,
    ["ClearPick"] = function(self)
        self.frame:UnlockHighlight();
    end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
    local name = Type..AceGUI:GetNextWidgetNum(Type)
    local button = CreateFrame("BUTTON", name, UIParent, "OptionsListButtonTemplate");
    button:SetHeight(20);
    button:SetWidth(1000);
    button:SetDisabledFontObject("GameFontNormal");

    local background = button:CreateTexture(nil, "BACKGROUND");
    button.background = background;
    background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp");
    background:SetBlendMode("ADD");
    background:SetVertexColor(0.5, 0.5, 0.5, 0.25);
    background:SetAllPoints(button);

    button:SetScript("OnEnter", function() Show_Tooltip(button, button:GetText():sub(2), button.description or L["Add a new display"]) end);
    button:SetScript("OnLeave", Hide_Tooltip);

    local widget = {
        frame = button,
        type = Type
    }
    for method, func in pairs(methods) do
        widget[method] = func
    end

    return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

local Type, Version = "WeakAurasLoadedHeaderButton", 20
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local L = WeakAuras.L

-- GLOBALS: GameTooltip UIParent WeakAuras WeakAurasOptionsSaved

local function Hide_Tooltip()
  GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:SetPoint("LEFT", owner, "RIGHT");
  GameTooltip:ClearLines();
  GameTooltip:AddLine(line1);
  GameTooltip:AddLine(line2, 1, 1, 1, 1);
  GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(1000);
		self:SetHeight(20);
	end,
	["SetText"] = function(self, text)
		self.frame:SetText(" "..text);
	end,
  ["SetClick"] = function(self, func)
    self.frame:SetScript("OnClick", func);
  end,
  ["Disable"] = function(self)
    self.frame:Disable();
  end,
  ["Enable"] = function(self)
    self.frame:Enable();
  end,
  ["Pick"] = function(self)
    self.frame:LockHighlight();
  end,
  ["ClearPick"] = function(self)
    self.frame:UnlockHighlight();
  end,
  ["Expand"] = function(self, reloadTooltip)
    self.expand:Enable();
    self.expanded = true;
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-MinusButton-Up.blp");
    self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-MinusButton-Down.blp");
    self.expand.title = L["Collapse"];
    self.expand.desc = self.expand.collapsedesc;
    self.expand:SetScript("OnClick", function() self:Collapse(true) end);
    self.expand.func();
    if(reloadTooltip) then
      Hide_Tooltip();
      Show_Tooltip(self.frame, self.expand.title, self.expand.desc);
    end
  end,
  ["Collapse"] = function(self, reloadTooltip)
    self.expand:Enable();
    self.expanded = false;
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Up.blp");
    self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-PlusButton-Down.blp");
    self.expand.title = L["Expand"];
    self.expand.desc = self.expand.expanddesc;
    self.expand:SetScript("OnClick", function() self:Expand(true) end);
    self.expand.func();
    if(reloadTooltip) then
      Hide_Tooltip();
      Show_Tooltip(self.frame, self.expand.title, self.expand.desc);
    end
  end,
  ["SetOnExpandCollapse"] = function(self, func)
    self.expand.func = func;
  end,
  ["GetExpanded"] = function(self)
    return self.expanded;
  end,
  ["DisableExpand"] = function(self)
    self.expand:Disable();
    self.expand.disabled = true;
    self.expand.expanded = false;
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
  end,
  ["EnableExpand"] = function(self)
    self.expand.disabled = false;
    if(self:GetExpanded()) then
      self:Expand();
    else
      self:Collapse();
    end
  end,
  ["SetViewClick"] = function(self, func)
    self.view:SetScript("OnClick", func);
  end,
  ["SetViewTest"] = function(self, func)
    self.view.func = func;
  end,
  ["SetViewDescription"] = function(self, desc)
    self.view.desc = desc;
  end,
  ["SetExpandDescription"] = function(self, desc)
    self.expand.expanddesc = desc;
  end,
  ["SetCollapseDescription"] = function(self, desc)
    self.expand.collapsedesc = desc;
    self.expand.desc = desc;
  end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
  local name = Type..AceGUI:GetNextWidgetNum(Type)
	local button = CreateFrame("BUTTON", name, UIParent, "OptionsListButtonTemplate");
  button:SetHeight(20);
  button:SetWidth(1000);
  button:SetDisabledFontObject("GameFontNormal");

  local background = button:CreateTexture(nil, "BACKGROUND");
  button.background = background;
  background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp");
  background:SetBlendMode("ADD");
  background:SetVertexColor(0.5, 0.5, 0.5, 0.25);
  background:SetAllPoints(button);

  local expand = CreateFrame("BUTTON", nil, button);
  button.expand = expand;
  expand.expanded = true;
  expand.disabled = true;
  expand.func = function() end;
  expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
  expand:Disable();
  expand:SetWidth(16);
  expand:SetHeight(16);
  expand:SetPoint("RIGHT", button, "RIGHT");
  expand:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  expand.title = L["Disabled"];
  expand.desc = L["Expansion is disabled because this group has no children"];
  expand.expanddesc = "";
  expand.collapsedesc = "";
  expand:SetScript("OnEnter", function() Show_Tooltip(button, expand.title, expand.desc) end);
	expand:SetScript("OnLeave", Hide_Tooltip);

  local view = CreateFrame("BUTTON", nil, button);
  button.view = view;
  view:SetWidth(16);
  view:SetHeight(16);
  view:SetPoint("RIGHT", button, "RIGHT", -16, 0);
  local viewTexture = view:CreateTexture()
  view.texture = viewTexture;
  viewTexture:SetTexture("Interface\\LFGFrame\\BattlenetWorking1.blp");
  viewTexture:SetTexCoord(0.1, 0.9, 0.1, 0.9);
  viewTexture:SetAllPoints(view);
  view:SetNormalTexture(viewTexture);
  view:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  view.desc = "";
  view:SetScript("OnEnter", function() Show_Tooltip(button, L["View"], view.desc) end);
	view:SetScript("OnLeave", Hide_Tooltip);
  view.visibility = 0;
  view.func = function() return view.visibility end;
  view:SetScript("OnUpdate", function()
    if(view.func() == 2) then
      view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking0.blp");
    elseif(view.func() == 1) then
      view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking2.blp");
    else
      view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking4.blp");
    end
  end);

	local widget = {
		frame = button,
    expand = expand,
    view = view,
		type = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

local tinsert, tconcat, tremove, wipe = table.insert, table.concat, table.remove, wipe
local select, pairs, next, type, unpack = select, pairs, next, type, unpack
local tostring, error = tostring, error

local Type, Version = "WeakAurasDisplayButton", 27
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local L = WeakAuras.L;
local fullName;

-- GLOBALS: GameTooltip GetCursorPosition UIParent WeakAuras WeakAuras_DropDownMenu WeakAurasOptionsSaved

local function Hide_Tooltip()
    GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
    GameTooltip:SetOwner(owner, "ANCHOR_NONE");
    GameTooltip:SetPoint("LEFT", owner, "RIGHT");
    GameTooltip:ClearLines();
    GameTooltip:AddLine(line1);
    GameTooltip:AddLine(line2, 1, 1, 1, 1);
    GameTooltip:Show();
end

local function Show_Long_Tooltip(owner, description)
    GameTooltip:SetOwner(owner, "ANCHOR_NONE");
    GameTooltip:SetPoint("LEFT", owner, "RIGHT");
    GameTooltip:ClearLines();
    local line = 1;
    for i,v in pairs(description) do
        if(type(v) == "string") then
            if(line > 1) then
                GameTooltip:AddLine(v, 1, 1, 1, 1);
            else
                GameTooltip:AddLine(v);
            end
        elseif(type(v) == "table") then
            if(i == 1) then
                GameTooltip:AddDoubleLine(v[1], v[2]..(v[3] and (" |T"..v[3]..":12:12:0:0:64:64:4:60:4:60|t") or ""));
            else
                GameTooltip:AddDoubleLine(v[1], v[2]..(v[3] and (" |T"..v[3]..":12:12:0:0:64:64:4:60:4:60|t") or ""), 1, 1, 1, 1, 1, 1, 1, 1);
            end
        end
        line = line + 1;
    end
    GameTooltip:Show();
end

local function ensure(t, k, v)
    return t and k and v and t[k] == v
end

--[[     Actions     ]]--

local Actions = {
    -- move source into group or top-level list / optionally place it before or after target
    ["Group"] = function(source, groupId, target, before)
        if source and not source.data.parent then
            if groupId then
                local group = WeakAuras.GetDisplayButton(groupId)
                if group and group:IsGroup() then
                    local children = group.data.controlledChildren
                    if target then
                        local index = target:GetGroupOrder()
                        if ensure(children, index, target.data.id) then
                                -- account for insert position
                                index = before and index or index+1
                                tinsert(children, index, source.data.id)
                        else
                            error("Calling 'Group' with invalid target. Reload your UI to fix the display list.")
                        end
                    else
                        -- move source into group as the first child
                        tinsert(children, 1, source.data.id)
                    end
                    source:SetGroup(groupId)
                    source.data.parent = groupId
                    WeakAuras.Add(source.data)
                    WeakAuras.Add(group.data)
                    WeakAuras.UpdateGroupOrders(group.data)
                    WeakAuras.ReloadGroupRegionOptions(group.data)
                    WeakAuras.UpdateDisplayButton(group.data)
                    group.callbacks.UpdateExpandButton();
                    group:ReloadTooltip()
                else
                    error("Calling 'Group' with invalid groupId. Reload your UI to fix the display list.")
                end
            else
                -- move source into the top-level list
                WeakAuras.Add(source.data)
            end
        else
            error("Calling 'Group' with invalid source. Reload your UI to fix the display list.")
        end
    end,
    -- remove source from its group or top-level list
    ["Ungroup"] =  function(source)
        if source and source.data.parent then
            local parent = WeakAuras.GetData(source.data.parent)
            local children = parent.controlledChildren
            local index = source:GetGroupOrder()
            if ensure(children, index, source.data.id) then
                tremove(children, index)
                source:SetGroup()
                source.data.parent = nil
                WeakAuras.Add(parent);
                WeakAuras.UpdateGroupOrders(parent);
                WeakAuras.ReloadGroupRegionOptions(parent);
                WeakAuras.UpdateDisplayButton(parent);
            else
                error("Display thinks it is a member of a group which does not control it")
            end
        else
            error("Calling 'Ungroup' with invalid source. Reload your UI to fix the display list.")
        end
    end,
    -- move source inside its own group before or after target
    ["Move"] = function(source, target, before )
        if source and source.data.parent then
            local parent = WeakAuras.GetData(source.data.parent)
            local children = parent.controlledChildren
            local i = source:GetGroupOrder()
            if ensure(children, i, source.data.id) then
                if target and target.data.parent then
                    local j = target:GetGroupOrder()
                    if ensure(children, j, target.data.id) then
                        -- account for possible reorder
                        j = i < j and j-1 or j
                        -- account for insert position
                        j = before and j or j+1
                        tremove(children, i)
                        tinsert(children, j, source.data.id)
                    else
                        error("Calling 'Move' with invalid target. Reload your UI to fix the display list.")
                    end
                else
                    tremove(children, i)
                    tinsert(children, 1, source.data.id)
                end
                WeakAuras.Add(parent)
                WeakAuras.UpdateGroupOrders(parent)
                WeakAuras.UpdateDisplayButton(parent)
            else
                error("Calling 'Move' with invalid source. Reload your UI to fix the display list.")
            end
        else
            error("Calling 'Move' with invalid source. Reload your UI to fix the display list.")
        end
    end,
}

local Icons = {
    ["Group"] = "Interface\\GossipFrame\\TrainerGossipIcon",
    ["Ungroup"] = "Interface\\GossipFrame\\UnlearnGossipIcon",
    ["Move"] = nil
}

local function GetAction(target, area, source)
    if target and source and (area == "TOP" or area == "BOTTOM")then
        if target.data.parent and source.data.parent then
            if source.data.parent == target.data.parent then
                    return function(_source, _target)
                            Actions["Move"](_source, _target, area=="TOP")
                        end,
                        Icons["Move"]
                else
                    return function(_source, _target)
                            Actions["Ungroup"](_source)
                            Actions["Group"](_source, _target.data.parent, _target, area == "TOP")
                        end,
                        Icons["Group"]
                end
        elseif target.data.parent then -- and not source.data.parent
            return function(_source, _target)
                    Actions["Group"](_source, _target.data.parent, _target, area == "TOP")
                end,
                Icons["Group"]
        elseif source.data.parent then -- and not target.data.parent
            if area == "TOP" then
                return function(_source, _target)
                        Actions["Ungroup"](_source)
                        Actions["Group"](_source)
                    end,
                    Icons["Ungroup"]
            else -- area == "BOTTOM"
                if source.data.parent == target.data.id then
                    return Actions["Move"], Icons["Move"]
                else
                    return function(_source, _target)
                            Actions["Ungroup"](_source)
                            Actions["Group"](_source, _target.data.id)
                        end,
                        Icons["Group"]
                end
            end
        else -- not target.data.parent and not source.data.parent
            if target:IsGroup() and area == "BOTTOM" then
                return function(_source, _target)
                        Actions["Group"](_source, _target.data.id)
                    end,
                    Icons["Group"]
            else
                return nil
            end
        end
    end
end

-------------------------

local function GetDropTarget()
    local buttonList = WeakAuras.displayButtons
    local id, button, pos, offset
    repeat
        repeat
            id, button = next(buttonList, id)
        until not id or not button.dragging and button:IsEnabled() and button:IsShown()
        if id and button then
            offset = (button.frame.height or button.frame:GetHeight() or 16) / 2
            pos = button.frame:IsMouseOver(1,offset) and "TOP"
                or button.frame:IsMouseOver(-offset,-1) and "BOTTOM"
        end
    until not id or pos
    return id, button, pos
end

local function Show_DropIndicator(id)
    local indicator = WeakAuras.DropIndicator()
    local source = WeakAuras.GetDisplayButton(id)
    local target, pos
    if source then
        target, pos = select(2, GetDropTarget())
    end
    indicator:ClearAllPoints()
    local action, icon = GetAction(target, pos, source)
    if action then
        -- show line
        if pos == "TOP" then
            indicator:SetPoint("BOTTOMLEFT", target.frame, "TOPLEFT", 0, -1)
            indicator:SetPoint("BOTTOMRIGHT", target.frame, "TOPRIGHT", 0, -1)
            indicator:Show()
        elseif pos == "BOTTOM" then
            indicator:SetPoint("TOPLEFT", target.frame, "BOTTOMLEFT", 0, 1)
            indicator:SetPoint("TOPRIGHT", target.frame, "BOTTOMRIGHT", 0, 1)
            indicator:Show()
        else
            error("Invalid value pos '"..tostring(pos))
        end
        -- show icon
        if icon then
            if indicator.icon.texture ~= icon then
                indicator.icon.texture = icon
                indicator.icon:SetTexture(icon)
            end
           indicator.icon:Show()
        else
            indicator.icon:Hide()
        end
    else
        indicator:Hide()
    end
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
    ["OnAcquire"] = function(self)
        self:SetWidth(1000);
        self:SetHeight(32);
    end,
    ["Initialize"] = function(self)
        local data = self.data;
        self.callbacks = {};

        function self.callbacks.OnClickNormal(_, mouseButton)
            if(IsControlKeyDown() and not data.controlledChildren) then
                WeakAuras.PickDisplayMultiple(data.id);
                self:ReloadTooltip();
            elseif(IsShiftKeyDown()) then
                local editbox = GetCurrentKeyBoardFocus();
                if(editbox) then
                    if (not fullName) then
                      local name, realm = UnitFullName("player")
                      fullName = name.."-"..realm
                    end
                    editbox:Insert("[WeakAuras: "..fullName.." - "..data.id.."]");
                end
            else
                if(mouseButton == "RightButton") then
                    Hide_Tooltip();
                    if(WeakAuras.IsDisplayPicked(data.id) and WeakAuras.IsPickedMultiple()) then
                        EasyMenu(WeakAuras.MultipleDisplayTooltipMenu(), WeakAuras_DropDownMenu, self.frame, 0, 0, "MENU");
                    else
                        EasyMenu(self.menu, WeakAuras_DropDownMenu, self.frame, 0, 0, "MENU");
                        if not(WeakAuras.IsDisplayPicked(data.id)) then
                            WeakAuras.PickDisplay(data.id);
                        end
                    end
                else
                    WeakAuras.PickDisplay(data.id);
                    self:ReloadTooltip();
                end
            end
        end

        function self.callbacks.OnClickCopying()
            if (WeakAuras.IsImporting()) then return end;
            WeakAuras.Copy(data.id, self.copying.id);
            WeakAuras.ScanForLoads();
            WeakAuras.SetIconNames(self.copying);
            WeakAuras.SortDisplayButtons();
            WeakAuras.AddOption(self.copying.id, self.copying);
            WeakAuras.OptionsFrame():PickDisplay(self.copying.id);
            WeakAuras.UpdateDisplayButton(self.copying);
            WeakAuras.SetCopying();
            self:ReloadTooltip();
        end

        function self.callbacks.OnClickCopyingSelf()
            WeakAuras.SetCopying();
            self:ReloadTooltip();
        end

        function self.callbacks.UpdateExpandButton()
            if(#self.data.controlledChildren == 0) then
                self:DisableExpand();
            else
                self:EnableExpand();
            end
        end

        function self.callbacks.OnClickGrouping()
            if (WeakAuras.IsImporting()) then return end;
            tinsert(data.controlledChildren, self.grouping.id);
            local childButton = WeakAuras.GetDisplayButton(self.grouping.id);
            childButton:SetGroup(data.id, data.regionType == "dynamicgroup");
            childButton:SetGroupOrder(#data.controlledChildren, #data.controlledChildren);
            self.callbacks.UpdateExpandButton();
            self.grouping.parent = data.id;
            WeakAuras.Add(data);
            WeakAuras.Add(self.grouping);
            WeakAuras.SetGrouping();
            WeakAuras.UpdateDisplayButton(data);
            WeakAuras.ReloadGroupRegionOptions(data);
            WeakAuras.UpdateGroupOrders(data);
            WeakAuras.SortDisplayButtons();
            self:ReloadTooltip();
        end

        function self.callbacks.OnClickGroupingSelf()
            WeakAuras.SetGrouping();
            self:ReloadTooltip();
        end

        function self.callbacks.OnCopyClick()
            WeakAuras.PickDisplay(data.id);
            WeakAuras.SetCopying(data);
        end

        function self.callbacks.OnGroupClick()
            WeakAuras.PickDisplay(data.id);
            WeakAuras.SetGrouping(data);
        end

        function self.callbacks.OnDeleteClick()
            if (WeakAuras.IsImporting()) then return end;
            local parentData = data.parent and WeakAuras.GetData(data.parent);
            local parentButton = data.parent and WeakAuras.GetDisplayButton(data.parent);
            WeakAuras.DeleteOption(data);
            if(parentData) then
                WeakAuras.UpdateGroupOrders(parentData);
            end
            if(parentButton) then
                parentButton.callbacks.UpdateExpandButton();
            end
        end

        function self.callbacks.OnDuplicateClick()
            if (WeakAuras.IsImporting()) then return end;
            local base_id = data.id .. " ";
            local num = 2;

            -- if the old id ends with a number increment the number
            local matchName, matchNumber = string.match(data.id, "^(.-)(%d*)$")
            matchNumber = tonumber(matchNumber)
            if (matchName ~= "" and matchNumber ~= nil) then
                base_id = matchName;
                num = matchNumber + 1
            end

            local new_id = base_id .. num;
            while(WeakAuras.GetData(new_id)) do
                new_id = base_id .. num;
                num = num + 1;
            end

            local newData = {};
            WeakAuras.DeepCopy(data, newData);
            newData.id = new_id;
            newData.parent = nil;
            WeakAuras.Add(newData);
            WeakAuras.NewDisplayButton(newData);
            if(data.parent) then
                local parentData = WeakAuras.GetData(data.parent);
                local index;
                for i, childId in pairs(parentData.controlledChildren) do
                    if(childId == data.id) then
                        index = i;
                        break;
                    end
                end
                if(index) then
                    local newIndex = index + 1;
                    if(newIndex > #parentData.controlledChildren) then
                        tinsert(parentData.controlledChildren, newData.id);
                    else
                        tinsert(parentData.controlledChildren, index + 1, newData.id);
                    end
                    newData.parent = data.parent;
                    WeakAuras.Add(parentData);
                    WeakAuras.Add(newData);

                    for index, id in pairs(parentData.controlledChildren) do
                        local childButton = WeakAuras.GetDisplayButton(id);
                        childButton:SetGroup(parentData.id, parentData.regionType == "dynamicgroup");
                        childButton:SetGroupOrder(index, #parentData.controlledChildren);
                    end

                    local button = WeakAuras.GetDisplayButton(parentData.id);
                    button.callbacks.UpdateExpandButton();
                    WeakAuras.UpdateDisplayButton(parentData);
                    WeakAuras.ReloadGroupRegionOptions(parentData);
                end
            end
            WeakAuras.SortDisplayButtons();
            WeakAuras.DoConfigUpdate();
            WeakAuras.PickAndEditDisplay(new_id);
        end

        function self.callbacks.OnDeleteAllClick()
            if (WeakAuras.IsImporting()) then return end;
            if(data.controlledChildren) then

                local region = WeakAuras.regions[data.id];
                if (region.ControlChildren) then
                  region:Pause();
                end

                local toDelete = {};
                for index, id in pairs(data.controlledChildren) do
                    toDelete[index] = WeakAuras.GetData(id);
                end
                for index, childData in pairs(toDelete) do
                    WeakAuras.DeleteOption(childData);
                end
            end
            WeakAuras.DeleteOption(data);
        end

        function self.callbacks.OnUngroupClick()
            if (WeakAuras.IsImporting()) then return end;
            local parentData = WeakAuras.GetData(data.parent);
            local index;
            for childIndex, childId in pairs(parentData.controlledChildren) do
                if(childId == data.id) then
                    index = childIndex;
                    break;
                end
            end
            if(index) then
                tremove(parentData.controlledChildren, index);
                WeakAuras.Add(parentData);
                WeakAuras.ReloadGroupRegionOptions(parentData);
            else
                error("Display thinks it is a member of a group which does not control it");
            end
            self:SetGroup();
            data.parent = nil;
            WeakAuras.Add(data);
            WeakAuras.UpdateGroupOrders(parentData);
            WeakAuras.UpdateDisplayButton(parentData);
            WeakAuras.SortDisplayButtons();
        end

        function self.callbacks.OnUpGroupClick()
            if (WeakAuras.IsImporting()) then return end;
            if(data.parent) then
                local id = data.id;
                local parentData = WeakAuras.GetData(data.parent);
                local index;
                for childIndex, childId in pairs(parentData.controlledChildren) do
                    if(childId == id) then
                        index = childIndex;
                        break;
                    end
                end
                if(index) then
                    if(index <= 1) then
                        error("Attempt to move up the first element in a group");
                    else
                        tremove(parentData.controlledChildren, index);
                        tinsert(parentData.controlledChildren, index - 1, id);
                        WeakAuras.Add(parentData);
                        self:SetGroupOrder(index - 1, #parentData.controlledChildren);
                        local otherbutton = WeakAuras.GetDisplayButton(parentData.controlledChildren[index]);
                        otherbutton:SetGroupOrder(index, #parentData.controlledChildren);
                        WeakAuras.SortDisplayButtons();
                        local updata = {duration = 0.15, type = "custom", use_translate = true, x = 0, y = -32};
                        local downdata = {duration = 0.15, type = "custom", use_translate = true, x = 0, y = 32};
                        WeakAuras.Animate("button", parentData.controlledChildren[index-1], "main", updata, self.frame, true, function() WeakAuras.SortDisplayButtons() end);
                        WeakAuras.Animate("button", parentData.controlledChildren[index], "main", downdata, otherbutton.frame, true, function() WeakAuras.SortDisplayButtons() end);
                        WeakAuras.UpdateDisplayButton(parentData);
                    end
                else
                    error("Display thinks it is a member of a group which does not control it");
                end
            else
                error("This display is not in a group. You should not have been able to click this button");
            end
        end

        function self.callbacks.OnDownGroupClick()
            if (WeakAuras.IsImporting()) then return end;
            if(data.parent) then
                local id = data.id;
                local parentData = WeakAuras.GetData(data.parent);
                local index;
                for childIndex, childId in pairs(parentData.controlledChildren) do
                    if(childId == id) then
                        index = childIndex;
                        break;
                    end
                end
                if(index) then
                    if(index >= #parentData.controlledChildren) then
                        error("Attempt to move down the last element in a group");
                    else
                        tremove(parentData.controlledChildren, index);
                        tinsert(parentData.controlledChildren, index + 1, id);
                        WeakAuras.Add(parentData);
                        self:SetGroupOrder(index + 1, #parentData.controlledChildren);
                        local otherbutton = WeakAuras.GetDisplayButton(parentData.controlledChildren[index]);
                        otherbutton:SetGroupOrder(index, #parentData.controlledChildren);
                        WeakAuras.SortDisplayButtons()
                        local updata = {duration = 0.15, type = "custom", use_translate = true, x = 0, y = -32};
                        local downdata = {duration = 0.15, type = "custom", use_translate = true, x = 0, y = 32};
                        WeakAuras.Animate("button", parentData.controlledChildren[index+1], "main", downdata, self.frame, true, function() WeakAuras.SortDisplayButtons() end);
                        WeakAuras.Animate("button", parentData.controlledChildren[index], "main", updata, otherbutton.frame, true, function() WeakAuras.SortDisplayButtons() end);
                        WeakAuras.UpdateDisplayButton(parentData);
                    end
                else
                    error("Display thinks it is a member of a group which does not control it");
                end
            else
                error("This display is not in a group. You should not have been able to click this button");
            end
        end

        function self.callbacks.OnViewClick()
            WeakAuras.PauseAllDynamicGroups();

            if(self.view.func() == 2) then
                for index, childId in ipairs(data.controlledChildren) do
                    WeakAuras.GetDisplayButton(childId):PriorityHide(2);
                end
            else
                for index, childId in ipairs(data.controlledChildren) do
                    WeakAuras.GetDisplayButton(childId):PriorityShow(2);
                end
            end

            WeakAuras.ResumeAllDynamicGroups();
        end

        function self.callbacks.ViewTest()
            local none, all = true, true;
            for index, childId in ipairs(data.controlledChildren) do
                local childButton = WeakAuras.GetDisplayButton(childId);
                if(childButton) then
                    if(childButton:GetVisibility() ~= 2) then
                        all = false;
                    end
                    if(childButton:GetVisibility() ~= 0) then
                        none = false;
                    end
                end
            end
            if(all) then
                return 2;
            elseif(none) then
                return 0;
            else
                return 1;
            end
        end

        function self.callbacks.OnRenameClick()
            if (WeakAuras.IsImporting()) then return end;
            if(self.title:IsVisible()) then
                self.title:Hide();
                self.renamebox:SetText(self.title:GetText());
                self.renamebox:Show();
            else
                self.title:Show();
                self.renamebox:Hide();
            end
        end

        function self.callbacks.OnRenameAction(newid)
            if (WeakAuras.IsImporting()) then return end;
            local oldid = data.id;
            if not(newid == oldid) then
                local temp;

                WeakAuras.Rename(data, newid);

                WeakAuras.thumbnails[newid] = WeakAuras.thumbnails[oldid];
                WeakAuras.thumbnails[oldid] = nil;
                WeakAuras.displayButtons[newid] = WeakAuras.displayButtons[oldid];
                WeakAuras.displayButtons[oldid] = nil;
                WeakAuras.displayOptions[oldid] = nil;
                WeakAuras.AddOption(newid, data);

                WeakAuras.displayButtons[newid]:SetTitle(newid);

                if(data.controlledChildren) then
                    for index, childId in pairs(data.controlledChildren) do
                        WeakAuras.displayButtons[childId]:SetGroup(newid);
                    end
                end

                WeakAuras.SetCopying();
                WeakAuras.SetGrouping();
                WeakAuras.SortDisplayButtons();
                WeakAuras.PickDisplay(newid);
            end
        end

        function self.callbacks.OnDragStart()
            if WeakAuras.IsImporting() or self:IsGroup() then return end;
            WeakAuras.PickDisplay(data.id)
            WeakAuras.SetDragging(data)
        end

        function self.callbacks.OnDragStop()
            if not self.dragging then return end
            WeakAuras.SetDragging(data, true)
        end

        self.frame.terribleCodeOrganizationHackTable = {};

        function self.frame.terribleCodeOrganizationHackTable.IsGroupingOrCopying()
            return self.grouping or self.copying;
        end

        function self.frame.terribleCodeOrganizationHackTable.SetNormalTooltip()
            self:SetNormalTooltip();
        end

        function self.frame.terribleCodeOrganizationHackTable.OnShow()
            WeakAuras.UpdateCloneConfig(data);
        end

        function self.frame.terribleCodeOrganizationHackTable.OnHide()
            WeakAuras.CollapseAllClones(data.id);
        end

        self:SetTitle(data.id);
        self.menu = {
            {
                text = L["Rename"],
                notCheckable = 1,
                func = self.callbacks.OnRenameClick
            },
            {
                text = L["Copy settings from..."],
                notCheckable = 1,
                func = self.callbacks.OnCopyClick
            },
            {
                text = L["Set tooltip description"],
                notCheckable = 1,
                func = function() WeakAuras.ShowDisplayTooltip(data, nil, nil, nil, nil, nil, true) end
            },
            {
                text = L["Export to string..."],
                notCheckable = 1,
                func = function() WeakAuras.ExportToString(data.id) end
            },
            {
                text = L["Export to Lua table..."],
                notCheckable = 1,
                func = function() WeakAuras.ExportToTable(data.id) end
            },
            {
                text = " ",
                notClickable = 1,
                notCheckable = 1,
            },
            {
                text = L["Delete"],
                notCheckable = 1,
                func = self.callbacks.OnDeleteClick
            },
            {
                text = " ",
                notClickable = 1,
                notCheckable = 1,
            },
            {
                text = L["Close"],
                notCheckable = 1,
                func = function() WeakAuras_DropDownMenu:Hide() end
            }
        }
        if(data.controlledChildren) then
            tinsert(self.menu, 8, {
                text = L["Delete children and group"],
                notCheckable = 1,
                func = self.callbacks.OnDeleteAllClick
            });
            self:SetViewClick(self.callbacks.OnViewClick);
            self:SetViewTest(self.callbacks.ViewTest);
            self:DisableGroup();
            self.callbacks.UpdateExpandButton();
            self:SetOnExpandCollapse(function() WeakAuras.SortDisplayButtons(nil, true) end);
        else
            local convertMenu = {};
            for regionType, regionData in pairs(WeakAuras.regionOptions) do
                if(regionType ~= "group" and regionType ~= "dynamicgroup" and regionType ~= "timer" and regionType ~= data.regionType) then
                    tinsert(convertMenu, {
                        text = regionData.displayName,
                        notCheckable = 1,
                        func = function()
                            WeakAuras.ConvertDisplay(data, regionType);
                            WeakAuras_DropDownMenu:Hide();
                        end
                    });
                end
            end
            tinsert(self.menu, 3, {
                text = L["Convert to..."],
                notCheckable = 1,
                hasArrow = true,
                menuList = convertMenu
            });
            tinsert(self.menu, 4, {
                text = L["Duplicate"],
                notCheckable = 1,
                func = self.callbacks.OnDuplicateClick
            });
            self:SetViewRegion(WeakAuras.regions[data.id].region);
            self:EnableGroup();
        end
        self:SetNormalTooltip();
        self.frame:SetScript("OnClick", self.callbacks.OnClickNormal);
        self.frame:SetMovable(true);
        self.frame:RegisterForDrag("LeftButton");
        self.frame:SetScript("OnDragStart", self.callbacks.OnDragStart);
        self.frame:SetScript("OnDragStop", self.callbacks.OnDragStop);

        self:Enable();
        self:SetRenameAction(self.callbacks.OnRenameAction);
        self.group:SetScript("OnClick", self.callbacks.OnGroupClick);
        self.ungroup:SetScript("OnClick", self.callbacks.OnUngroupClick);
        self.upgroup:SetScript("OnClick", self.callbacks.OnUpGroupClick);
        self.downgroup:SetScript("OnClick", self.callbacks.OnDownGroupClick);
        if(data.parent) then
            local parentData = WeakAuras.GetData(data.parent);
            local index;
            for childIndex, childId in pairs(parentData.controlledChildren) do
                if(childId == data.id) then
                    index = childIndex;
                    break;
                end
            end
            if(index) then
                self:SetGroup(data.parent);
                self:SetGroupOrder(index, #parentData.controlledChildren);
            else
                error("Display \""..data.id.."\" thinks it is a member of group \""..data.parent.."\" which does not control it");
            end
        end
    end,
    ["SetNormalTooltip"] = function(self)
        local data = self.data;
        local namestable = {};
        if(data.controlledChildren) then
            for index, childId in pairs(data.controlledChildren) do
                tinsert(namestable, {" ", childId});
            end
            if(#namestable > 0) then
                namestable[1][1] = L["Children:"];
            else
                namestable[1] = L["No Children"];
            end
        else
            for triggernum = 0, data.numTriggers or 9 do
                local trigger;
                if(triggernum == 0) then
                    trigger = data.trigger;
                elseif(data.additional_triggers and data.additional_triggers[triggernum]) then
                    trigger = data.additional_triggers[triggernum].trigger;
                end
                if(trigger) then
                    if(trigger.type == "aura") then
                        if(trigger.fullscan) then
                            tinsert(namestable, {L["Aura:"], L["Full Scan"]});
                        else
                            for index, name in pairs(trigger.names) do
                                local left = " ";
                                if(index == 1) then
                                    if(#trigger.names > 0) then
                                        if(#trigger.names > 1) then
                                            left = L["Auras:"];
                                        else
                                            left = L["Aura:"];
                                        end
                                    end
                                end
                                local icon = WeakAuras.spellCache.GetIcon(name) or "Interface\\Icons\\INV_Misc_QuestionMark";
                                tinsert(namestable, {left, name, icon});
                            end
                        end
                    elseif(trigger.type == "event" or trigger.type == "status") then
                        if(trigger.type == "event") then
                            tinsert(namestable, {L["Trigger:"], (WeakAuras.event_types[trigger.event] or L["Undefined"])});
                        else
                            tinsert(namestable, {L["Trigger:"], (WeakAuras.status_types[trigger.event] or L["Undefined"])});
                        end
                        if(trigger.event == "Combat Log" and trigger.subeventPrefix and trigger.subeventSuffix) then
                            tinsert(namestable, {L["Message type:"], (WeakAuras.subevent_prefix_types[trigger.subeventPrefix] or L["Undefined"]).." "..(WeakAuras.subevent_suffix_types[trigger.subeventSuffix] or L["Undefined"])});
                        end
                    else
                        tinsert(namestable, {L["Trigger:"], L["Custom"]});
                    end
                end
            end
        end
        if(WeakAuras.CanHaveClones(data)) then
            tinsert(namestable, {" ", "|cFF00FF00"..L["Auto-cloning enabled"]})
        end
        if(WeakAuras.IsDefinedByAddon(data.id)) then
            tinsert(namestable, " ");
            tinsert(namestable, {" ", "|cFF00FFFF"..L["Addon"]..": "..WeakAuras.IsDefinedByAddon(data.id)});
        end
        if(data.desc and data.desc ~= "") then
            tinsert(namestable, " ");
            tinsert(namestable, "|cFFFFD100\""..data.desc.."\"");
        end
        tinsert(namestable, " ");
        tinsert(namestable, {" ", "|cFF00FFFF"..L["Right-click for more options"]});
        if not(data.controlledChildren) then
            tinsert(namestable, {" ", "|cFF00FFFF"..L["Drag to move"]});
            tinsert(namestable, {" ", "|cFF00FFFF"..L["Control-click to select multiple displays"]});
        end
        tinsert(namestable, {" ", "|cFF00FFFF"..L["Shift-click to create chat link"]});
        local regionData = WeakAuras.regionOptions[data.regionType or ""]
        local displayName = regionData and regionData.displayName or "";
        self:SetDescription({data.id, displayName}, unpack(namestable));
    end,
    ["ReloadTooltip"] = function(self)if(
        WeakAuras.IsPickedMultiple() and WeakAuras.IsDisplayPicked(self.data.id)) then
            Show_Long_Tooltip(self.frame, WeakAuras.MultipleDisplayTooltipDesc());
        else
            Show_Long_Tooltip(self.frame, self.frame.description);
        end
    end,
    ["SetCopying"] = function(self, copyingData)
        self.copying = copyingData;
        if(self.copying) then
            if(self.data.id == self.copying.id) then
                self:SetDescription(L["Cancel"], L["Do not copy any settings"]);
                self.frame:SetScript("OnClick", self.callbacks.OnClickCopyingSelf);
            else
                if(self.data.regionType == self.copying.regionType) then
                    self:SetDescription(self.data.id, L["Copy settings from %s"]:format(self.data.id));
                    self.frame:SetScript("OnClick", self.callbacks.OnClickCopying);
                else
                    self:Disable();
                end
            end
        else
            self:SetNormalTooltip();
            self.frame:SetScript("OnClick", self.callbacks.OnClickNormal);
            self:Enable();
        end
    end,
    ["SetGrouping"] = function(self, groupingData)
        self.grouping = groupingData;
        if(self.grouping) then
            if(self.data.id == self.grouping.id) then
                self.frame:SetScript("OnClick", self.callbacks.OnClickGroupingSelf);
                self:SetDescription(L["Cancel"], L["Do not group this display"]);
            else
                if(self.data.regionType == "group" or self.data.regionType == "dynamicgroup") then
                    self.frame:SetScript("OnClick", self.callbacks.OnClickGrouping);
                    self:SetDescription(self.data.id, L["Add to group %s"]:format(self.data.id));
                else
                    self:Disable();
                end
            end
        else
            self:SetNormalTooltip();
            self.frame:SetScript("OnClick", self.callbacks.OnClickNormal);
            self:Enable();
        end
    end,
    ["SetDragging"] = function(self, data, drop)
        if data then
            -- self
            if self.data.id == data.id then
                if drop then
                    self:Drop()
                    self.frame:SetScript("OnClick", self.callbacks.OnClickNormal)
                else
                    Hide_Tooltip()
                    self.frame:SetScript("OnClick", nil)
                    self:Drag()
                end
            -- invalid targets
            elseif not self.data.parent and not self:IsGroup()
            then
                if drop then
                    self:Enable()
                else
                    self:Disable()
                end
            -- valid target
            else
                if drop then
                    self.frame:SetScript("OnClick", self.callbacks.OnClickNormal)
                else
                    self.frame:SetScript("OnClick", nil)
                end
            end
        else
            -- restore events and layout
            self.frame:SetScript("OnClick", self.callbacks.OnClickNormal)
            self:Enable()
            if (self.dragging) then
              self:Drop(true)
            end
        end
    end,
    ["ShowTooltip"] = function(self)
    end,
    ["Drag"] = function(self)
        local uiscale, _, y = UIParent:GetScale(), GetCursorPosition()
        local scale, x, w = self.frame:GetEffectiveScale(), self.frame:GetLeft(), self.frame:GetWidth()
        -- hide "visual clutter"
        self.downgroup:Hide()
        self.group:Hide()
        self.loaded:Hide()
        self.ungroup:Hide()
        self.upgroup:Hide()
        self.view:Hide()
        -- mark as being dragged, attach to mouse and raise frame strata
        self.dragging = true
        self.frame:StartMoving()
        self.frame:ClearAllPoints()
        self.frame.temp = {
            parent = self.frame:GetParent(),
            strata = self.frame:GetFrameStrata(),
        }
        self.frame:SetParent(UIParent)
        self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
        self.frame:SetPoint("Center", UIParent, "BOTTOMLEFT", (x+w/2)*scale/uiscale, y/uiscale)
        -- attach OnUpdate event to update drop indicator
        local id = self.data.id
        self.frame:SetScript("OnUpdate", function(self,elapsed)
            self.elapsed = (self.elapsed or 0) + elapsed
            if self.elapsed > 0.1 then
                Show_DropIndicator(id)
                self.elapsed = 0
            end
        end)
        Show_DropIndicator(id)
        WeakAuras.UpdateButtonsScroll()
    end,
    ["Drop"] = function(self, reset)
        self.frame:StopMovingOrSizing()
        self.frame:SetScript("OnUpdate", nil)
        if self.dragging then
            self.frame:SetParent(self.frame.temp.parent)
            self.frame:SetFrameStrata(self.frame.temp.strata)
            self.frame.tmp = nil
            if self.data.parent then
                self.downgroup:Show()
                self.ungroup:Show()
                self.upgroup:Show()
            else
                self.group:Show()
            end
            self.loaded:Show()
            self.view:Show()
        end
        Show_DropIndicator()
        local target, area = select(2, GetDropTarget())
        self.dragging = false
        -- exit if we have no target or only want to reset
        if reset or not target then return WeakAuras.UpdateButtonsScroll() end
        -- get action and execute it
        local action = GetAction(target, area, self)
        if action then
            action(self,target)
        end
        WeakAuras.SortDisplayButtons()
    end,
    ["GetGroupOrCopying"] = function(self)
        return self.group or self.copying;
    end,
    ["SetTitle"] = function(self, title)
        self.titletext = title;
        self.title:SetText(title);
    end,
    ["GetTitle"] = function(self)
        return self.titletext;
    end,
    ["SetDescription"] = function(self, ...)
        self.frame.description = {...};
    end,
    ["SetIcon"] = function(self, icon)
        if(type(icon) == "string" or type(icon) == "number") then
            self.icon:SetTexture(icon);
            self.icon:Show();
            if(self.iconRegion and self.iconRegion.Hide) then
                self.iconRegion:Hide();
            end
        else
            self.iconRegion = icon;
            icon:SetAllPoints(self.icon);
            icon:SetParent(self.frame);
            self.icon:Hide();
        end
    end,
    ["SetViewRegion"] = function(self, region)
        self.view.region = region;
        self.view.func = function() return self.view.visibility end;
        self.view:SetScript("OnClick", function()
            if(self.view.visibility < 2) then
                self.view:PriorityShow(2);
            else
                self.view:PriorityHide(2);
            end
        end);
    end,
    ["SetViewClick"] = function(self, func)
        self.view:SetScript("OnClick", func);
    end,
    ["SetViewTest"] = function(self, func)
        self.view.func = func;
    end,
    ["SetRenameAction"] = function(self, func)
        self.renamebox.func = function()
            func(self.renamebox:GetText());
        end
    end,
    ["DisableGroup"] = function(self)
        self.group:Hide();
        self.loaded:Hide();
        self.expand:Show();
    end,
    ["EnableGroup"] = function(self)
        self.group:Show();
        self.loaded:Show();
        self.expand:Hide();
    end,
    ["SetIds"] = function(self, ids)
        self.renamebox.ids = ids;
    end,
    ["SetGroup"] = function(self, group)
        self.frame.dgroup = group;
        if(group) then
            self.icon:SetPoint("LEFT", self.ungroup, "RIGHT");
            self.background:SetPoint("LEFT", self.ungroup, "RIGHT");
            self.ungroup:Show();
            self.group:Hide();
            self.upgroup:Show();
            self.downgroup:Show();
        else
            self.icon:SetPoint("LEFT", self.frame, "LEFT");
            self.background:SetPoint("LEFT", self.frame, "LEFT");
            self.ungroup:Hide();
            self.group:Show();
            self.upgroup:Hide();
            self.downgroup:Hide();
        end
    end,
    ["GetGroup"] = function(self)
        return self.frame.dgroup;
    end,
    ["IsGroup"] = function(self)
        return self.data.regionType == "group" or self.data.regionType == "dynamicgroup"
    end,
    ["SetData"] = function(self, data)
        self.data = data;
        self.frame.id = data.id;
    end,
    ["GetData"] = function(self)
        return self.data;
    end,
    ["Expand"] = function(self, reloadTooltip)
        self.expand:Enable();
        self.data.expanded = true;
        self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-MinusButton-Up.blp");
        self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-MinusButton-Down.blp");
        self.expand.title = L["Collapse"];
        self.expand.desc = L["Hide this group's children"];
        self.expand:SetScript("OnClick", function() self:Collapse(true) end);
        self.expand.func();
        if(reloadTooltip) then
            Hide_Tooltip();
            Show_Tooltip(self.frame, self.expand.title, self.expand.desc);
        end
    end,
    ["Collapse"] = function(self, reloadTooltip)
        self.expand:Enable();
        self.data.expanded = false;
        self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Up.blp");
        self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-PlusButton-Down.blp");
        self.expand.title = L["Expand"];
        self.expand.desc = L["Show this group's children"];
        self.expand:SetScript("OnClick", function() self:Expand(true) end);
        self.expand.func();
        if(reloadTooltip) then
            Hide_Tooltip();
            Show_Tooltip(self.frame, self.expand.title, self.expand.desc);
        end
    end,
    ["SetOnExpandCollapse"] = function(self, func)
        self.expand.func = func;
    end,
    ["GetExpanded"] = function(self)
        return self.data.expanded;
    end,
    ["DisableExpand"] = function(self)
        self.expand:Disable();
        self.expand.disabled = true;
        self.expand.expanded = false;
        self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
    end,
    ["EnableExpand"] = function(self)
        self.expand.disabled = false;
        if(self:GetExpanded()) then
            self:Expand();
        else
            self:Collapse();
        end
    end,
    ["SetGroupOrder"] = function(self, order, max)
        if(order == 1) then
            self:DisableUpGroup();
        else
            self:EnableUpGroup();
        end
        if(order == max) then
            self:DisableDownGroup();
        else
            self:EnableDownGroup();
        end
        self.frame.dgrouporder = order;
    end,
    ["GetGroupOrder"] = function(self)
        return self.frame.dgrouporder;
    end,
    ["DisableUpGroup"] = function(self)
        self.upgroup:Disable();
        self.upgroup.texture:SetVertexColor(0.3, 0.3, 0.3);
    end,
    ["EnableUpGroup"] = function(self)
        self.upgroup:Enable();
        self.upgroup.texture:SetVertexColor(1, 1, 1);
    end,
    ["DisableDownGroup"] = function(self)
        self.downgroup:Disable();
        self.downgroup.texture:SetVertexColor(0.3, 0.3, 0.3);
    end,
    ["EnableDownGroup"] = function(self)
        self.downgroup:Enable();
        self.downgroup.texture:SetVertexColor(1, 1, 1);
    end,
    ["DisableLoaded"] = function(self)
        self.loaded.title = "Not Loaded";
        self.loaded.desc = L["This display is not currently loaded"];
        self.loaded:SetNormalTexture("Interface\\BUTTONS\\UI-GuildButton-OfficerNote-Disabled.blp");
    end,
    ["EnableLoaded"] = function(self)
        self.loaded.title = "Loaded";
        self.loaded.desc = L["This display is currently loaded"];
        self.loaded:SetNormalTexture("Interface\\BUTTONS\\UI-GuildButton-OfficerNote-Up.blp");
    end,
    ["Pick"] = function(self)
        self.frame:LockHighlight();
        self.view:PriorityShow(1);
    end,
    ["ClearPick"] = function(self)
        self.frame:UnlockHighlight();
        self.view:PriorityHide(1);
    end,
    ["PriorityShow"] = function(self, priority)
        self.view:PriorityShow(priority);
    end,
    ["PriorityHide"] = function(self, priority)
        self.view:PriorityHide(priority);
    end,
    ["GetVisibility"] = function(self)
        return self.view.visibility;
    end,
    ["Disable"] = function(self)
        self.background:Hide();
        self.frame:Disable();
        self.view:Disable();
        self.group:Disable();
        self.ungroup:Disable();
        self.upgroup:Disable();
        self.downgroup:Disable();
        self.loaded:Disable();
        self.expand:Disable();
    end,
    ["Enable"] = function(self)
        self.background:Show();
        self.frame:Enable();
        self.view:Enable();
        self.group:Enable();
        self.ungroup:Enable();
        self.upgroup:Enable();
        self.downgroup:Enable();
        self.loaded:Enable();
        if not(self.expand.disabled) then
            self.expand:Enable();
        end
    end,
    ["IsEnabled"] = function(self)
        return self.frame:IsEnabled();
    end,
    ["OnRelease"] = function(self)
        self:SetViewRegion();
        self:Enable();
        self:SetGroup();
        self:EnableGroup();
        self.renamebox:Hide();
        self.title:Show();
        local id = self.data.id;
        self.frame:SetScript("OnEnter", nil);
        self.frame:SetScript("OnLeave", nil);
        self.frame:SetScript("OnClick", nil);
        self.frame:SetScript("OnDragStart", nil);
        self.frame:SetScript("OnDragStop", nil);
        --self.frame:EnableMouse(false);
        self.frame:ClearAllPoints();
        self.frame:Hide();
        self.frame = nil;
        self.data = nil;
    end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
    local name = "WeakAurasDisplayButton"..AceGUI:GetNextWidgetNum(Type);
    local button = CreateFrame("BUTTON", name, UIParent, "OptionsListButtonTemplate");
    button:SetHeight(32);
    button:SetWidth(1000);
    button.dgroup = nil;
    button.data = {};

    local background = button:CreateTexture(nil, "BACKGROUND");
    button.background = background;
    background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp");
    background:SetBlendMode("ADD");
    background:SetVertexColor(0.5, 0.5, 0.5, 0.25);
    background:SetPoint("TOP", button, "TOP");
    background:SetPoint("BOTTOM", button, "BOTTOM");
    background:SetPoint("LEFT", button, "LEFT");
    background:SetPoint("RIGHT", button, "RIGHT");

    local icon = button:CreateTexture(nil, "OVERLAY");
    button.icon = icon;
    icon:SetWidth(32);
    icon:SetHeight(32);
    icon:SetPoint("LEFT", button, "LEFT");

    local title = button:CreateFontString(nil, "OVERLAY", "GameFontNormal");
    button.title = title;
    title:SetHeight(14);
    title:SetJustifyH("LEFT");
    title:SetPoint("TOP", button, "TOP", 0, -2);
    title:SetPoint("LEFT", icon, "RIGHT", 2, 0);
    title:SetPoint("RIGHT", button, "RIGHT");

    button.description = {};

    button:SetScript("OnEnter", function()
        if(WeakAuras.IsPickedMultiple() and WeakAuras.IsDisplayPicked(button.id)) then
            Show_Long_Tooltip(button, WeakAuras.MultipleDisplayTooltipDesc());
        else
            if not(button.terribleCodeOrganizationHackTable.IsGroupingOrCopying()) then
                button.terribleCodeOrganizationHackTable.SetNormalTooltip();
            end
            Show_Long_Tooltip(button, button.description);
        end
    end);
    button:SetScript("OnLeave", Hide_Tooltip);

    local view = CreateFrame("BUTTON", nil, button);
    button.view = view;
    view:SetWidth(16);
    view:SetHeight(16);
    view:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", -2, 0);
    local viewTexture = view:CreateTexture()
    view.texture = viewTexture;
    viewTexture:SetTexture("Interface\\LFGFrame\\BattlenetWorking1.blp");
    viewTexture:SetTexCoord(0.1, 0.9, 0.1, 0.9);
    viewTexture:SetAllPoints(view);
    view:SetNormalTexture(viewTexture);
    view:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
    view:SetScript("OnEnter", function() Show_Tooltip(button, L["View"], L["Toggle the visibility of this display"]) end);
    view:SetScript("OnLeave", Hide_Tooltip);
    view.visibility = 0;
    view.PriorityShow = function(self, priority)
        if(priority >= self.visibility) then
            self.visibility = priority;
            if(self.region and self.region.Expand) then
                button.terribleCodeOrganizationHackTable.OnShow();
                self.region:Expand();
                if (WeakAuras.personalRessourceDisplayFrame) then
                  WeakAuras.personalRessourceDisplayFrame:expand(self.region.id);
                end
                if (WeakAuras.mouseFrame) then
                  WeakAuras.mouseFrame:expand(self.region.id);
                end
            end
        end
    end
    view.PriorityHide = function(self, priority)
        if(priority >= self.visibility) then
            self.visibility = 0;
            if(self.region and self.region.Collapse) then
                button.terribleCodeOrganizationHackTable.OnHide();
                self.region:Collapse();
                if (WeakAuras.personalRessourceDisplayFrame) then
                  WeakAuras.personalRessourceDisplayFrame:collapse(self.region.id);
                end
                if (WeakAuras.mouseFrame) then
                  WeakAuras.mouseFrame:collapse(self.region.id);
                end
            end
        end
    end
    view.func = function() return view.visibility end;
    view:SetScript("OnUpdate", function()
        if(view.func() == 2) then
            view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking0.blp");
        elseif(view.func() == 1) then
            view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking2.blp");
        else
            view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking4.blp");
        end
    end);

    local loaded = CreateFrame("BUTTON", nil, button);
    button.loaded = loaded;
    loaded:SetWidth(16);
    loaded:SetHeight(16);
    loaded:SetPoint("BOTTOM", button, "BOTTOM");
    loaded:SetPoint("LEFT", icon, "RIGHT", 0, 0);
    loaded:SetNormalTexture("Interface\\BUTTONS\\UI-GuildButton-OfficerNote-Up.blp");
    loaded:SetDisabledTexture("Interface\\BUTTONS\\UI-GuildButton-OfficerNote-Disabled.blp");
    --loaded:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
    loaded.title = L["Loaded"];
    loaded.desc = L["This display is currently loaded"];
    loaded:SetScript("OnEnter", function() Show_Tooltip(button, loaded.title, loaded.desc) end);
    loaded:SetScript("OnLeave", Hide_Tooltip);

    local renamebox = CreateFrame("EDITBOX", nil, button, "InputBoxTemplate");
    renamebox:SetHeight(14);
    renamebox:SetPoint("TOP", button, "TOP");
    renamebox:SetPoint("LEFT", icon, "RIGHT", 6, 0);
    renamebox:SetPoint("RIGHT", button, "RIGHT", -4, 0);
    renamebox:SetFont("Fonts\\FRIZQT__.TTF", 10);
    renamebox:Hide();

    renamebox.func = function() --[[By default, do nothing!]] end;
    renamebox:SetScript("OnEnterPressed", function()
        local oldid = button.title:GetText();
        local newid = renamebox:GetText();
        if(newid == "" or (newid ~= oldid and WeakAuras.GetData(newid))) then
            renamebox:SetText(button.title:GetText());
        else
            renamebox.func();
            title:SetText(renamebox:GetText());
            title:Show();
            renamebox:Hide();
        end
    end);

    renamebox:SetScript("OnEscapePressed", function()
        title:Show();
        renamebox:Hide();
    end);

    local group = CreateFrame("BUTTON", nil, button);
    button.group = group;
    group:SetWidth(16);
    group:SetHeight(16);
    group:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", -18, 0);
    local grouptexture = group:CreateTexture(nil, "OVERLAY");
    group.texture = grouptexture;
    grouptexture:SetTexture("Interface\\GLUES\\CharacterCreate\\UI-RotationRight-Big-Up.blp");
    grouptexture:SetTexCoord(0.15, 0.85, 0.15, 0.85);
    grouptexture:SetAllPoints(group);
    group:SetNormalTexture(grouptexture);
    group:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
    group:SetScript("OnEnter", function() Show_Tooltip(button, L["Group (verb)"], L["Put this display in a group"]) end);
    group:SetScript("OnLeave", Hide_Tooltip);

    local ungroup = CreateFrame("BUTTON", nil, button);
    button.ungroup = ungroup;
    ungroup:SetWidth(11);
    ungroup:SetHeight(11);
    ungroup:SetPoint("LEFT", button, "LEFT", 0, 0);
    local ungrouptexture = group:CreateTexture(nil, "OVERLAY");
    ungrouptexture:SetTexture("Interface\\MoneyFrame\\Arrow-Left-Down.blp");
    ungrouptexture:SetTexCoord(0.5, 0, 0.5, 1, 1, 0, 1, 1);
    ungrouptexture:SetAllPoints(ungroup);
    ungroup:SetNormalTexture(ungrouptexture);
    ungroup:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
    ungroup:SetScript("OnEnter", function() Show_Tooltip(button, L["Ungroup"], L["Remove this display from its group"]) end);
    ungroup:SetScript("OnLeave", Hide_Tooltip);
    ungroup:Hide();

    local upgroup = CreateFrame("BUTTON", nil, button);
    button.upgroup = upgroup;
    upgroup:SetWidth(11);
    upgroup:SetHeight(11);
    upgroup:SetPoint("TOPLEFT", button, "TOPLEFT", 0, 0);
    local upgrouptexture = group:CreateTexture(nil, "OVERLAY");
    upgroup.texture = upgrouptexture;
    upgrouptexture:SetTexture("Interface\\MoneyFrame\\Arrow-Left-Down.blp");
    upgrouptexture:SetTexCoord(0.5, 1, 1, 1, 0.5, 0, 1, 0);
    upgrouptexture:SetVertexColor(1, 1, 1);
    upgrouptexture:SetAllPoints(upgroup);
    upgroup:SetNormalTexture(upgrouptexture);
    upgroup:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
    upgroup:SetScript("OnEnter", function() Show_Tooltip(button, L["Move Up"], L["Move this display up in its group's order"]) end);
    upgroup:SetScript("OnLeave", Hide_Tooltip);
    upgroup:Hide();

    local downgroup = CreateFrame("BUTTON", nil, button);
    button.downgroup = downgroup;
    downgroup:SetWidth(11);
    downgroup:SetHeight(11);
    downgroup:SetPoint("BOTTOMLEFT", button, "BOTTOMLEFT", 0, 0);
    local downgrouptexture = group:CreateTexture(nil, "OVERLAY");
    downgroup.texture = downgrouptexture;
    downgrouptexture:SetTexture("Interface\\MoneyFrame\\Arrow-Left-Down.blp");
    downgrouptexture:SetTexCoord(1, 0, 0.5, 0, 1, 1, 0.5, 1);
    downgrouptexture:SetAllPoints(downgroup);
    downgroup:SetNormalTexture(downgrouptexture);
    downgroup:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
    downgroup:SetScript("OnEnter", function() Show_Tooltip(button, L["Move Down"], L["Move this display down in its group's order"]) end);
    downgroup:SetScript("OnLeave", Hide_Tooltip);
    downgroup:Hide();

    local expand = CreateFrame("BUTTON", nil, button);
    button.expand = expand;
    expand.expanded = true;
    expand.disabled = true;
    expand.func = function() end;
    expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
    expand:Disable();
    expand:SetWidth(16);
    expand:SetHeight(16);
    expand:SetPoint("BOTTOM", button, "BOTTOM");
    expand:SetPoint("LEFT", icon, "RIGHT", 0, 0);
    expand:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
    expand.title = L["Disabled"];
    expand.desc = L["Expansion is disabled because this group has no children"];
    expand:SetScript("OnEnter", function() Show_Tooltip(button, expand.title, expand.desc) end);
    expand:SetScript("OnLeave", Hide_Tooltip);

    local widget = {
        frame = button,
        title = title,
        icon = icon,
        --delete = delete, -- There is no variable called delete?
        --copy = copy, -- There is no variable called copy?
        view = view,
        --rename = rename, -- There is no variable called rename?
        renamebox = renamebox,
        --descbox = descbox, -- There is no variable called descbox?
        group = group,
        ungroup = ungroup,
        upgroup = upgroup,
        downgroup = downgroup,
        loaded = loaded,
        background = background,
        expand = expand,
        type = Type
    }
    for method, func in pairs(methods) do
        widget[method] = func
    end

    return AceGUI:RegisterAsWidget(widget);
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

local Type, Version = "WeakAurasTextureButton", 21
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- GLOBALS: GameTooltip UIParent WeakAuras WeakAurasOptionsSaved

local function Hide_Tooltip()
  GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:SetPoint("BOTTOM", owner, "TOP");
  GameTooltip:ClearLines();
  GameTooltip:AddLine(line1);
  GameTooltip:AddLine(line2, 1, 1, 1, 1);
  GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(128);
		self:SetHeight(128);
	end,
  ["OnRelease"] = function(self)
    self:ClearPick();
    self.texture:SetTexture();
  end,
  ["SetTexture"] = function(self, texturePath, name)
    self.texture:SetTexture(texturePath);
    self.texture.path = texturePath;
    self.texture.name = name;
  end,
  ["ChangeTexture"] = function(self, r, g, b, a, rotate, discrete_rotation, rotation, mirror, blendMode)
    local ulx,uly , llx,lly , urx,ury , lrx,lry;
    if(rotate) then
      local angle = rad(135 - rotation);
      local vx = math.cos(angle);
      local vy = math.sin(angle);

      ulx,uly , llx,lly , urx,ury , lrx,lry = 0.5+vx,0.5-vy , 0.5-vy,0.5-vx , 0.5+vy,0.5+vx , 0.5-vx,0.5+vy;
    else
      if(discrete_rotation == 0 or discrete_rotation == 360) then
        ulx,uly , llx,lly , urx,ury , lrx,lry = 0,0 , 0,1 , 1,0 , 1,1;
      elseif(discrete_rotation == 90) then
        ulx,uly , llx,lly , urx,ury , lrx,lry = 1,0 , 0,0 , 1,1 , 0,1;
      elseif(discrete_rotation == 180) then
        ulx,uly , llx,lly , urx,ury , lrx,lry = 1,1 , 1,0 , 0,1 , 0,0;
      elseif(discrete_rotation == 270) then
        ulx,uly , llx,lly , urx,ury , lrx,lry = 0,1 , 1,1 , 0,0 , 1,0;
      end
    end
    if(mirror) then
      self.texture:SetTexCoord(urx,ury , lrx,lry , ulx,uly , llx,lly);
    else
      self.texture:SetTexCoord(ulx,uly , llx,lly , urx,ury , lrx,lry);
    end
    self.texture:SetVertexColor(r, g, b, a);
    self.texture:SetBlendMode(blendMode);
  end,
  ["SetTexCoord"] = function(self, left, right, top, bottom)
    self.texture:SetTexCoord(left, right, top, bottom);
  end,
  ["SetOnUpdate"] = function(self, func)
    self.frame:SetScript("OnUpdate", func);
  end,
  ["GetTexturePath"] = function(self)
    return self.texture.path;
  end,
  ["SetClick"] = function(self, func)
    self.frame:SetScript("OnClick", func);
  end,
  ["Pick"] = function(self)
    self.frame:LockHighlight();
  end,
  ["ClearPick"] = function(self)
    self.frame:UnlockHighlight();
  end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
	local name = "WeakAurasTextureButton"..AceGUI:GetNextWidgetNum(Type);
	local button = CreateFrame("BUTTON", name, UIParent, "OptionsListButtonTemplate");
  button:SetHeight(128);
  button:SetWidth(128);
	button:SetBackdrop({
    bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
    edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
    tile = true, tileSize = 16, edgeSize = 16,
    insets = { left = 4, right = 4, top = 4, bottom = 4 }
  });
	button:SetBackdropColor(0.1,0.1,0.1);
	button:SetBackdropBorderColor(0.4,0.4,0.4);

  local highlighttexture = button:CreateTexture(nil, "OVERLAY");
  highlighttexture:SetTexture("Interface\\BUTTONS\\ButtonHilight-SquareQuickslot.blp");
  highlighttexture:SetTexCoord(0.175, 0.875, 0.125, 0.825);
  highlighttexture:SetPoint("BOTTOMLEFT", button, 4, 4);
  highlighttexture:SetPoint("TOPRIGHT", button, -4, -4);
  button:SetHighlightTexture(highlighttexture);

  local texture = button:CreateTexture(nil, "OVERLAY");
  texture:SetPoint("BOTTOMLEFT", button, 4, 4);
  texture:SetPoint("TOPRIGHT", button, -4, -4);

  button:SetScript("OnEnter", function() Show_Tooltip(button, texture.name, texture.path:gsub("\\", "\n")) end);
	button:SetScript("OnLeave", Hide_Tooltip);

	local widget = {
		frame = button,
    texture = texture,
		type = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

local Type, Version = "WeakAurasIconButton", 21
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- GLOBALS: GameTooltip UIParent WeakAuras WeakAurasOptionsSaved

local function Hide_Tooltip()
  GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:SetPoint("BOTTOM", owner, "TOP");
  GameTooltip:ClearLines();
  GameTooltip:AddLine(line1);
  GameTooltip:AddLine(line2, 1, 1, 1, 1);
  GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(52);
		self:SetHeight(52);
	end,
  ["OnRelease"] = function(self)
    self:ClearPick();
    self.texture:SetTexture();
  end,
  ["SetName"] = function(self, name)
    self.texture.name = name;
  end,
  ["GetName"] = function(self)
    return self.texture.name;
  end,
  ["SetTexture"] = function(self, texturePath)
    self.texture.path = texturePath;
    local success = self.texture:SetTexture(texturePath);
    if not(success) then
      self.texture:SetTexture("Interface\\BUTTONS\\UI-Quickslot-Depress.blp");
    end
    return success;
  end,
  ["GetTexturePath"] = function(self)
    return self.texture.path;
  end,
  ["SetClick"] = function(self, func)
    self.frame:SetScript("OnClick", func);
  end,
  ["Pick"] = function(self)
    self.frame:LockHighlight();
  end,
  ["ClearPick"] = function(self)
    self.frame:UnlockHighlight();
  end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
	local button = CreateFrame("BUTTON", nil, UIParent);
  button:SetHeight(52);
  button:SetWidth(52);

  local highlighttexture = button:CreateTexture(nil, "OVERLAY");
  --highlighttexture:SetTexture("Interface\\BUTTONS\\ButtonHilight-SquareQuickslot.blp");
  --highlighttexture:SetTexCoord(0.175, 0.875, 0.125, 0.825);
  highlighttexture:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  highlighttexture:SetVertexColor(0.25, 0.5, 1);
  highlighttexture:SetPoint("BOTTOMLEFT", button, 4, 4);
  highlighttexture:SetPoint("TOPRIGHT", button, -4, -4);
  button:SetHighlightTexture(highlighttexture);

  local texture = button:CreateTexture(nil, "OVERLAY");
  texture:SetAllPoints(button);
  texture.name = "Undefined";

  button:SetScript("OnEnter", function() Show_Tooltip(button, texture.name, texture.path) end);
	button:SetScript("OnLeave", Hide_Tooltip);

	local widget = {
		frame = button,
    texture = texture,
		type = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

local Type, Version = "WeakAurasNewButton", 21
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- GLOBALS: GameTooltip UIParent WeakAuras WeakAurasOptionsSaved

local function Hide_Tooltip()
    GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
    GameTooltip:SetOwner(owner, "ANCHOR_NONE");
    GameTooltip:SetPoint("LEFT", owner, "RIGHT");
    GameTooltip:ClearLines();
    GameTooltip:AddLine(line1);
    GameTooltip:AddLine(line2, 1, 1, 1, 1);
    GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
    ["OnAcquire"] = function(self)
        self:SetWidth(380);
        self:SetHeight(40);
    end,
    ["SetTitle"] = function(self, title)
        self.title:SetText(title);
    end,
    ["GetTitle"] = function(self)
        return self.title:GetText();
    end,
    ["SetDescription"] = function(self, desc)
        self.frame.description = desc;
        self.description:SetText(desc);
    end,
    ["SetClick"] = function(self, func)
        self.frame:SetScript("OnClick", func);
    end,
    ["SetIcon"] = function(self, icon)
        if(type(icon) == "string" or type(icon) == "number") then
            self.icon:SetTexture(icon);
            self.icon:Show();
            if(self.iconRegion and self.iconRegion.Hide) then
                self.iconRegion:Hide();
            end
        else
            self.iconRegion = icon;
            icon:SetAllPoints(self.icon);
            icon:SetParent(self.frame);
            self.icon:Hide();
        end
    end,
    ["OnRelease"] = function(self)
        if(self.iconRegion and self.iconRegion.Hide) then
            self.iconRegion:Hide();
        end
        self.icon:Hide();
        self.frame:UnlockHighlight();
    end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
    local name = "WeakAurasDisplayButton"..AceGUI:GetNextWidgetNum(Type);
    local button = CreateFrame("BUTTON", name, UIParent, "OptionsListButtonTemplate");
    button:SetHeight(40);
    button:SetWidth(380);
    button.dgroup = nil;

    local background = button:CreateTexture(nil, "BACKGROUND");
    button.background = background;
    background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp");
    background:SetBlendMode("ADD");
    background:SetVertexColor(0.5, 0.5, 0.5, 0.25);
    background:SetAllPoints(button);

    local icon = button:CreateTexture(nil, "OVERLAY");
    button.icon = icon;
    icon:SetWidth(40);
    icon:SetHeight(40);
    icon:SetPoint("LEFT", button, "LEFT");

    local title = button:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge");
    button.title = title;
    title:SetHeight(14);
    title:SetJustifyH("LEFT");
    title:SetPoint("TOP", button, "TOP", 0, -5);
    title:SetPoint("LEFT", icon, "RIGHT", 2, 0);
    title:SetPoint("RIGHT", button, "RIGHT");

    local description = button:CreateFontString(nil, "OVERLAY", "GameFontHighlight");
    button.description = description;
    description:SetHeight(14);
    description:SetJustifyH("LEFT");
    description:SetPoint("BOTTOM", button, "BOTTOM", 0, 2);
    description:SetPoint("LEFT", icon, "RIGHT", 2, 0);
    description:SetPoint("RIGHT", button, "RIGHT");


    button.description = "";

    button:SetScript("OnEnter", function() Show_Tooltip(button, title:GetText(), button.description) end);
    button:SetScript("OnLeave", Hide_Tooltip);


    local widget = {
        frame = button,
        title = title,
        icon = icon,
        description = description,
        background = background,
        type = Type
    }
    for method, func in pairs(methods) do
        widget[method] = func
    end

    return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

local Type, Version = "WeakAurasImportButton", 20
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local L = WeakAuras.L;

-- GLOBALS: GameTooltip UIParent WeakAuras WeakAurasOptionsSaved

local function Hide_Tooltip()
    GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
    GameTooltip:SetOwner(owner, "ANCHOR_NONE");
    GameTooltip:SetPoint("LEFT", owner, "RIGHT");
    GameTooltip:ClearLines();
    GameTooltip:AddLine(line1);
    GameTooltip:AddLine(line2, 1, 1, 1, 1);
    GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
    ["OnAcquire"] = function(self)
        self:SetWidth(380);
        self:SetHeight(18);
    end,
    ["SetTitle"] = function(self, title)
        self.title:SetText(title);
    end,
    ["GetTitle"] = function(self)
        return self.title:GetText();
    end,
    ["SetDescription"] = function(self, desc)
        self.frame.description = desc;
    end,
    ["SetIcon"] = function(self, iconPath)
        if(iconPath) then
            local icon = self.frame:CreateTexture();
            icon:SetTexture(iconPath);
            icon:SetPoint("RIGHT", self.frame, "RIGHT");
            icon:SetPoint("BOTTOM", self.frame, "BOTTOM");
            icon:SetWidth(16);
            icon:SetHeight(16);
            self.title:SetPoint("RIGHT", icon, "LEFT");
        end
    end,
    -- ["SetChecked"] = function(self, value)
        -- print("SetChecked", self.title:GetText(), value);
        -- self.checkbox:SetChecked(value);
        -- print("After SetChecked", self.checkbox:GetChecked(), self:GetChecked());
    -- end,
    -- ["GetChecked"] = function(self)
        -- local checked = self.checkbox:GetChecked();
        -- print("GetChecked", self.title:GetText(), checked);
        -- return checked;
    -- end,
    ["SetClick"] = function(self, func)
        self.checkbox:SetScript("OnClick", func);
    end,
    ["Expand"] = function(self, reloadTooltip)
        self.expand:Enable();
        self.expand.expanded = true;
        self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-MinusButton-Up.blp");
        self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-MinusButton-Down.blp");
        self.expand.title = L["Collapse"];
        self.expand:SetScript("OnClick", function() self:Collapse(true) end);
        self.expand.func();
        if(reloadTooltip) then
            Hide_Tooltip();
            Show_Tooltip(self.frame, self.expand.title, nil);
        end
    end,
    ["Collapse"] = function(self, reloadTooltip)
        self.expand:Enable();
        self.expand.expanded = nil;
        self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Up.blp");
        self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-PlusButton-Down.blp");
        self.expand.title = L["Expand"];
        self.expand:SetScript("OnClick", function() self:Expand(true) end);
        self.expand.func();
        if(reloadTooltip) then
            Hide_Tooltip();
            Show_Tooltip(self.frame, self.expand.title, nil);
        end
    end,
    ["SetOnExpandCollapse"] = function(self, func)
        self.expand.func = func;
    end,
    ["GetExpanded"] = function(self)
        return self.expand.expanded;
    end,
    ["DisableExpand"] = function(self)
        self.expand:Disable();
        self.expand.disabled = true;
        self.expand.expanded = false;
        self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
    end,
    ["EnableExpand"] = function(self)
        self.expand.disabled = false;
        if(self:GetExpanded()) then
            self:Expand();
        else
            self:Collapse();
        end
    end,
    ["SetExpandVisible"] = function(self, value)
        if(value) then
            self.expand:Show();
        else
            self.expand:Hide();
        end
    end,
    ["SetLevel"] = function(self, level)
        self.checkbox:SetPoint("left", self.frame, "left", level * 16, 0);
    end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
    local name = "WeakAurasImportButton"..AceGUI:GetNextWidgetNum(Type);
    local button = CreateFrame("BUTTON", name, UIParent, "OptionsListButtonTemplate");
    button:SetHeight(18);
    button:SetWidth(380);
    button.dgroup = nil;

    local background = button:CreateTexture(nil, "BACKGROUND");
    button.background = background;
    background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp");
    background:SetBlendMode("ADD");
    background:SetVertexColor(0.5, 0.5, 0.5, 0.25);
    background:SetAllPoints(button);

    local expand = CreateFrame("BUTTON", nil, button);
    button.expand = expand;
    expand.expanded = true;
    expand.disabled = true;
    expand.func = function() end;
    expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
    expand:Disable();
    expand:SetWidth(16);
    expand:SetHeight(16);
    expand:SetPoint("BOTTOM", button, "BOTTOM");
    expand:SetPoint("LEFT", button, "LEFT");
    expand:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
    expand.title = L["Disabled"];
    expand:SetScript("OnEnter", function() Show_Tooltip(button, expand.title, nil) end);
    expand:SetScript("OnLeave", Hide_Tooltip);

    local checkbox = CreateFrame("CheckButton", nil, button, "ChatConfigCheckButtonTemplate");
    button.checkbox = checkbox;
    checkbox:EnableMouse(false);
    checkbox:SetWidth(18);
    checkbox:SetHeight(18);
    checkbox:SetPoint("BOTTOM", button, "BOTTOM");
    checkbox:SetPoint("LEFT", button, "LEFT", 16);

    local title = button:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge");
    button.title = title;
    title:SetHeight(14);
    title:SetJustifyH("LEFT");
    title:SetPoint("LEFT", checkbox, "RIGHT", 2, 0);
    title:SetPoint("RIGHT", button, "RIGHT");

    button.description = "";

    button:SetScript("OnEnter", function() Show_Tooltip(button, title:GetText(), button.description) end);
    button:SetScript("OnLeave", Hide_Tooltip);

    button:SetScript("OnClick", function() checkbox:Click() end);

    local widget = {
        frame = button,
        title = title,
        checkbox = checkbox,
        expand = expand,
        background = background,
        type = Type
    }
    for method, func in pairs(methods) do
        widget[method] = func
    end

    return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

local Type, Version = "WeakAurasSortedDropdown", 1
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local function Constructor()
  local DropDownConstructor = AceGUI.WidgetRegistry["Dropdown"];
  if (not DropDownConstructor) then
    return nil;
  end
  local widget = DropDownConstructor();
  if (not widget) then
    return nil;
  end

  local oldSetList = widget.SetList
  widget.SetList = function(self, list, order, itemType)
    local orderTable = {};
    for k, v in pairs(list) do
      tinsert(orderTable, { key = k, value = v  });
    end

    table.sort(orderTable, function(a, b)
      return a.value < b.value;
    end);

    local order = {};
    for i, item in ipairs(orderTable) do
      order[i] = item.key;
    end

    oldSetList(self, list, order, itemType)
  end

  widget.type = Type;

  return widget;
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)
